
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.typetuple2</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.typetuple2");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.typetuple2</h1><!-- Generated by Ddoc from dranges\typetuple2.d -->
This module defines templates on typetuples (complementary, sometimes similar to std.typetuple/std.traits):
reversing, rotating, extracting, filtering, unfolding, etc, all on typetuples.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Init</span>
<script>explorer.outline.addDecl('Init');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the .init value of a typetuple. When you have a typetuple (T...)
inside a template, you cannot do (T.init), DMD does not accept it. Use 
<span class="currsymbol">Init</span>
<script>explorer.outline.addDecl('Init');</script>

!T instead.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ExtractType</span>
<script>explorer.outline.addDecl('ExtractType');</script>

(alias array,R...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Extracts some types from the variadic type tuple R according to the indices given by array (a static array).
[0,1,2] means 'the first, second and third types'. The indices can be repeated or omitted and the array
can be longer than R ([0,1,2,2,3,0,0,2,3]...). In the latter case, the resulting type tuple will obviously be longer
than R.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>ExtractType</u>!([0,1],TT) E1;
<font color=blue>alias</font> <u>ExtractType</u>!([1,0],TT) E2;
<font color=blue>alias</font> <u>ExtractType</u>!([1],TT) E3;
<font color=blue>alias</font> <u>ExtractType</u>!([1,0,2,2,0],TT) E4;

<font color=blue>assert</font>(<font color=blue>is</font>(E1 == TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E2 == TypeTuple!(<font color=blue>double</font>,<font color=blue>int</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E3 == TypeTuple!(<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E4 == TypeTuple!(<font color=blue>double</font>,<font color=blue>int</font>,string,string,<font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n,R...) if (R.length &gt; 0 &amp;&amp; n &gt;= 0)<br>template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n,R...) if (R.length &gt; 0 &amp;&amp; n &lt; 0)<br>template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>If n&gt;0, it rotate a TypeTuple on the left by n positions (it takes the first n types and puts them at the end).
for n== 0, it does nothing (it's the identity template).
If n&lt;0, it rotates on the right (takes the last n types and puts them at the beginning).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>RotateTypes</u>!(1,TT) R1;   <font color=green>// (double, string, int)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(0,TT) R0;   <font color=green>// (int, double, string)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(5,TT) R5;   <font color=green>// (string, int, double)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(-1,TT) R_1; <font color=green>// (string, int, double)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(-5,TT) R_5; <font color=green>// (double, string, int)
</font>
<font color=blue>assert</font>(<font color=blue>is</font>(R1 == TypeTuple!(<font color=blue>double</font>,string,<font color=blue>int</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(R0 == TT));
<font color=blue>assert</font>(<font color=blue>is</font>(R5 == TypeTuple!(string,<font color=blue>int</font>,<font color=blue>double</font>))); <font color=green>// equivalent to Rotate!(2,TT)
</font><font color=blue>assert</font>(<font color=blue>is</font>(R_1 == TypeTuple!(string,<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(R_5 == TypeTuple!(<font color=blue>double</font>,string,<font color=blue>int</font>))); <font color=green>// equivalent to Rotate!(-2,TT) and also to Rotate!(1,TT)
</font>
<font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>) TT2;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>RotateTypes</u>!(1,TT2) == TT2)); <font color=green>// one type: unchanged by rotation
</font>
<font color=blue>alias</font> StaticFilter!(isIntegral, TT2) F; <font color=green>// double is not an integral type -&gt; F is empty
</font><font color=blue>assert</font>(<font color=blue>is</font>(<u>RotateTypes</u>!(1,F) == F)); <font color=green>// zero type: also unchanged by rotation.
</font></pre>

To Be Documented: curried version: alias 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

!1 R1;<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FlipType</span>
<script>explorer.outline.addDecl('FlipType');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a type tuple and reverses it.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>FlipType</u>!TT R;
<font color=blue>assert</font>(<font color=blue>is</font>(R == TypeTuple!(string,<font color=blue>double</font>,<font color=blue>int</font>)));

<font color=blue>alias</font> TypeTuple!(<font color=blue>double</font>) TT2;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>FlipType</u>!TT2 == TT2)); <font color=green>// one type: unchanged by inversion.
</font>
<font color=blue>alias</font> StaticFilter!(isIntegral, TT2) F; <font color=green>// double is not an integral type -&gt; F is empty
</font><font color=blue>assert</font>(<font color=blue>is</font>(<u>FlipType</u>!F == F)); <font color=green>// no type: unchanged by inversion.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SwapTypes</span>
<script>explorer.outline.addDecl('SwapTypes');</script>

(size_t i1,size_t i2,R...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Swap the types at index i1 and index i2 in a TypeTuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string, <font color=blue>short</font>) Test;

<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(1,3,Test) == TypeTuple!(<font color=blue>int</font>,<font color=blue>short</font>,string,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(3,1,Test) == TypeTuple!(<font color=blue>int</font>,<font color=blue>short</font>,string,<font color=blue>double</font>)));

<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(1,1,Test) == Test));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SegmentTypes</span>
<script>explorer.outline.addDecl('SegmentTypes');</script>

(int n,T...) if (n &gt; 0 &amp;&amp; T.length % n == 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">allEqual</span>
<script>explorer.outline.addDecl('allEqual');</script>

(alias a,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">AllEqual</span>
<script>explorer.outline.addDecl('AllEqual');</script>

(Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TypeNuple</span>
<script>explorer.outline.addDecl('TypeNuple');</script>

(T,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>creates a TypeTuple of n T's, repeated. If n == 0, it becomes the empty TypeTuple: TypeTuple!().
<pre class="d_code"><font color=blue>alias</font> <u>TypeNuple</u>!(<font color=blue>int</font>, 3) TN3;
<font color=blue>assert</font>(<font color=blue>is</font>(TN3 == TypeTuple!(<font color=blue>int</font>,<font color=blue>int</font>,<font color=blue>int</font>)));
<font color=blue>alias</font> <u>TypeNuple</u>!(<font color=blue>int</font>, 1) TN1;
<font color=blue>assert</font>(<font color=blue>is</font>(TN1 == TypeTuple!(<font color=blue>int</font>)));
<font color=blue>assert</font>(!<font color=blue>is</font>(TN1 == <font color=blue>int</font>)); <font color=green>// TypeTuple!int is not an int.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Expansion</span>
<script>explorer.outline.addDecl('Expansion');</script>

(T : U[n],U,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a static array into a TypeTuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Expansion</u>!(<font color=blue>int</font>[3]) E; <font color=green>// Gives TypeTuple!(int, int, int).
</font></pre>

<br><br>
<b>Note:</b><br>
int[1] gives TypeTuple!(int), which is not of type int.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FlattenTuple</span>
<script>explorer.outline.addDecl('FlattenTuple');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticMap</span>
<script>explorer.outline.addDecl('StaticMap');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Just an exercice: blind-coding std.traits.staticMap. Aliases
itself to the TypeTuple (F!T0, F!T1, ...)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticFilter</span>
<script>explorer.outline.addDecl('StaticFilter');</script>

(alias Pred,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The filter equivalent to StaticMap: alias itself to a TypeTuple
containing the types in T that verify the predicate Pred
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string, <font color=blue>long</font>) TT;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>StaticFilter</u>!(isIntegral, TT) == TypeTuple!(<font color=blue>int</font>, <font color=blue>long</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(<u>StaticFilter</u>!(hasLength2, <font color=blue>int</font>[], <font color=blue>int</font>[3], <font color=blue>int</font>) == TypeTuple!(<font color=blue>int</font>[], <font color=blue>int</font>[3])));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticReduce</span>
<script>explorer.outline.addDecl('StaticReduce');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>aliases itself to a repeated application of the binary template F on the types of T, like reduce
does on ranges.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> CT(T,T2) {
    <font color=blue>alias</font> CommonType!(T,T2) CT;
}

<font color=blue>template</font> Tup(T1,T2) {
    <font color=blue>alias</font> Tuple!(T1, T2) Tup; <font color=green>// That's std.typecons.Tuple, NOT std.typetuple.TypeTuple
</font>}

<font color=blue>alias</font> <u>StaticReduce</u>!(CT, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>long</font>) SR1; <font color=green>// Equivalent to CommonType!(int,double,int,long)
</font><font color=blue>assert</font>(<font color=blue>is</font>(SR1 == <font color=blue>double</font>));
<font color=blue>alias</font> <u>StaticReduce</u>!(Tup, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>long</font>) SR2;
<font color=blue>assert</font>(<font color=blue>is</font>(SR2 == Tuple!(<font color=blue>int</font>, Tuple!(<font color=blue>double</font>, Tuple!(<font color=blue>int</font>, <font color=blue>long</font>))))); <font color=green>// Non-flattening tuples
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">MapOnAlias</span>
<script>explorer.outline.addDecl('MapOnAlias');</script>

(alias Mapper,alias current,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReduceOnAlias</span>
<script>explorer.outline.addDecl('ReduceOnAlias');</script>

(alias Reducer,alias current,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticReduce0</span>
<script>explorer.outline.addDecl('StaticReduce0');</script>

(alias F,alias accumulator,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticScan</span>
<script>explorer.outline.addDecl('StaticScan');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticIterate</span>
<script>explorer.outline.addDecl('StaticIterate');</script>

(size_t times,alias F,T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticIterateOnAlias</span>
<script>explorer.outline.addDecl('StaticIterateOnAlias');</script>

(size_t times,alias F,alias value)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticUnfold</span>
<script>explorer.outline.addDecl('StaticUnfold');</script>

(size_t times,alias F,State...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticStride</span>
<script>explorer.outline.addDecl('StaticStride');</script>

(alias step,T...) if (step &gt; 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticGroup</span>
<script>explorer.outline.addDecl('StaticGroup');</script>

(alias size,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticTakeWhile</span>
<script>explorer.outline.addDecl('StaticTakeWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticDropWhile</span>
<script>explorer.outline.addDecl('StaticDropWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRotateWhile</span>
<script>explorer.outline.addDecl('StaticRotateWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias to)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias from,alias to)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias from,alias to,alias step)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SortTypes</span>
<script>explorer.outline.addDecl('SortTypes');</script>

(alias Pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sort types in Types, according to predicate Pred. Pred is a binary template
that must alias itself to 0 if types are equal, to -1 if T1 &lt; T2 and +1 if T1 &gt; T2.
If you do not care for the precise ordering (such as when you just want to verify that two tuples
are the same), you can use dranges.templates.CompareTypes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">NthType</span>
<script>explorer.outline.addDecl('NthType');</script>

(size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the nth field/type in a TypeTuple. Useful for template composition.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">First</span>
<script>explorer.outline.addDecl('First');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as NthType. Alias itself to the first type in a typetuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Second</span>
<script>explorer.outline.addDecl('Second');</script>

(T...) if (T.length &gt; 1)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as NthType. Alias itself to the second type in a typetuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Last</span>
<script>explorer.outline.addDecl('Last');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the last type in a TypeTuple. As the previous template, it's sometimes useful
while composing templates.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Tail</span>
<script>explorer.outline.addDecl('Tail');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to all types except the first in a TypeTuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Doubler</span>
<script>explorer.outline.addDecl('Doubler');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Doubles a TypeTuple. ie: from (int, double), makes a (int,double,int,double).<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sat May 15 22:50:10 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

	explorer.packageExplorer.addModule("dranges.algorithm2");

	explorer.packageExplorer.addModule("dranges.associative");

	explorer.packageExplorer.addModule("dranges.eager");

	explorer.packageExplorer.addModule("dranges.experiments");

	explorer.packageExplorer.addModule("dranges.functional2");

	explorer.packageExplorer.addModule("dranges.morphism");

	explorer.packageExplorer.addModule("dranges.patternmatch");

	explorer.packageExplorer.addModule("dranges.phobos_extension");

	explorer.packageExplorer.addModule("dranges.predicate");

	explorer.packageExplorer.addModule("dranges.range2");

	explorer.packageExplorer.addModule("dranges.rangeofranges");

	explorer.packageExplorer.addModule("dranges.recursive");

	explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.templates");

	explorer.packageExplorer.addModule("dranges.traits2");

	explorer.packageExplorer.addModule("dranges.treerange");

	explorer.packageExplorer.addModule("dranges.tuple2");

	explorer.packageExplorer.addModule("dranges.typetuple2");

	explorer.packageExplorer.addModule("dranges.variadic");

	
</script>
</body></html>


