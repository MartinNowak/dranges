
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.patternmatch</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.patternmatch");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.patternmatch</h1><!-- Generated by Ddoc from dranges\patternmatch.d -->
This module leverages the pattern-matching nature of templates to provide a basic pattern-matching
function. The main function here is <b><code>match</code></b>, the engine behind ($ dranges.functional.eitherFun).
See below for more doc.
<br><br>
My goal is to link into a coherent whole all the pattern-matching modules in dranges: this one, <b><code>dranges.typepattern</code></b>,
<b><code>dranges.tuplepattern</code></b>, <b><code>drange.ctre</code></b> and maybe use them to map and transform tuple-trees. A far-away
but inspirational goal is to get an AST from D code, transform it and recombine it into another AST, reducing it down
to a string reprensenting D code. That is, a sort of macro system for D. It's but a dream, but it's a also a fun journey.

<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

(alias fun,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b><code>
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

</code></b> is a pattern taking any number of function, templated or not, as input. When you then pass it a value,
<b><code>
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

</code></b> will test the value with the passed-in functions in the order they were passed-in,
see if they 
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

 or not and return the result of the first function that matches.
If no function matches, <b><code>
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

</code></b> will throw a <b><code>NoMatchException</code></b>.
<br><br>
The provided functions are template parameters and so must be known at compile-time.
<br><br>

The interesting part is that, being a template and acting on templated functions, <b><code>
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

</code></b> can potentially accept any type
and return any other type. It uses the inherent pattern-matching done by templates to find a 
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

. All the type-patterns and template constraints
you're used to can be used there.
<br><br>

For example:
<pre class="d_code">T one(T)(T t) { <font color=blue>return</font> t;} <font color=green>// matches any lone type
</font>
T[] twoEqual(T)(T t1, T t2) { <font color=blue>return</font> [t1,t2];} <font color=green>// matches if the input is twice the same type
</font>
Tuple!(T,U) twoDiff(T,U)(T t, U u) { <font color=blue>return</font> tuple(t,u);} <font color=green>// Matches any two types
</font>
string three(T)(T t1, T t2, T t3) { <font color=blue>return</font> T.stringof ~ <font color=red>" thrice"</font>;} <font color=green>// Thrice the same type
</font>
string threeDiff(T,U,V)(T t, U u, V v) <font color=green>// Any three types.
</font>    { <font color=blue>return</font> T.stringof ~ <font color=red>" "</font> ~ U.stringof ~ <font color=red>" "</font> ~ V.stringof;}

<font color=blue>alias</font> <u>match</u>!(one,
             twoEqual,
             twoDiff,
             three,
             threeDiff,
             any) m;

<font color=blue>assert</font>(m(1) == 1);              <font color=green>// one type
</font><font color=blue>assert</font>(m('a','b') = ['a','b']);  <font color=green>// twice the same type. twoEqual is tested before two
</font><font color=blue>assert</font>(m('a', 2.34) == tuple('a',2.34)); <font color=green>// two different types. twoEqual is not activated, but twoDiff is.
</font>m(<font color=red>"aha"</font>, 1, 3.1415, 'a'); <font color=green>// no match!
</font></pre>

<br><br>
<b>See Also:</b><br>
.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">amatch</span>
<script>explorer.outline.addDecl('amatch');</script>

(Funs...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another matching function, this one working on algebraic types from <b><code>std.typecons</code></b>.
The passed-in functions must be standard, non-templated functions which all return the same type
and must match the types allowed by the algebraic.
That is, if you have an <b><code>Algebraic!(int, double, string)</code></b>,
one function must accept an int, another must accept a double and a third must accept
a string. Or rather, given this triplet of function <b><code>
<span class="currsymbol">amatch</span>
<script>explorer.outline.addDecl('amatch');</script>

!(funs)</code></b> will not accept
an <b><code>Algebraic</code></b> which does not have <b><code>int</code></b>, <b><code>string</code></b> and <b><code>double</code></b> as allowed types.
Note that the order is not important, the types are all sorted internally.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Algebraic!(<font color=blue>int</font>, string, <font color=blue>double</font>) alg;

string foo(<font color=blue>int</font> i) { <font color=blue>return</font> to!string(i+1);}
string bar(<font color=blue>double</font> d) { <font color=blue>return</font> to!string(d*d);}
string baz(string s) { <font color=blue>return</font> <font color=red>""</font>;}
<font color=blue>alias</font> <u>amatch</u>!(foo,bar,baz) matcher;

alg = 3;
<font color=blue>assert</font>(matcher(alg) == <font color=red>"4"</font>); <font color=green>// int function activated.
</font>alg = <font color=red>"abc"</font>;
<font color=blue>assert</font>(matcher(alg) == <font color=red>""</font>);  <font color=green>// string function activated.
</font>alg = 3.0;
<font color=blue>assert</font>(matcher(alg) == <font color=red>"9.0"</font>); <font color=green>// int function activated.
</font></pre>
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Fri Nov 12 11:55:10 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

	explorer.packageExplorer.addModule("dranges.lambda");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


