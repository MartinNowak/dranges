
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.algorithm</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.algorithm");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.algorithm</h1><!-- Generated by Ddoc from dranges\algorithm.d -->
This module contains functions akin to <b><code>map</code></b> and <b><code>filter</code></b>, found in <b><code>std.
<span class="currsymbol">algorithm</span>
<script>explorer.outline.addDecl('algorithm');</script>

</code></b>.
You'll find there generalizations of these functions to act on a variadic numbers
of ranges in parallel (<b><code>tmap</code></b>, <b><code>tfilter</code></b>) or to map n-ary functions on a range (<b><code>nmap</code></b>, <b><code>nfilter</code></b>).
There are also many function inspired by the sequence/list/map libraries of other (functional) programming
languages (namely, Haskell, Clojure, Scala, Python) : a range comprehension,
zipping ranges, <b><code>reduceR</code></b>, <b><code>fold</code></b>/<b><code>foldR</code></b>, <b><code>scan</code></b>/<b><code>scanR</code></b>, and so on.
<br><br>
As far as possible, all higher-order ranges presented in this module
and in <b><code>dranges.range</code></b> are 'tight wrappers': they are bidirectional if their input range is bidirectional,
define <b><code>opIndex</code></b>, <b><code>opIndexAssign</code></b>, <b><code>length</code></b> if it's possible, etc. That way, a good input range (for example, a random-access range)
will see its properties propagated through a chain of calls.

<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(R) 
<span class="currsymbol">sum</span>
<script>explorer.outline.addDecl('sum');</script>

(R)(R <span class="funcparam">range</span>);
<br>ElementType!(R) 
<span class="currsymbol">product</span>
<script>explorer.outline.addDecl('product');</script>

(R)(R <span class="funcparam">range</span>);
<br>ElementType!(R) 
<span class="currsymbol">maxOf</span>
<script>explorer.outline.addDecl('maxOf');</script>

(R)(R <span class="funcparam">range</span>);
<br>ElementType!(R) 
<span class="currsymbol">minOf</span>
<script>explorer.outline.addDecl('minOf');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Small one-liners to use reduce. Sum and product work on empty ranges (they return 0 and 1, respectively),
but not minOf and maxOf.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [1,2,3,4,5];
<font color=blue>auto</font> r2 = [-1.0,2.7818281828, 3.1415926];

<font color=blue>assert</font>(<u>sum</u>(r1) == 1+2+3+4+5);
<font color=blue>assert</font>(product(r1) == 1*2*3*4*5);
<font color=blue>assert</font>(minOf(r2) == -1.0);
<font color=blue>assert</font>(maxOf(r2) == 3.1415926);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t[ElementType!(R)] 
<span class="currsymbol">frequency</span>
<script>explorer.outline.addDecl('frequency');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns an associative array containing the number of times each element
is present in the range. It's a greedy algorithm: it does not work
on infinite ranges.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = <font color=red>"Mississippi"</font>;
<font color=blue>auto</font> f = <u>frequency</u>(r);
<font color=blue>assert</font>(f['i'] == 4);
<font color=blue>assert</font>(f['s'] == 4);
<font color=blue>assert</font>(f['M'] == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NMapType!(fun,R) 
<span class="currsymbol">nmap</span>
<script>explorer.outline.addDecl('nmap');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps a n-ary function on a range, taking n-elements segment at a time. You can use
standard functions or 'string' functions. For string functions, it will automatically determine their arity.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5,6];
<font color=blue>auto</font> nm1 = <u>nmap</u>!<font color=red>"a*b"</font>(r1); <font color=green>// Will map "a*b" on (0,1), (1,2), (2,3), (3,4), (4,5), (5,6)
</font><font color=blue>assert</font>(equal(nm1, [0,2,6,12,20,30][]));

<font color=green>// Will map "a*b*c"/"a+b+c" alternatively on (0,1,2), (1,2,3), (2,3,4), (3,4,5), (4,5,6)
</font><font color=blue>auto</font> nm2 = <u>nmap</u>!<font color=red>"a%2 == 0 ? a*b*c : a+b+c"</font>(r1);
<font color=blue>assert</font>(equal(nm2, [0,6,24,12,120][]));

<font color=blue>auto</font> nm3 = <u>nmap</u>!<font color=red>"a"</font>(r1); <font color=green>// Will map "a" on (0), (1), (2), ...
</font><font color=blue>assert</font>(equal(nm3, [0,1,2,3,4,5,6][])); <font color=green>// Completly equivalent to map!"a"(r1)
</font>
<font color=blue>int</font>[] e;
<font color=blue>auto</font> nm4 = <u>nmap</u>!<font color=red>"a%2 == 0 ? a*b*c : a+b+c"</font>(e); <font color=green>// e is empty -&gt; cannot map a ternary function on it
</font><font color=blue>assert</font>(nm4.empty);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!(fun,R) 
<span class="currsymbol">tmap</span>
<script>explorer.outline.addDecl('tmap');</script>

(alias fun, R...)(R <span class="funcparam">ranges</span>);
<br>TMapType!(fun,R) 
<span class="currsymbol">tmap</span>
<script>explorer.outline.addDecl('tmap');</script>

(alias fun, R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps a n-args function on either n ranges in parallel or on an n-tuple producing range.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// With functions mapped on n ranges in parallel:
</font><font color=blue>auto</font> r1 = [1,2,3,4,5,6];
string s = <font color=red>"abcdefghijk"</font>;

<font color=blue>auto</font> tm1 = <u>tmap</u>!<font color=red>"replicate(a,b)"</font>(r1,s); <font color=green>// [a], [b,b], [c,c,c], [d,d,d,d], ...
</font><font color=blue>assert</font>(equal(flatten(tm1), <font color=red>"abbcccddddeeeeeffffff"</font>)); <font color=green>// Note the use of flatten
</font>
<font color=blue>auto</font> tm2 = <u>tmap</u>!<font color=red>"a%2 == 0 ? b : '_'"</font>(r1,s); <font color=green>// alternate between a char from s and '_'
</font><font color=blue>assert</font>(equal(tm2, <font color=red>"_b_d_f"</font>));

<font color=blue>auto</font> tm3 = <u>tmap</u>!<font color=red>"a%2==0 ? b : c"</font>(r1,s,flatten(tm1)); <font color=green>// ternary function mapped on three ranges in parallel
</font><font color=blue>assert</font>(equal(tm3, <font color=red>"abbdcf"</font>));

string e = <font color=red>""</font>;
<font color=blue>assert</font>(<u>tmap</u>!<font color=red>"a"</font>(r1, s, e).empty); <font color=green>// e is empty -&gt; tmap also
</font></pre>

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// With functions mapped on a tuple-producing range:
</font>
<font color=blue>auto</font> tf = tfilter!<font color=red>"a%2"</font>(r1, s); <font color=green>// keeps the odd elements from r1, produces 2-tuples (1,'a'),(3,'c'),(5,'e')
</font>string foo(<font color=blue>int</font> a, <font color=blue>char</font> b) { <font color=blue>return</font> to!string(array(replicate(a,b)));}
<font color=blue>auto</font> tm4 = <u>tmap</u>!foo(tf); <font color=green>// maps a standard binary function on a 2-tuple range
</font><font color=blue>assert</font>(equal(tm4, [<font color=red>"a"</font>,<font color=red>"ccc"</font>,<font color=red>"eeeee"</font>][]));

<font color=blue>auto</font> r2 = [1,2,3][];
<font color=green>// combinations(r2,r2) is equivalent to [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)][]
</font><font color=blue>auto</font> combs = <u>tmap</u>!<font color=red>"a*b"</font>(combinations(r2,r2));
<font color=blue>assert</font>(equal(combs, [1,2,3,2,4,6,3,6,9][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NFilterType!(fun,step,R) 
<span class="currsymbol">nfilter</span>
<script>explorer.outline.addDecl('nfilter');</script>

(alias fun, size_t step = 1, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>
<span class="currsymbol">nfilter</span>
<script>explorer.outline.addDecl('nfilter');</script>

 takes a n-args predicate and a range and outputs the n-uplets that verify the predicate.
As with other n-args functions on ranges (dropWhile, takeWhile, nmap, ...) it accepts
'string' functions and adapts its behavior accordingly.
It also takes an optional step argument, defaulting to 1 (see the examples).
<br><br>
To use it easily with other ranges, 
<span class="currsymbol">nfilter</span>
<script>explorer.outline.addDecl('nfilter');</script>

 produces tuples, not arrays.
That also means that if you use a unary predicate it will produce the same
values than std.algorithm.filter but wrapped in a tuple. (tuple(1), ...)
<br><br>


<br><br>
<b>TODO:</b><br>
Fuse the array-returning version and the tuple-returning version and control the behavior with a policy. Do that also
with the sibling functions: dropWhile, takeWhile, nmap.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,3,5,4,3,2,1,0];
<font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b, <font color=blue>int</font> c) { <font color=blue>return</font> a&lt;=b &amp;&amp; b&lt;=c;} <font color=green>// increase on three elements
</font><font color=blue>auto</font> nf1 = <u>nfilter</u>!(foo)(r1);
<font color=blue>assert</font>(equal(nf1, [tuple(0,1,2), tuple(1,2,3), tuple(2,3,3), tuple(3,3,5)][]));

<font color=blue>auto</font> nf2 = <u>nfilter</u>!<font color=red>"a&lt;=b &amp;&amp; b&lt;=c"</font>(r1); <font color=green>// The same with a string function.
</font>                                       <font color=green>// Automatically deduces that the predicate is a 3-args function.
</font><font color=blue>assert</font>(equal(nf2, [tuple(0,1,2), tuple(1,2,3), tuple(2,3,3), tuple(3,3,5)][]));

<font color=blue>auto</font> nf3 = <u>nfilter</u>!(<font color=red>"a == b-1 || a == b+1"</font>, 2)(r1); <font color=green>// step of 2, will test (0,1) (2,3), (3,5), (4,3), (2,1)
</font><font color=blue>assert</font>(equal(nf3, [tuple(0,1), tuple(2,3), tuple(4,3), tuple(2,1)][]));

<font color=blue>auto</font> nf4 = <u>nfilter</u>!<font color=red>"a&gt;100"</font>(r1); <font color=green>// this predicate is always false
</font><font color=blue>assert</font>(nf4.empty);              <font color=green>// the filtered range is empty.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TFilterType!(fun,R) 
<span class="currsymbol">tfilter</span>
<script>explorer.outline.addDecl('tfilter');</script>

(alias fun, R...)(R <span class="funcparam">ranges</span>);
<br>TFilterType!(fun,R) 
<span class="currsymbol">tfilter</span>
<script>explorer.outline.addDecl('tfilter');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>
<span class="currsymbol">tfilter</span>
<script>explorer.outline.addDecl('tfilter');</script>

 stands for tuple-filter: it either filters a variadic list of ranges in lockstep,
with a n-args predicate spanning all ranges or filters a tuple-returning range with a function.
In all cases, it returns the n-tuples that satisfy the predicate.
<br><br>
It can take standard functions or 'string' functions.
<br><br>

The first arg will be filled with the front from the first field or range element, the second arg with the second field or range and so on.
That's a,b,c,d... for a string function.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// Filtering n ranges in parallel
</font><font color=blue>auto</font>    r1 = [ 0,   1,   2,   3,   4,   5];
<font color=blue>auto</font> r2 = [ 3.0, 4.0, 5.0, 6.0];
string[] r3 = [<font color=red>"a"</font>, <font color=red>"b"</font>, <font color=red>"cc"</font>];

<font color=green>// standard function
</font><font color=blue>bool</font> pred(<font color=blue>int</font> a, <font color=blue>double</font> b, string c) { <font color=blue>return</font> (a&lt;b) &amp;&amp; (c.length&gt;1);}
<font color=blue>auto</font> tf1 = <u>tfilter</u>!(pred)(r1,r2,r3);
<font color=blue>assert</font>(equal(tf1, [tuple(2, 5.0, <font color=red>"cc"</font>)][]));       <font color=green>// tf1 is just (2, 5.0, "cc)
</font>
<font color=green>// string function
</font><font color=blue>auto</font> tf2 = <u>tfilter</u>!<font color=red>"a&lt;b &amp;&amp; c.length&gt;1"</font>(r1,r2,r3); <font color=green>// knows arity must be 3. Will instantiate the (int,double,string) version
</font><font color=blue>assert</font>(equal(tf2, [tuple(2, 5.0, <font color=red>"cc"</font>)][]));      <font color=green>// tf2 is equal to tf1
</font>
<font color=blue>auto</font> tf3 = <u>tfilter</u>!<font color=red>"a*a&gt;b"</font>(r1, r2);
<font color=blue>assert</font>(equal(tf3, [tuple(3, 6.0)][]));            <font color=green>// Only one tuple satisfies a*a&gt;b before reaching the end of r2
</font>
<font color=green>// templated predicate
</font><font color=blue>bool</font> pred2(T,U)(T t, U u) { <font color=blue>return</font> t*t&gt;u;}
<font color=blue>auto</font> tf4 = <u>tfilter</u>!(pred2!(<font color=blue>int</font>, <font color=blue>double</font>))(r1, r2); <font color=green>// it doesn't automatically instantiate the correct function from a template.
</font><font color=blue>assert</font>(equal(tf4, [tuple(3,6.0)][]));             <font color=green>// because tfilter has no way to know which types the template is waiting for.
</font></pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Filtering a tuple-returning range with a function:
</font>
<font color=green>// combinations(r1,r3) is equivalent to [(0,"a"),(0,"b"),(0,"cc"),(1,"a), ..., (5,"a),(5,"b),(5,"cc")][]
</font><font color=blue>auto</font> tf5 = <u>tfilter</u>!<font color=red>"a%2 &amp;&amp; b.length&gt;1"</font>(combinations(r1,r3));

<font color=blue>assert</font>(equal(tf5, [tuple(1,<font color=red>"cc"</font>),tuple(3,<font color=red>"cc"</font>),tuple(5,<font color=red>"cc"</font>)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">reduceR</span>
<script>explorer.outline.addDecl('reduceR');</script>

(fun...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The complementary function to reduce: it reduces a (bidirectional) range from the right
reduce!fun(seed, range) applies successively the binary function fun
to the left elements of range (beginning with seed)
and produces fun(fun(... fun(fun(seed, range.front), range[1])...)).
<br><br>
By comparison, 
<span class="currsymbol">reduceR</span>
<script>explorer.outline.addDecl('reduceR');</script>

!fun(seed, range) applies successively fun to the right elements of range (also beginning
with seed or range.back, if seed is not given) and produces: fun(fun(... fun(range[$-2], fun(range.back, seed)) ...)).
If fun is not a commutative operation (that is, if fun(a,b) != fun(b,a) in general), then 
<span class="currsymbol">reduceR</span>
<script>explorer.outline.addDecl('reduceR');</script>

 will
produce different results from reduce. See for example the lines with reduce!"a/b" and 
<span class="currsymbol">reduceR</span>
<script>explorer.outline.addDecl('reduceR');</script>

!"a/b".
<br><br>

Like reduce, it accepts many functions at the same time. In that case, the result is a tuple of the different values.
<br><br>
<b>Note:</b><br>
It's completly based on std.algorithm.reduce's code.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> a = [ 3, 4 ];
<font color=blue>auto</font> r = reduce!(<font color=red>"a + b"</font>)(0, a);
<font color=blue>assert</font>(r == 7);
<font color=blue>auto</font> rR = <u>reduceR</u>!(<font color=red>"a + b"</font>)(0, a); <font color=green>// a+b is commutative -&gt; same result than reduce
</font><font color=blue>assert</font>(rR == 7);

r = reduce!<font color=red>"a+b"</font>(a);
<font color=blue>assert</font>(r == 7);
rR = <u>reduceR</u>!<font color=red>"a+b"</font>(a); <font color=green>// Without seed value
</font><font color=blue>assert</font>(rR == 7);

<font color=blue>auto</font> a2 = [1.0,2.0,3.0,4.0];
<font color=blue>auto</font> r2 = reduce!<font color=red>"a / b"</font>(a2);
<font color=blue>assert</font>(r2 == (((1.0)/2.0)/3.0)/4.0 );
<font color=blue>auto</font> rR2 = <u>reduceR</u>!<font color=red>"a / b"</font>(a2);
<font color=blue>assert</font>(rR2 == 1.0/(2.0/(3.0/(4.0))) ); <font color=green>// a/b is not a commutative operation
</font>
a = [ 1, 2, 3, 4, 5 ];
<font color=green>// Stringize with commas
</font><font color=green>// the function has been 'symmetrized' compared to reduce's unittest
</font>string rep = reduce!(<font color=red>"to!string(a) ~ `, ` ~ to!(string)(b)"</font>)(<font color=red>""</font>, a);
<font color=blue>assert</font>(rep[2 .. $] == <font color=red>"1, 2, 3, 4, 5"</font>);
string repR = <u>reduceR</u>!(<font color=red>"to!string(a) ~ `, ` ~ to!string(b)"</font>)(<font color=red>""</font>, a);
<font color=blue>assert</font>(repR[0 .. $-2] == <font color=red>"1, 2, 3, 4, 5"</font>);

<font color=green>// Continued fraction
</font><font color=blue>double</font> continuedFraction(<font color=blue>double</font> a, <font color=blue>double</font> b) { <font color=blue>return</font> a + 1.0/b;}
<font color=blue>auto</font> piFrac = [3, 7, 15, 1, 292];         <font color=green>// pi continued fraction,
</font>                                              <font color=green>// 3.141592 is approx. 3 + 1/(7 + 1/(15 + 1/(1 + 1/(292 + 1/...))))
</font><font color=blue>auto</font> pi2 = <u>reduceR</u>!continuedFraction(piFrac); <font color=green>// calculates the continued fraction: needs reduceR as reduce wouldn't make it
</font><font color=blue>assert</font>(approxEqual(pi2, PI));                 <font color=green>// check
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Iterate</span>
<script>explorer.outline.addDecl('Iterate');</script>

(alias fun,S);
<br>Iterate!(fun,S) 
<span class="currsymbol">iterate</span>
<script>explorer.outline.addDecl('iterate');</script>

(alias fun, S)(S <span class="funcparam">seed</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a function fun and a seed value, iterate repeatedly applies fun
and produces the infinite range seed, fun(seed), fun(fun(seed)), fun(fun(fun(seed))), ...
opIndex is defined, but may take some time (if you ask for a high index).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Generating the natural numbers
</font><font color=blue>auto</font> natural = iterate!<font color=red>"a+1"</font>(0);    <font color=green>// 0,1,2,3,4,5, (as ints)
</font><font color=blue>assert</font>(equal(take(5, natural), [0,1,2,3,4][]));

<font color=green>// Generating powers of two
</font><font color=blue>auto</font> powersOf(size_t n)() { <font color=blue>return</font> iterate!(to!string(n) ~ <font color=red>"*a"</font>)(1L); <font color=green>// 1, n, n*n, n*n*n, n*n*n*n (as longs)
</font><font color=blue>assert</font>(equal(take(5, powersOf!2), [1,2,4,8,16][]));
<font color=blue>assert</font>(powersOf!2[10] == 1024); <font color=green>// opIndex is defined
</font>
<font color=green>// Converging on a value
</font><font color=green>// (x+n/x)/2 applied repeatedly converges towards sqrt(n)
</font><font color=blue>auto</font> sqrtOf(size_t n)() {
    <font color=blue>return</font> iterate!Format(<font color=red>"(a + %s/a)/2"</font>, n)(1.0);
}
<font color=blue>auto</font> sqrt2 = sqrtOf!2; <font color=green>// Converges towards sqrt(2), 1.414
</font>popFrontN(sqrt2, 4); <font color=green>// letting it converge
</font><font color=blue>assert</font>(approxEqual(sqrt2.front, sqrt(2.0), 0.0000001)); <font color=green>// 5 iterations, already quite good
</font>
<font color=green>// Conway's 'Look and Say' sequence
</font><font color=green>// http://en.wikipedia.org/wiki/Look_and_say_sequence
</font><font color=blue>int</font>[] LookAndSay(<font color=blue>int</font>[] r) {
    <font color=blue>int</font>[] e;
    <font color=blue>return</font> reduce!<font color=red>"a ~ b.field[1] ~ b.field[0]"</font>(e, std.algorithm.group(r));
}

<font color=blue>auto</font> conwaySequence = iterate!LookAndSay([1][]);
<font color=blue>assert</font>(equal(take(6, conwaySequence), [[1][],          <font color=green>/+ One 1 +/</font>
                                       [1,1][],        <font color=green>/+ Two 1s +/</font>
                                       [2,1][],        <font color=green>/+ One 2, one 1+/</font>
                                       [1,2,1,1][],    <font color=green>/+ One 1, one 2, two 1s+/</font>
                                       [1,1,1,2,2,1][],<font color=green>/+ Three 1s, two 2s, one 1+/</font>
                                       [3,1,2,2,1,1][]
                                       ][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Scan</span>
<script>explorer.outline.addDecl('Scan');</script>

(alias fun,S,R) if (isForwardRange!(R));
<br>Scan!(fun,S,R) 
<span class="currsymbol">scan</span>
<script>explorer.outline.addDecl('scan');</script>

(alias fun, S, R)(S <span class="funcparam">seed</span>, R <span class="funcparam">range</span>);
<br>Scan!(fun,ElementType!(R),R) 
<span class="currsymbol">scan</span>
<script>explorer.outline.addDecl('scan');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A range that produces the successive result of reduce!fun(seed, range).
[seed, fun(seed, range.front), fun(fun(seed, range.front), range[1]), ...]
It's useful to get moving calculations, like moving sums, products, minima, etc.
Taken from Haskell.
<br><br>
<b>Note:</b><br>
only the one-function version is implemented. scan!(max, min, foo)(r) is not possible right now,
though not difficult to code...

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// moving sum
</font><font color=blue>auto</font> r1 = [1,2,3,4];
<font color=blue>auto</font> s = scan!<font color=red>"a+b"</font>(0,r1);
<font color=blue>assert</font>(equal(s, [0,1,3,6,10][])); <font color=green>// 0, 0+1, 0+1+2, 0+1+2+3, 0+1+2+3+4
</font>s = scan!<font color=red>"a+b"</font>(r1);
<font color=blue>assert</font>(equal(s, [1,3,6,10][])); <font color=green>// 1, 1+2, 1+2+3, 1+2+3+4
</font>
<font color=green>// factorials
</font><font color=blue>auto</font> fac = scan!<font color=red>"a*b"</font>(1L, numbers(1)); <font color=green>// numbers(1) is 1,2,3,4,5,6,...
</font><font color=blue>assert</font>(equal(take(fac,6), [1,1,2,6,24,120][])); <font color=green>// 1, 1*1, 1*1*2, 1*1*2*3, 1*1*2*3*4, 1*1*2*3*4*5
</font>
<font color=green>//Moving minima
</font><font color=blue>auto</font> r2 = [1,2, -1, -4, 0, 3, 4];
<font color=blue>auto</font> r = scan!min(0,r2);
<font color=blue>assert</font>(equal(r, [0,0,0,-1,-4,-4,-4,-4][]));
r = scan!min(r2);
<font color=blue>assert</font>(equal(r, [1,1,-1,-4,-4,-4,-4][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Scan2</span>
<script>explorer.outline.addDecl('Scan2');</script>

(alias fun,S,R) if (isForwardRange!(R));
<br>Scan2!(fun,S,R) 
<span class="currsymbol">scan2</span>
<script>explorer.outline.addDecl('scan2');</script>

(alias fun, S, R)(S <span class="funcparam">seed</span>, R <span class="funcparam">range</span>);
<br>Scan2!(fun,ElementType!(R),R) 
<span class="currsymbol">scan2</span>
<script>explorer.outline.addDecl('scan2');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A variation on scan: this range returns the same values than scan, but paired
with the rest of the range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> arr = [1,2,3,4];
<font color=green>// running sum
</font><font color=blue>assert</font>(equal(scan!<font color=red>"a+b"</font>(0,arr),  [0,1,3,6,10]));
<font color=green>// sum with rest of range
</font><font color=blue>assert</font>(equal(scan2!<font color=red>"a+b"</font>(0,arr), [tuple(0, [1,2,3,4][]),
                                  tuple(1, [2,3,4][]),
                                  tuple(3, [3,4][]),
                                  tuple(6, [4][]),
                                  tuple(10,(<font color=blue>int</font>[]).init)]));

</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ScanR</span>
<script>explorer.outline.addDecl('ScanR');</script>

(alias fun,S,R) if (isBidirectionalRange!(R));
<br>ScanR!(fun,S,R) 
<span class="currsymbol">scanR</span>
<script>explorer.outline.addDecl('scanR');</script>

(alias fun, S, R)(S <span class="funcparam">seed</span>, R <span class="funcparam">range</span>);
<br>ScanR!(fun,ElementType!(R),R) 
<span class="currsymbol">scanR</span>
<script>explorer.outline.addDecl('scanR');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The cousin of scan. A range that produces the successive result of reduceR!fun(seed, range):
[seed, fun(range.back, seed), fun(range[1], fun(range.back, seed)), ...]
Taken from Haskell.
<br><br>
<b>See Also:</b><br>
scan, reduce, reduceR
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [1,2,3,4];
<font color=blue>auto</font> s = scanR!<font color=red>"a+b"</font>(0,r1); <font color=green>// moving sum
</font><font color=blue>assert</font>(equal(s, [0,4,7,9,10][])); <font color=green>// 0, 4+0, 3+4+0, 2+3+4+0, 1+2+3+4+0
</font>s = scanR!<font color=red>"a+b"</font>(r1);
<font color=blue>assert</font>(equal(s, [4,7,9,10][]));
<font color=blue>auto</font> r2 = [1,2, -1, -4, 0, 3, 4];
<font color=blue>auto</font> r = scanR!min(0,r2); <font color=green>// moving minimum
</font><font color=blue>assert</font>(equal(r, [0,0,0,0,-4,-4,-4,-4][]));
r = scanR!min(r2);
<font color=blue>assert</font>(equal(r, [4,3,0,-4,-4,-4,-4][]));

<font color=blue>int</font>[] e;
<font color=blue>assert</font>(scanR!<font color=red>"a+b"</font>(e).empty);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TScan</span>
<script>explorer.outline.addDecl('TScan');</script>

(alias fun,S,R...) if (allSatisfy!(isForwardRange,R));
<br>TScan!(fun,S,R) 
<span class="currsymbol">tscan0</span>
<script>explorer.outline.addDecl('tscan0');</script>

(alias fun, S, R...)(S <span class="funcparam">seed</span>, R <span class="funcparam">ranges</span>);
<br>TScan!(fun,ElementType!(Knit!(R)),R) 
<span class="currsymbol">tscan</span>
<script>explorer.outline.addDecl('tscan');</script>

(alias fun, R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>
The n-ranges-in-parallel version of scan.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TScanR</span>
<script>explorer.outline.addDecl('TScanR');</script>

(alias fun,S,R...) if (allSatisfy!(isBidirectionalRange,R));
<br>TScanR!(fun,S,R) 
<span class="currsymbol">tscanR0</span>
<script>explorer.outline.addDecl('tscanR0');</script>

(alias fun, S, R...)(S <span class="funcparam">seed</span>, R <span class="funcparam">ranges</span>);
<br>TScanR!(fun,ElementType!(Knit!(R)),R) 
<span class="currsymbol">tscanR</span>
<script>explorer.outline.addDecl('tscanR');</script>

(alias fun, R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>
The right-fold cousin of tscan.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Concat!(Map!(unaryFun!(fun),R)) 
<span class="currsymbol">flatMap</span>
<script>explorer.outline.addDecl('flatMap');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>
<span class="currsymbol">flatMap</span>
<script>explorer.outline.addDecl('flatMap');</script>

 is the concatenation of the results of a map on a range.
If the mapped function produces another range, 
<span class="currsymbol">flatMap</span>
<script>explorer.outline.addDecl('flatMap');</script>

 concatenates all these ranges
into a unique range. If the function returns only a value, 
<span class="currsymbol">flatMap</span>
<script>explorer.outline.addDecl('flatMap');</script>

 is not different from map.
<br><br>
<b>Example:</b><br>
<pre class="d_code">string text = <font color=red>"this is just a test.\nI mean, I have no idea\nif this will work."</font>;
<font color=blue>auto</font> lines = splitlines(text);
<font color=blue>assert</font>(equal(lines, [<font color=red>"this is just a test."</font>, <font color=red>"I mean, I have no idea"</font>, <font color=red>"if this will work."</font>][]));
<font color=blue>auto</font> words = map!split(lines); <font color=green>// With map: you obtain a range of ranges
</font><font color=blue>assert</font>(equal(words, [[<font color=red>"this"</font>, <font color=red>"is"</font>, <font color=red>"just"</font>, <font color=red>"a"</font>, <font color=red>"test."</font>],
                     [<font color=red>"I"</font>, <font color=red>"mean,"</font>, <font color=red>"I"</font>, <font color=red>"have"</font>, <font color=red>"no"</font>, <font color=red>"idea"</font>],
                     [<font color=red>"if"</font>, <font color=red>"this"</font>, <font color=red>"will"</font>, <font color=red>"work."</font>]][]));
<font color=blue>auto</font> words2 = <u>flatMap</u>!split(lines); <font color=green>// With flatMap, it gives a range
</font><font color=blue>assert</font>(equal(words2, [<font color=red>"this"</font>, <font color=red>"is"</font>, <font color=red>"just"</font>, <font color=red>"a"</font>, <font color=red>"test."</font>,
                      <font color=red>"I"</font>, <font color=red>"mean,"</font>, <font color=red>"I"</font>, <font color=red>"have"</font>, <font color=red>"no"</font>, <font color=red>"idea"</font>,
                      <font color=red>"if"</font>, <font color=red>"this"</font>, <font color=red>"will"</font>, <font color=red>"work."</font>][]));

<font color=blue>auto</font> r1 = [1,2,3,4];
<font color=blue>auto</font> f = <u>flatMap</u>!<font color=red>"replicate(a,a)"</font>(r1); <font color=green>// stretching a range
</font><font color=blue>assert</font>(equal(f, [1,2,2,3,3,3,4,4,4,4][]));

<font color=blue>auto</font> f2 = <u>flatMap</u>!(<font color=red>"take(a, iota(0,int.max))"</font>)(r1); <font color=green>// growing ramps of numbers
</font><font color=blue>assert</font>(equal(f2, [0,0,1,0,1,2,0,1,2,3][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Unfold</span>
<script>explorer.outline.addDecl('Unfold');</script>

(alias fun,T...);
<br>Unfold!(fun,T) 
<span class="currsymbol">unfold</span>
<script>explorer.outline.addDecl('unfold');</script>

(alias fun, T...)(T <span class="funcparam">initialParameters</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Equivalent to the unfold of functional programming, the 'inverse' (dual?) of reduce. Given a seed and a generative
function, it creates an entire range. The function must have a special signature: it takes T... for arguments
and returns a Tuple!(Result, T...). The first part is the value for the range, the second part is used
as argument for the next step.
<br><br>
Compared to reduce which takes two arguments and returns one value, unfold uses a function
that takes n arguments and returns n+1 values. Thus, the expansion and the generation of a range.
Compare also to iterate, for which the value produced and the current state (next args) are the same.
<br><br>

Note that this version of unfold produces an infinite range.

<br><br>
<b>Example:</b><br>
<pre class="d_code">Tuple!(R,R,R) fibonacci(R)(R a, R b) { <font color=blue>return</font> tuple(a, b, a+b);} <font color=green>// value produced: a. Next state: (b,a+b)
</font><font color=blue>auto</font> fibs = unfold!fibonacci!<font color=blue>int</font>(0,1);
<font color=blue>assert</font>(equal(take(10, fibs), [0,1,1,2,3,5,8,13,21,34][])); <font color=green>// lazily computes the Fibonacci numbers.
</font><font color=blue>assert</font>(isInfinite!(<font color=blue>typeof</font>(fibs))); <font color=green>// It's an infinite range.
</font>
<font color=green>// And now with BigInts!
</font><font color=blue>auto</font> fibs2 = unfold!(fibonacci!BigInt)(BigInt(0),BigInt(1));
<font color=blue>assert</font>(drop(fibs2,100).front == <font color=red>"573147844013817084101"</font>); <font color=green>// Yeah, rapid growth
</font></pre>
You can use 'string' functions, as in many places in this module. In this case, the fibonacci sequence is
defined simply as:
<pre class="d_code"><font color=blue>auto</font> fibs3 = unfold!<font color=red>"tuple(a,b,a+b)"</font>(0,1); <font color=green>// value produced: a. Next state: (b,a+b)
</font><font color=green>// "tuple(a,b,a+b)" is templated, so this would work directly with BigInts too.
</font></pre>
But calculating Fibonacci numbers could easily be done easily with std.range.recurrence,
because the state has a constant size (int, int).
Calculating prime numbers on the other hand, necessitates a growing state (the list of primes already calculated).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Given a list of primes, finds the next prime number
</font>Tuple!(<font color=blue>ulong</font>, <font color=blue>ulong</font>[]) nextPrime(<font color=blue>ulong</font>[] primeList) {
    <font color=blue>ulong</font> value = primeList.back + 2; <font color=green>// This could be done better with a wheel
</font>    <font color=blue>bool</font> isPrime = <font color=blue>false</font>;
    <font color=blue>while</font>(!isPrime) {
        <font color=blue>foreach</font>(prime; primeList) {
            <font color=blue>if</font> (prime * prime &gt; value) {
                isPrime = <font color=blue>true</font>;
                primeList ~= value;
                <font color=blue>break</font>; <font color=green>// reached sqrt(value), it's a prime, no need to go further
</font>            }
            <font color=blue>else</font> {
                <font color=blue>if</font> (value % prime == 0) { <font color=green>// not a prime, test next one
</font>                    isPrime = <font color=blue>false</font>;
                    value += 2;
                    <font color=blue>break</font>;
                }
            }
        }
    }
    <font color=blue>return</font> tuple(value, primeList);
}

<font color=blue>ulong</font>[] seed = [2UL,3][];
<font color=blue>auto</font> primesAfter3 = unfold!nextPrime(seed);

<font color=blue>assert</font>(equal(take(10, primesAfter3), [5,7,11,13,17,19,23,29,31,37][]));
</pre>

Another example, to be compared to reduceR example: calculating the
<a href = "http://en.wikipedia.org/wiki/Continued_fraction">continued fraction</a> development
of a real.

<br><br>
<b>Example:</b><br>
<pre class="d_code">Tuple!(<font color=blue>int</font>, <font color=blue>real</font>) toCF(<font color=blue>real</font> d) { <font color=blue>return</font> tuple(to!<font color=blue>int</font>(d), 1.0 / (d - trunc(d)));}

<font color=blue>auto</font> piCF = unfold!toCF(PI); <font color=green>// Continued fraction dvt for pi 3.1415926...
</font><font color=green>// taken from http://mathworld.wolfram.com/PiContinuedFraction.html
</font><font color=blue>assert</font>(equal(take(12, piCF), [3,7,15,1,292,1,1,1,2,1,3,1][]));

<font color=blue>auto</font> eCF = unfold!toCF(E);   <font color=green>// For e 2.7818281828...
</font>                             <font color=green>// It can be proven to be 2,1, 2,1,1, 4,1,1, 6,1,1, 8,1,1, ... 2n,1,1 , ...
</font><font color=blue>assert</font>(equal(take(17, eCF), [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1][]));

<font color=blue>double</font> GoldenRatio = 0.5 * (1 + sqrt(5.0)); <font color=green>// Phi, the golden mean/ratio, about 1.618033988...
</font><font color=blue>auto</font> GRCF = unfold!toCF(GoldenRatio); <font color=green>// Known to be 1,1,1,1,1,1,1,1,1,1, ... ad infinitum
</font><font color=blue>assert</font>(equal(take(30, GRCF), replicate(30,1))); <font color=green>// Check
</font></pre>
This example has a problem: it doesn't stop. But a number can have a finite continued development. A trivial example is
1.25 = 1 + 1/4. There is no way with unfold to stop the process, see unfold2 to do that.

<br><br>
<b>See Also:</b><br>
unfold2, reduce, reduceR, iterate, scan, scanR, recurrence, sequence<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Unfold2</span>
<script>explorer.outline.addDecl('Unfold2');</script>

(alias fun,alias pred,T...);
<br>Unfold2!(fun,pred,T) 
<span class="currsymbol">unfold2</span>
<script>explorer.outline.addDecl('unfold2');</script>

(alias fun, alias pred, T...)(T <span class="funcparam">initialParameters</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalization of unfold with a second function: a predicate telling it when to stop (it stops when pred(elem,state) is <b>false</b>).
The former unfold produces a infinite range, this version can stop when you decide it to.
It's also sometimes called an anamorphism (see Wikipedia). It's not an infinite range (in the 'enum bool empty == <b>false</b>' sense).
<br><br>
<b>Note:</b><br>
the wikipedia example stops if pred(elem) is <b>true</b> and acts only on the generated value, not the global state.
As such it's equivalent to takeWhile!(not!pred)(unfold!fun) and so I decided here to use a more general predicate.

<br><br>
<b>Example:</b><br>
<pre class="d_code">Tuple!(<font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>int</font>) fibonacci(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> tuple(b, b, a+b);}
<font color=blue>auto</font> fibs = unfold2!(fibonacci, <font color=red>"a &gt; 100"</font>)(0,1); <font color=green>// stops when you reach 100
</font><font color=blue>assert</font>(equal(fibs, [1,1,2,3,5,8,13,21,34,55,89][])); <font color=green>// Generates 89. Next value would be 55+89 &gt; 100 -&gt; stops.
</font>
<font color=green>// see unfold for the definition of nextPrime.
</font><font color=green>// stops when the internal array storing the primes is 10 elements long
</font><font color=blue>auto</font> primesAfter3 = unfold2!(nextPrime, <font color=red>"b.length == 10"</font>)(seed);
<font color=blue>assert</font>(equal(primesAfter3, [5,7,11,13,17,19,23][])); <font color=green>// Internally stores seed also, so the state is [2,3,5,7,11,13,17,19,23,29].
</font>                                                      <font color=green>// 29 is the 10th element in the array, which stops the unfolding.
</font><font color=green>// Continued fraction
</font>Tuple!(<font color=blue>real</font>, <font color=blue>real</font>) toCF(<font color=blue>real</font> d) { <font color=blue>return</font> tuple(floor(d), 1.0 / (d - floor(d)));}
<font color=blue>auto</font> cf = unfold2!(toCF, <font color=red>"isnan(a) || a &gt; 1E+6"</font>)(3.245); <font color=green>// Continued fraction dvt for 3.245
</font><font color=green>// can be calculated to be 3 + 1/(4 + 1/(12 + 1/4))
</font><font color=blue>assert</font>(equal(cf, [3,4,12,3,1][])); <font color=green>// ends with 3,1 =&gt; 3+1/1 (ie. 4)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">CompType!(gen,pred,R) 
<span class="currsymbol">comp</span>
<script>explorer.outline.addDecl('comp');</script>

(alias gen, alias pred, R...)(R <span class="funcparam">inputs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A list comprehension for D. List comprehensions (also called for-comprehension
in some languages) are a powerful way to create sequences from input ranges, filters and a generative function.
<br><br>
Here, the syntax is:
<pre class="d_code"><u>comp</u>!(generator, predicate)(inputs...);
</pre>
It will then lazily generate the combination of all inputs, filter them through the predicate
and apply the generator to produce the values.
<br><br>

The generator and predicate can be written in a string form, as the functions in std.algorithm.map or .filter,
only generalized to 'a'-'z'. 'a' refers to elements from the first input, 'b' from the second and so on...
You can use other function like sin, cos, abs (or even tuple!) to generate values.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// find the pythagorean triplets for numbers between 1 and 10
</font><font color=green>// In set notation it's {(a,b,c) | a*a+b*b==c*c, a in [1,10], b in [1,10], c in [1,10]}
</font>input = numbers(1, 11);
<font color=blue>auto</font> lc = <u>comp</u>!(<font color=red>"tuple(a,b,c)"</font>, <font color=red>"a*a+b*b == c*c &amp;&amp; a&lt;b"</font>)(input, input, input);
<font color=green>// it finds the two triplets : Tuple!(int, int,int)(3,4,5) and (6,8,10)
</font><font color=blue>assert</font>(equal(lc, [tuple(3,4,5), tuple(6,8,10)][]));
</pre>

<br><br>
<b>Limitations:</b><br>
It cannot directly do bindings (having one of the input ranges based on another one, like input2 = take(5, (range1.front))
successively for each range1.front).
In this case, you must fall back on a combination of map, filter and flatMap. Though it should be possible
to code this.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">IntersectionType!(R) 
<span class="currsymbol">intersection</span>
<script>explorer.outline.addDecl('intersection');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A small application of range comprehension ('comp'): outputs the '
<span class="currsymbol">intersection</span>
<script>explorer.outline.addDecl('intersection');</script>

' of n ranges. That's the
elements present in all ranges. I say '
<span class="currsymbol">intersection</span>
<script>explorer.outline.addDecl('intersection');</script>

' (with quotes) because if some ranges are not sets
there will be duplicates.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,2,3];
<font color=blue>auto</font> r2 = [2.0,4,5,3,7,1,0];
<font color=blue>short</font>[] r3 = [-2,-3,1,0];
<font color=blue>auto</font> i = <u>intersection</u>(r1,r2,r3); <font color=green>// i.front is a double
</font><font color=blue>assert</font>(equal(i, [0,1][]));

<font color=blue>auto</font> i2 = <u>intersection</u>(r1,r2);
<font color=blue>assert</font>(equal(i2, [0,1,2,3,2,3][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Without!(Chain!(R),IntersectionType!(R)) 
<span class="currsymbol">symmetricDifference</span>
<script>explorer.outline.addDecl('symmetricDifference');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>As intersection, a small one-liner to produce the symmetric difference between n ranges (ie the
elements in the ranges that are not in their intersection).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,7];
<font color=blue>auto</font> r2 = [1,2,5,6,0];
<font color=blue>auto</font> s = <u>symmetricDifference</u>(r1, r2);
<font color=blue>assert</font>(equal(s, [3,5,7,6][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">PCompType!(gen,pred,R) 
<span class="currsymbol">pComp</span>
<script>explorer.outline.addDecl('pComp');</script>

(alias gen, alias pred, R...)(R <span class="funcparam">inputs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another kind of list comprehension, based on a Haskell proposal for parallel list comprehension. The n ranges are iterated
in parallel (in lockstep) instead of generating all combinations. They are filtered with pred and the values
are generated by applying gen to the resulting tuples.
<br><br>
As for comprehension and setComprehension, you can use standard functions or 'string' functions, with
letters 'a'-'z' representing the current value for the first, second, etc. ranges.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = numbers(1,100);
string sentence = <font color=red>"The quick brown fox jumped over the lazy dog."</font>;
<font color=blue>auto</font> words = split(sentence);
<font color=green>// get the words that are longer than a growing value and capitalize them
</font><font color=blue>auto</font> plc = <u>pComp</u>!(<font color=red>"capitalize(b)"</font>, <font color=red>"b.length &gt; a"</font>)(r1, words);
<font color=blue>assert</font>(equal(plc, [<font color=red>"The"</font>, <font color=red>"Quick"</font>, <font color=red>"Brown"</font>, <font color=red>"Jumped"</font>]));
</pre>

One interesting use case is on indexed ranges. You can use pcomp to filter on the element's indices
and expose elements (and obtaining stride-like or drop-like behavior, see below), or filter on elements
and return indices (like do 'positions' and 'indices' in this module).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r2 = [0,1,2,3,4,5,6,7];
<font color=blue>auto</font> myDrop(size_t n, R)(R range) {
    <font color=blue>return</font> <u>pComp</u>!(<font color=red>"b"</font>, <font color=red>"a&gt;="</font>~to!string(n))(indexed(range));
}
<font color=blue>assert</font>(equal(myDrop!3(r2), [3,4,5,6,7][]));

<font color=blue>auto</font> myStride(size_t n, R)(R range) {
    <font color=blue>return</font> <u>pComp</u>!(<font color=red>"b"</font>, <font color=red>"a%"</font>~to!string(n)~<font color=red>" == 0"</font>)(indexed(range));
}
<font color=blue>assert</font>(equal(myStride!3(r2), [0,3,6][]));

<font color=blue>auto</font> dropEvery(size_t n, R)(R range) {
    <font color=blue>return</font> <u>pComp</u>!(<font color=red>"b"</font>, <font color=red>"a%"</font>~to!string(n)~<font color=red>"!="</font>~to!string(n)~<font color=red>"-1"</font>)(indexed(range));
}
<font color=blue>assert</font>(equal(dropEvery!3(r2), [0,1, 3,4, 6,7][]));
</pre>

<br><br>
<b>See Also:</b><br>
tfilter, tmap, comp, setComprehension, select, subranges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">AsSet!(CompType!(gen,pred,R)) 
<span class="currsymbol">setComp</span>
<script>explorer.outline.addDecl('setComp');</script>

(alias gen, alias pred, R...)(R <span class="funcparam">inputs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A set comprehension for D, using asSet on comp.
<pre class="d_code"><font color=blue>auto</font> input = numbers(1,5);
<font color=blue>auto</font> sc = <u>setComp</u>!(<font color=red>"a+b+c"</font>, <font color=red>"a + b &gt; c"</font>)(input, input, input);
<font color=blue>assert</font>(equal(sc, [3,4,5,6,7,8,9,10,11,12][])); <font color=green>// The equivalent comprehension is three times as long.
</font></pre>
<br><br>
<b>See Also:</b><br>
comprehension, asSet.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Merge</span>
<script>explorer.outline.addDecl('Merge');</script>

(alias pred,R...) if (allSatisfy!(isForwardRange,R) &amp;&amp; CompatibleRanges!(R));
<br>Merge!(pred,R) 
<span class="currsymbol">merge</span>
<script>explorer.outline.addDecl('merge');</script>

(alias pred = "a&lt;b", R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a variadic list of ranges and a predicate (default: "a&lt;b"), merge will 'merge' the ranges
according to the following algorithm: it compare all fronts, finds the front
which verifies the predicate with all other fronts (the 'smallest') and outputs
it, advancing its range.
If all ranges are sorted with the predicate, it's equivalent to the call:
<pre class="d_code">sortAsArray!pred(chain(ranges)); <font color=green>// Which may be exactly what you want instead of 'merge'
</font></pre>
But if the ranges are not sorted, the results are different:
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,2,3];
<font color=blue>auto</font> r2 = [1,4,5];
<font color=blue>auto</font> r3 = [1,6,7,0];
<font color=blue>int</font>[] e;
<font color=blue>auto</font> m = merge(r,e,r2,r3);
<font color=blue>assert</font>(equal(m, [0,1,1,2,3,4,5,6,7,0][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">CommonElementType!(R1,R2)[] 
<span class="currsymbol">merge2</span>
<script>explorer.outline.addDecl('merge2');</script>

(R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another version, for two ranges and with the predicate being automatically "a&lt;b".
It's faster than the generic merge, and get rid of duplicates.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Calculating Hamming numbers, numbers of the form 2^i * 3^j * 5^k
</font><font color=green>// see http://en.wikipedia.org/wiki/Regular_number
</font><font color=green>// Dijkstra's algorithm heavily uses merge.
</font>T[] hamming(T)(T[] r)
{
    <font color=blue>return</font> 1 ~ <u>merge2</u>(map!<font color=red>"2*a"</font>(r),<u>merge2</u>(map!<font color=red>"3*a"</font>(r),map!<font color=red>"5*a"</font>(r)));
}

<font color=blue>auto</font> hammingNumbers()
{
    <font color=blue>return</font> iterate!hamming([1UL][]); <font color=green>// develop the Hamming sequence at each iteration.
</font>}
<font color=green>// 1,2,3,4,5,6,8,9,10,12,...
</font><font color=green>// For the i-th iteration, the sequence is complete only up to 2^i,
</font><font color=green>// but has much more numbers already calculated.
</font><font color=green>// The algorithm finds all Hamming numbers less than 1000_000_000_000 (1E+12) in 250 ms on my computer.
</font><font color=green>// There are 3428 of them and it takes 39 iterations to find them all. At this step the generated
</font><font color=green>// Hamming sequence has more than one million numbers already calculated.
</font><font color=green>// (most may be false due to reaching ulong.max).
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool[] 
<span class="currsymbol">nextBoolean</span>
<script>explorer.outline.addDecl('nextBoolean');</script>

(bool[] <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Internal helper function. Takes a number coded as
a dynamic array of bits (boolean), returns the next number.
The low-order bits are the first elements. That is, 8 is 0b1000 -&gt; [<b>false</b>, <b>false</b>, <b>false</b>, <b>true</b>].
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>bool</font>[] num; <font color=green>// equivalent to [false];
</font><font color=blue>foreach</font>(i; 0..4) { <font color=green>// 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4
</font>    num = <u>nextBoolean</u>(num);
}
<font color=blue>assert</font>(num == [<font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>true</font>][]); <font color=green>// 4 is 0b100, here encoded as [false, false, true]
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">PCompType!("b","a",bool[],R) 
<span class="currsymbol">select</span>
<script>explorer.outline.addDecl('select');</script>

(R)(bool[] <span class="funcparam">flags</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a dynamic array of flags (boolean), extracts the corresponding elements
and returns the corresponding subrange as a comprehension (another lazy range).
If stops at whichever is shortest between flags and range.
It works for infinite ranges, too.
<br><br>
<b>See Also:</b><br>
fromIndex.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3];
<font color=blue>auto</font> s01 = <u>select</u>([<font color=blue>false</font>, <font color=blue>true</font>][], r);
<font color=blue>assert</font>(equal(s01, [1][]));
<font color=blue>auto</font> s13 = <u>select</u>([<font color=blue>false</font>, <font color=blue>true</font>,<font color=blue>false</font>,<font color=blue>true</font>][], r);
<font color=blue>assert</font>(equal(s13, [1,3][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">SubRanges!(R) 
<span class="currsymbol">subranges</span>
<script>explorer.outline.addDecl('subranges');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Lazily returns all 
<span class="currsymbol">subranges</span>
<script>explorer.outline.addDecl('subranges');</script>

 of a range: the ranges created
by taking only some elements of the range in the same order.
<br><br>
For this implementation, it begins with the empty range.
For a range of length n, 
<span class="currsymbol">subranges</span>
<script>explorer.outline.addDecl('subranges');</script>

 has 2^^n elements.

<br><br>
<b>Note:</b><br>
It works for infinite ranges.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2];
<font color=blue>auto</font> sr = <u>subranges</u>(r);
<font color=blue>int</font>[][] witness = [[],
                   [0],
                   [1],
                   [0,1],
                   [2],
                   [0,2], [1,2],
                   [0,1,2]];

<font color=blue>foreach</font>(elem; sr) {
    <font color=blue>assert</font>(equal(elem, witness.front));
    witness.popFront;
}
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(R)[] 
<span class="currsymbol">sortAsArray</span>
<script>explorer.outline.addDecl('sortAsArray');</script>

(alias pred = "a &lt; b", R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>std.algorithm.sort does an efficient in-place sort, but it requires the
input range to returns its elements by reference. As it's not the case for
most of the ranges here (mainly because they simply cannot), 
<span class="currsymbol">sortAsArray</span>
<script>explorer.outline.addDecl('sortAsArray');</script>


is provided here if you need to sort a range with an ordering function.
It just calls array() on range, sorts it and return the sorted array.
<br><br>
<b>See Also:</b><br>
indexSorted
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [5,1,2,3,4];
<font color=blue>auto</font> r2 = [4.0,3.0,2.0,1.0,0.0];
<font color=blue>auto</font> r3 = [<font color=red>"abc"</font>,<font color=red>"def"</font>,<font color=red>"ghi"</font>];
<font color=blue>auto</font> s = knit(r1,r2,r3); <font color=green>// sort(s) won't work
</font><font color=green>// sort with no ordering function defined, defaults to "a &lt; b" (it's defined on tuples)
</font><font color=blue>assert</font>(equal(<u>sortAsArray</u>(s), [tuple(1,3.0,<font color=red>"def"</font>),tuple(2,2.0,<font color=red>"ghi"</font>),tuple(5,4.0,<font color=red>"abc"</font>)][]));
<font color=green>// specifying an ordering function: sorting according to the second field
</font><font color=blue>assert</font>(equal(<u>sortAsArray</u>!<font color=red>"a.field[1] &lt; b.field[1]"</font>(s), [tuple(2,2.0,<font color=red>"ghi"</font>),tuple(1,3.0,<font color=red>"def"</font>),tuple(5,4.0,<font color=red>"abc"</font>)][]));

<font color=green>// Another kind of range, with front&amp;back not by ref
</font><font color=blue>auto</font> st = stutter(3, r2); <font color=green>// st is equivalent to [5,5,5,1,1,1,2,2,2,3,3,3,4,4,4][] but cannot be sorted by sort
</font><font color=blue>assert</font>(equal(<u>sortAsArray</u>(st), stutter(3, <u>sortAsArray</u>(r2))));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Group</span>
<script>explorer.outline.addDecl('Group');</script>

(R) if (isForwardRange!(R));
<br>Group!(R) 
<span class="currsymbol">group</span>
<script>explorer.outline.addDecl('group');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Groups a range by values and returns the grouped values as an array. It's a bidirectional range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> test = [0,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6];
<font color=blue>assert</font>(equal(group(test), [[0], [1,1], [2,2,2], [3,3,3,3], [4,4,4], [5,5], [6]][]));
<font color=blue>assert</font>(equal(group(<font color=red>"Mississippi"</font>), [<font color=red>"M"</font>, <font color=red>"i"</font>, <font color=red>"ss"</font>, <font color=red>"i"</font>, <font color=red>"ss"</font>, <font color=red>"i"</font>, <font color=red>"pp"</font>, <font color=red>"i"</font>][]));
</pre>
<br><br>
<b>Update:</b><br>
A function with the same name already exists in std.algorithm, with a predicate, even.
No need to work further on this.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Map!(valueLength,Group!(R)) 
<span class="currsymbol">runLengthEncode</span>
<script>explorer.outline.addDecl('runLengthEncode');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a range r, will return the run-length encoding of r, as a range of tuples(element, length).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> test = [0,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6][];
<font color=blue>auto</font> rle = <u>runLengthEncode</u>(test);
wr(rle); <font color=green>// will print Tuple!(int, size_t): (0,1) (1,2) (2,3) (3,4) (4,3) (5,2) (6,1)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">contains</span>
<script>explorer.outline.addDecl('contains');</script>

(R1, R2)(R1 <span class="funcparam">range1</span>, R2 <span class="funcparam">range2</span>);
<br>bool 
<span class="currsymbol">contains</span>
<script>explorer.outline.addDecl('contains');</script>

(R1, E)(R1 <span class="funcparam">range1</span>, E <span class="funcparam">element</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns <b>true</b> iff range1 
<span class="currsymbol">contains</span>
<script>explorer.outline.addDecl('contains');</script>

 range2 (as one block, not separated elements). Do not presumes the ranges
are sorted (so, does a linear scan).
Range2 can also be just one element.
<br><br>
<b>Note:</b><br>
Another version could be possible, with one of the ranges as a template arg: 
<span class="currsymbol">contains</span>
<script>explorer.outline.addDecl('contains');</script>

!"bar"(r).
That way, it could be used a predicate by filtering function like dropWhile, takeWhile and filter.
<br><br>
<b>TODO:</b><br>
maybe a predicate.d, containing predicates and predicate-constructing functions?
<br><br>
<b>TODO:</b><br>
it can be more efficient for slice-able ranges.
<br><br>
<b>TODO:</b><br>
maybe just use std.algo.find?

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=red>"foobarbaz"</font>.<u>contains</u>(<font color=red>"bar"</font>)); <font color=green>// true
</font><font color=blue>assert</font>(<font color=red>"foobarbaz"</font>.<u>contains</u>(<font color=red>"b"</font>));   <font color=green>// true
</font><font color=blue>assert</font>(<font color=red>"foobarbaz"</font>.<u>contains</u>('b'));   <font color=green>// true
</font><font color=green>//
</font><font color=blue>assert</font>(!(<font color=red>"foobarbaz"</font>.<u>contains</u>(<font color=red>"c"</font>)));<font color=green>// doesn't contain "c"
</font><font color=blue>assert</font>(<font color=red>"foobarbaz"</font>.<u>contains</u>(<font color=red>""</font>));    <font color=green>// "" (an empty range) is in any range
</font><font color=blue>assert</font>(!(<font color=red>""</font>.<u>contains</u>(<font color=red>"abc"</font>)));       <font color=green>// an empty range contains nothing
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Rotate!(R) 
<span class="currsymbol">rotate</span>
<script>explorer.outline.addDecl('rotate');</script>

(R)(R <span class="funcparam">range</span>, int <span class="funcparam">n</span> = 1);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>
rotates a range to the left by n positions (ie: take the first n elements and put them at the end).
R must be a forward range and have a length. If R is infinite, it just drops the first n terms.
<br><br>

If n is negative, it rotates it to the right.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Chain!(R,TakeWhile!(pred,R)) 
<span class="currsymbol">rotateWhile</span>
<script>explorer.outline.addDecl('rotateWhile');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Rotates a range while the predicate holds. It works for infinite ranges also.
<br><br>
If the predicate is <b>true</b> for all elements, it will not cycle forever, but deliver a range equal
to the orginal range.
<br><br>

Note that the predicate can be unary, but also binary or whatever. 
<span class="currsymbol">rotateWhile</span>
<script>explorer.outline.addDecl('rotateWhile');</script>

!"a&lt;b"(r) is possible.
See takeWhile.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> arr = [0,1,2,3,4,3,2,1,0];
wr(<u>rotateWhile</u>!<font color=red>"true"</font>(arr));    <font color=green>// 0,1,2,3,4,3,2,1,0
</font>wr(<u>rotateWhile</u>!<font color=red>"a&lt;2"</font>(arr));     <font color=green>// 2,3,4,3,2,1,0,0,1
</font>wr(<u>rotateWhile</u>!<font color=red>"a&lt;b"</font>(arr));     <font color=green>// 4,3,2,1,0,0,1,2,3
</font>wr(<u>rotateWhile</u>!<font color=red>"a+b+c&lt;10"</font>(arr));<font color=green>// 3,4,3,2,1,0,0,1,2
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!(rotate!(R),Repeat!(R),Numbers) 
<span class="currsymbol">rotations</span>
<script>explorer.outline.addDecl('rotations');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Infinite range producing the successive 
<span class="currsymbol">rotations</span>
<script>explorer.outline.addDecl('rotations');</script>

 of the input range.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!(replacer!(ElementType!(R)),R,Repeat!(V[K])) 
<span class="currsymbol">replace</span>
<script>explorer.outline.addDecl('replace');</script>

(R, V, K)(R <span class="funcparam">range</span>, V[K] <span class="funcparam">mapping</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>
Replaces the elementes of range present in the AA mapping by the values in mapping.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = <u>replace</u>([0,1,2,3,4], [1:100, 2:200]);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">IndicesType!(value,R) 
<span class="currsymbol">indices</span>
<script>explorer.outline.addDecl('indices');</script>

(alias value, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a value as template parameter and a range as argument, returns a (lazy) range
containing the 
<span class="currsymbol">indices</span>
<script>explorer.outline.addDecl('indices');</script>

 of 'value' in the range.
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,2,2];
<font color=blue>auto</font> i1 = <u>indices</u>!2(r1); <font color=green>// 2,5,6. finding an int in a int[]
</font><font color=blue>assert</font>(equal(indicesOf!'a'(<font color=red>"banana"</font>), [1,3,5][])); <font color=green>// finding a char in a string
</font>string sentence = <font color=red>"the quick brown fox jumped over the lazy dog."</font>;
<font color=blue>auto</font> i2 = <u>indices</u>!' '(sentence); <font color=green>// finding spaces in the string
</font><font color=blue>assert</font>(equal(i2, [3, 9, 15, 19, 26, 31, 35, 40][]));
<font color=blue>auto</font> words = split(sentence);
<font color=blue>auto</font> i3 = <u>indices</u>!<font color=red>"the"</font>(words); <font color=green>// finding a string in a string[]
</font><font color=blue>assert</font>(equal(i3, [0,6][]));
<font color=blue>auto</font> r2 = map!<font color=red>"a*a"</font>(cycle([1,2,3]));
<font color=blue>auto</font> i4 = <u>indices</u>!4(take(10, r2)); <font color=green>// inside another kind of range
</font><font color=blue>assert</font>(equal(i4, [1,4,7][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">PCompType!("a","b",Numbers,Map!(unaryFun!(pred),R)) 
<span class="currsymbol">positions</span>
<script>explorer.outline.addDecl('positions');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a predicate as template parameter and a range as argument, returns a (lazy) range
containing the indices of the values verifying pred.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5,6,1];
<font color=blue>auto</font> p1 = <u>positions</u>!<font color=red>"a%2==0"</font>(r1);
<font color=blue>assert</font>(equal(p1, [0,2,4,6][]));
<font color=blue>auto</font> p2 = <u>positions</u>!<font color=red>"a&lt;4"</font>(r1);
<font color=blue>assert</font>(equal(p2, [0,1,2,3,7][]));
<font color=blue>auto</font> p3 = <u>positions</u>!<font color=red>"a&gt;10"</font>(r1); <font color=green>// predicate never verified -&gt; empty
</font><font color=blue>assert</font>(p3.empty);

<font color=blue>auto</font> s = <font color=red>"banana"</font>;
<font color=blue>auto</font> p4 = <u>positions</u>!(isOneOf!<font color=red>"bn"</font>)(s);
<font color=blue>assert</font>(equal(p4, [0,2,4][]));

<font color=blue>int</font>[] e;
<font color=blue>assert</font>(<u>positions</u>!<font color=red>"a==0"</font>(e).empty); <font color=green>// on an empty range -&gt; empty
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!(atIndex!(R,ElementType!(I)),Combinations!(Once!(R),I)) 
<span class="currsymbol">fromIndex</span>
<script>explorer.outline.addDecl('fromIndex');</script>

(I, R)(I <span class="funcparam">indices</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a (possibly infinite) range of indices and a random-access range, it will lazily produce
the corresponding elements.
<br><br>
<b>Example:</b><br>
<pre class="d_code">string s = <font color=red>"abcdefg"</font>;

<font color=blue>auto</font> i1 = map!<font color=red>"a%4"</font>(numbers(10)); <font color=green>// 0,1,2,3,0,1,2,3,0,1
</font><font color=blue>auto</font> fi1 = <u>fromIndex</u>(i1, s);
<font color=blue>assert</font>(equal(fi1, <font color=red>"abcdabcdab"</font>)); <font color=green>// equivalent to take(10, cycle(take(4, s)))
</font>
<font color=blue>auto</font> i2 = map!<font color=red>"a/4"</font>(numbers(10)); <font color=green>// 0,0,0,0,1,1,1,1,2,2
</font><font color=blue>auto</font> fi2 = <u>fromIndex</u>(i2, s);
<font color=blue>assert</font>(equal(fi2, <font color=red>"aaaabbbbcc"</font>)); <font color=green>// equivalent to take(10, stutter(4, s))
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ToIndex</span>
<script>explorer.outline.addDecl('ToIndex');</script>

(R) if (isForwardRange!(R));
<br>ToIndex!(R) 
<span class="currsymbol">toIndex</span>
<script>explorer.outline.addDecl('toIndex');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a range, it will lazily produce the element's indices. If an element has the same value
than a previous element, this previous element's index will be given.
<br><br>
<b>Examples:</b><br>
<pre class="d_code">string s = <font color=red>"abcdefabcdefghab"</font>;
<font color=blue>auto</font> ti = toIndex(s);
<font color=blue>assert</font>(equal(ti, [0,1,2,3,4,5,0,1,2,3,4,5,12,13,0,1][]));
<font color=blue>assert</font>(equal(fromIndex(ti, s), s)); <font color=green>// toIndex is (sort of) the opposite of fromIndex
</font>
<font color=blue>auto</font> r = replicate(5,5); <font color=green>// 5,5,5,5,5
</font><font color=blue>assert</font>(equal(toIndex(r), [0,0,0,0,0][])); <font color=green>// Always the first element's index (0)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(Filter!(unaryFun!(pred),R),Filter!(Not!(unaryFun!(pred)),R)) 
<span class="currsymbol">separate</span>
<script>explorer.outline.addDecl('separate');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Separate a range in (in tuple of) two ranges according to predicate pred. The first field
will contain the values verifying pred, the second those that do not verify it. There
is an equivalent Haskell function.
<br><br>
<b>See Also:</b><br>
span.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3,4,5];
<font color=blue>auto</font> s = <u>separate</u>!<font color=red>"a&lt;1 || a&gt;3"</font>(r);
<font color=blue>assert</font>(equal(first(s), [0,4,5][]));
<font color=blue>assert</font>(equal(second(s), [1,2,3][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(TakeWhile!(pred,R),R) 
<span class="currsymbol">span</span>
<script>explorer.outline.addDecl('span');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Equivalent to Haskell's 
<span class="currsymbol">span</span>
<script>explorer.outline.addDecl('span');</script>

: returns the tuple(takeWhile!pred(range), dropWhile!pred(range)).
<br><br>
<b>See Also:</b><br>
separate.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = map!<font color=red>"a*a"</font>([0,1,2,3,4,5,4,3,2][]);
<font color=blue>auto</font> s = <u>span</u>!<font color=red>"a&lt;10"</font>(m);
<font color=blue>assert</font>(equal(first(s), [0,1,4,9][]));
<font color=blue>assert</font>(equal(second(s), [16,25,16,9,4][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(R)[] 
<span class="currsymbol">squeeze</span>
<script>explorer.outline.addDecl('squeeze');</script>

(E, R)(E <span class="funcparam">element</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Eliminates all duplicated occurences of 'element' from 'range'. Taken from Ruby by way of Clojure.
Useful to get rid of surnumerary spaces in strings.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,2,3,4,5,2,2,2,3,5,6,8,3,2];
string r2 = <font color=red>"abcd  ef g h    "</font>;
<font color=blue>assert</font>(equal(<u>squeeze</u>(2, r1), [0,1,2,3,4,5,2,3,5,6,8,3,2][]));
<font color=blue>assert</font>(equal(<u>squeeze</u>(' ', r2), <font color=red>"abcd ef g h "</font>));
</pre>
Note that it returns an array of ElementType!R, not a R.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Combinations</span>
<script>explorer.outline.addDecl('Combinations');</script>

(R...) if (allSatisfy!(isForwardRange,R));
<br>Combinations!(R) 
<span class="currsymbol">combinations</span>
<script>explorer.outline.addDecl('combinations');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the cartesian product of a variadic number of ranges: the sequence of all tuples
created by taking one element in each range.
The order of the input ranges is important: the rightmost one
will be incremented faster than the one before it and so on:

<span class="currsymbol">Combinations</span>
<script>explorer.outline.addDecl('Combinations');</script>

([0,1][], [2,3][], [4,5][]) will produce
Tuple!(int, int, int) (0,2,4), (0,2,5), (0,3,4), (0,3,5), (1,2,4), ...
<br><br>
If all the ranges have a length, 
<span class="currsymbol">Combinations</span>
<script>explorer.outline.addDecl('Combinations');</script>

 also has a 'length' member
whose value is the product of all these lengths.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2];
string r2 = <font color=red>"abcd"</font>;
<font color=blue>auto</font> r3 = map!<font color=red>"a + 3.0"</font>(r1);
<font color=blue>auto</font> cb = combinations(r1,r2,r3);
<font color=blue>assert</font>(!<font color=blue>is</font>(cb.length)); <font color=green>// r3 has no length, so cb neither.
</font><font color=blue>assert</font>(equal(take(7, cb),
            [tuple(0, 'a', 3.0), tuple(0, 'a', 4.0), tuple(0, 'a', 5.0),
             tuple(0, 'b', 3.0), tuple(0, 'b', 4.0), tuple(0, 'b', 5.0), tuple(0, 'c', 3.0)][]
            ));
<font color=blue>auto</font> cb2 = combinations(r1,r2);
<font color=blue>assert</font>(cb2.length == r1.length * r2.length); <font color=green>// 12
</font>cb2.popFront;
<font color=blue>assert</font>(cb2.length == r1.length * r2.length - 1); <font color=green>// 11
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Permutations</span>
<script>explorer.outline.addDecl('Permutations');</script>

(R);
<br>Permutations!(R) 
<span class="currsymbol">permutations</span>
<script>explorer.outline.addDecl('permutations');</script>

(R)(R <span class="funcparam">r</span>);
<br>Permutations!(R) 
<span class="currsymbol">permutations</span>
<script>explorer.outline.addDecl('permutations');</script>

(R)(R <span class="funcparam">r</span>, size_t <span class="funcparam">n</span>);
<br>Permutations!(ElementType!(R)[]) 
<span class="currsymbol">permutations</span>
<script>explorer.outline.addDecl('permutations');</script>

(R)(R <span class="funcparam">r</span>);
<br>Permutations!(ElementType!(R)[]) 
<span class="currsymbol">permutations</span>
<script>explorer.outline.addDecl('permutations');</script>

(R)(R <span class="funcparam">r</span>, size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Lazily generates the permutations of the first n elements in a range. By default
n is equal to the range's length, so it permutes the entire range.
It's completely based on algorithm C from Knuth's "the Art of Computer Programming", vol. IV
(found on the web <a href = "http://www-cs-faculty.stanford.edu/~knuth/fasc2b.ps.gz">here</a>),
fascicule 2b, section 7.2.1.2 "Generating all 
<span class="currsymbol">Permutations</span>
<script>explorer.outline.addDecl('Permutations');</script>

".
Internally it does not use any factorial, so it's quite safe to use it on long ranges.
Its length will be n!. So permutations(r,1) returns only array(r).
On the empty range, it returns an empty range and then stops.
<br><br>
<b>BUG:</b><br>
Do not work on infinite ranges. Not a bug, more a limitation of the algorithm as currently coded.
<br><br>
<b>Note:</b><br>
The front type is an array of ElementType!R, not an R, because most ranges
do not support the slicing operations needed there. Also, it's an array
and not a tuple as most ranges'd return here, because I gather the classical
use is indeed to treat each element (a permutation) as a range latter on. Tuples
wouldn't do it.
<br><br>
<b>Note:</b><br>
Another possibility would be to return a lazy extract, as do subranges and variations.
<br><br>
<b>Note:</b><br>
A possible update would be to get rid of internal arrays and to make it usable on infinite ranges.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2]; <font color=green>// array
</font><font color=blue>auto</font> m = map!<font color=red>"a*a"</font>(r); <font color=green>// not an array...
</font>
<font color=blue>auto</font> p1 = permutations(r); <font color=green>// on an array
</font><font color=blue>assert</font>(equal(p1, [[0,1,2], [1,2,0], [2,0,1], [1,0,2], [0,2,1], [2,1,0] ][]));

<font color=blue>auto</font> p2 = permutations(m); <font color=green>// on a forward range
</font><font color=blue>assert</font>(equal(p2, [[0,1,4], [1,4,0], [4,0,1], [1,0,4], [0,4,1], [4,1,0] ][]));

<font color=blue>auto</font> r2 = numbers(100); <font color=green>// 0..100
</font><font color=blue>auto</font> p3 = permutations(r2); <font color=green>// quite safe, but you'll probably never exhaust it...
</font>p3.popFront;
<font color=blue>assert</font>(p3.front == array(numbers(1,100)) ~ [0]);
p3.popFront;
<font color=blue>assert</font>(p3.front == array(numbers(2,100)) ~ [0,1]); <font color=green>// begins by rotating the range
</font>
<font color=blue>auto</font> p4 = permutations(r2, 3); <font color=green>// permutes only the first 3 elements.
</font>p4.popFront;
<font color=blue>assert</font>(p4.front == [1,2,0] ~ array(numbers(3,100)));
p4.popFront;
<font color=blue>assert</font>(p4.front == [2,0,1] ~ array(numbers(3,100)));
p4.popFront;
p4.popFront;
p4.popFront;
<font color=blue>assert</font>(p4.empty); <font color=green>// only 6 elements, as it acts only on the first 3 elements of r2.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ChooseType!(repetition,R) 
<span class="currsymbol">choose</span>
<script>explorer.outline.addDecl('choose');</script>

(uint repetition = withoutRepetition, R)(size_t <span class="funcparam">n</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Chooses n elements from a range. It lazily generates all combinations of n elements (as an array) taken from range.
There are two different behaviors determined by an anonymous enum : repetition {withRepetition, withoutRepetition}
<br><br>
Repetition tells the algorithm if you want to reuse the elements from the range or not.
Say you want to take 3 elements from [0,1,2,3]. You take '0'. If you selected withoutRepetition (the default state)
the second element will be taken from [1,2,3], and the third from [2,3] (for example). If you selected
withRepetition, all three elements will be taken from [0,1,2,3]. So repeated values like (2,3,3) are a possibility.
For a range of length l, choosing n elements among l will give C(n,l) = (
<span class="currsymbol">choose</span>
<script>explorer.outline.addDecl('choose');</script>

 n among l) = l!/(n! * (l-n)!) = l*(l-1)*(l-2)*...*(l-n+1) / n!
<br><br>

Without repetition, the generated arrays are always ordered as the range's elements: choosing 3 element among [0,1,2,3,4,5]
will generate [0,1,2], [0,1,3], ... but never [3,1,0]. If you want all the orderings, do flatMap!permutations on 
<span class="currsymbol">choose</span>
<script>explorer.outline.addDecl('choose');</script>

.
<br><br>

You can do the same with repetition, but in this case, you need to filter out the repeated patterns with asSet.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// A poker hand is five cards without repetition among 52 cards.
</font><font color=green>// That makes 2,598,960 possible hands.
</font><font color=blue>auto</font> ranks = <font color=red>"A23456789TJQK"</font>;
<font color=blue>auto</font> suits = [<font color=red>"Hearts"</font>, <font color=red>"Spades"</font>, <font color=red>"Diamonds"</font>, <font color=red>"Clubs"</font>];
<font color=blue>auto</font> cards = combinations(ranks, suits); <font color=green>// ('A', "Hearts"), ('A', "Spades"), ...
</font><font color=blue>assert</font>(walkLength(cards) == 52); <font color=green>// OK, 52 cards.
</font>
<font color=blue>auto</font> c = <u>choose</u>(5, cards); <font color=green>// default is withoutRepetition
</font><font color=blue>assert</font>(walkLength(c) == 52*51*50*49*48/(5*4*3*2)); <font color=green>// 2,598,960
</font>
<font color=green>// A DNA chain is made of one of four bases (here denoted as A, C, G or T)
</font><font color=green>// A codon is a 3-bases encoding for an amino-acid. How many codons are there?
</font><font color=blue>auto</font> DNA = <font color=red>"ACGT"</font>;
<font color=blue>auto</font> codons = <u>choose</u>!withRepetition(3, DNA);   <font color=green>// 4*4*4 == 64 elements
</font><font color=blue>assert</font>(walkLength(codons) == 64);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Consumer</span>
<script>explorer.outline.addDecl('Consumer');</script>

(alias nextElement,alias isSafe,alias renewState,alias buildState,alias flusher,R,St,Out);
<br>Consumer!(nextElement,isSafe,renewState,buildState,flusher,R,St,typeof(unaryFun!(nextElement)(St.init))) 
<span class="currsymbol">consumer</span>
<script>explorer.outline.addDecl('consumer');</script>

(alias nextElement, alias isSafe, alias renewState, alias buildState, alias flusher = id, R, St)(R <span class="funcparam">range</span>, St <span class="funcparam">initialState</span>);
<br>Consumer!(nextElement,isSafe,renewState,buildState,flusher,R,St,typeof(unaryFun!(nextElement)(St.init))) 
<span class="currsymbol">consumer</span>
<script>explorer.outline.addDecl('consumer');</script>

(alias nextElement, alias isSafe, alias renewState, alias buildState, alias flusher, R, St)(R <span class="funcparam">range</span>, St <span class="funcparam">initialState</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generic consumer of ranges. It will gobble as many elements as needed from the input range
to produce its next value, the number of input elements consumed can vary from
one call to popFront to the next. Taken from the Haskell code in
<a href = "http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/spigot.pdf">this article</a>.
<br><br>
It takes as input a (possibly infinite) range with element type In and an initial internal state (of type St).
Let's call Out the type consumer outputs. The idea is that you incrementaly build a valid internal state while consuming the range.
When the state is complete, nextElement can produce the output element and renewState 'discharges' the state,
making it OK for rebuilding by buildState.

<br><br>
<b>Params:</b><br>
<table border="1" cellpadding = "5" bgcolor = "Ivory"><tr>
<td nowrap valign="top" style="padding-right: 8px">nextElement</td>

               
<td>a callable taking a St (current state) and returning an Out. Produces the possible next element (of type Out).</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">isSafe</td>

               
<td>takes the current state and the element produced by nextElement. Tells wether or not it's OK to output the element.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">renewState</td>

               
<td>if isSafe is <b>true</b>, then renewState takes (state, element) and returns the state resotred to a 'pristine' state (ready to grow again).</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">buildState</td>

               
<td>if isSafe is <b>false</b>, buildState takes (state, range.front) and returns the new state. range.popFront is called.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">flush</td>

               
<td>is an optional callable that is used when the input range is exhausted (so, only for finite ranges). flush is called on the current state to produce the last few elements as an array of Out.</td></tr>
</table><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// to be documented.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(binaryFun!(plus)(binaryFun!(times)(ElementType!(R1).init,ElementType!(R2).init),binaryFun!(times)(ElementType!(R1).init,ElementType!(R1).init))) 
<span class="currsymbol">innerProduct</span>
<script>explorer.outline.addDecl('innerProduct');</script>

(alias plus = "a+b", alias times = "a*b", R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>generic inner product of a range.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Filter!(Not!(pred),R) 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(alias pred, R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>the dual of filter<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">reduceWhile</span>
<script>explorer.outline.addDecl('reduceWhile');</script>

(alias fun,alias pred)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>reduce a range while pred holds on the intermediary values.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">treduce0</span>
<script>explorer.outline.addDecl('treduce0');</script>

(alias fun)<br>template 
<span class="currsymbol">treduce</span>
<script>explorer.outline.addDecl('treduce');</script>

(alias fun)<br>template 
<span class="currsymbol">treduceR0</span>
<script>explorer.outline.addDecl('treduceR0');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>
Reducing n ranges in parallel (in the same vein than tmap, tfilter).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">treduceR</span>
<script>explorer.outline.addDecl('treduceR');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The right-fold pendant of treduce.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:56:11 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


