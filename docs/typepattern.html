
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.typepattern</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.typepattern");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.typepattern</h1><!-- Generated by Ddoc from dranges\typepattern.d -->
This module implements a basic pattern matching engine for type tuples. Think regexes, but for types:
"one or more int, followed by a string or a double, and then anything but a float".
<br><br>
Pattern expressions are built by aliasing the basic building blocks provided here and tested with the Match!(Pattern, Tuple...)
template. A match result is a struct exposing three fields:
<br><br>

<ul> <li>hasMatched: a boolean that tells us whether or not the typetuple matched the pattern</li>
  <li>Result: a typetuple holding the match result. If hasMatched is <b>false</b>, it will be empty.</li>
  <li>Post: the rest of the input typetuple, the part that was not consumed by the pattern.</li>
</ul>

<br><br>
<b>Usage:</b><br>
<pre class="d_code"><font color=green>// Let's define some basic patterns first:
</font><font color=blue>alias</font> OneOrMore!(<font color=blue>int</font>) Ints;
<font color=blue>alias</font> Either!(<font color=blue>int</font>, <font color=blue>double</font>) IOrD;
<font color=blue>alias</font> _ Any; <font color=green>// Predefined '_' pattern, matching any type.
</font><font color=blue>alias</font> And!(_,_) Two; <font color=green>// Matches any two types in succession. Will fail if passed 0 or 1 type.
</font>
<font color=green>// A more complicated example:
</font><font color=blue>alias</font> Successively!(
                    <font color=blue>int</font>,
                    None!(<font color=blue>int</font>,<font color=blue>double</font>,string),
                    _,
                    Repeat!(<font color=blue>int</font>, 2, 4),
                    Not!<font color=blue>int</font>,
                    End) Pattern;

<font color=green>// To match, use Match!(Pattern, TypeTuple):
</font><font color=blue>alias</font> Match!(Ints, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>)    Res1;
<font color=blue>alias</font> Match!(IOrD, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>) Res2;
<font color=blue>alias</font> Match!(Any,  <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>) Res3;
<font color=blue>alias</font> Match!(Two,  <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>) Res4;
<font color=blue>alias</font> Match!(Pattern, <font color=blue>int</font>, <font color=blue>float</font>, string, <font color=blue>int</font>,<font color=blue>int</font>,<font color=blue>int</font>, string) Res5;

<font color=green>// All is done at compile-time, of course.
</font><font color=blue>pragma</font>(msg, Res1.Result.stringof, <font color=red>" // "</font>, Res1.Post.stringof);
<font color=blue>pragma</font>(msg, Res2.Result.stringof, <font color=red>" // "</font>, Res2.Post.stringof);
<font color=blue>pragma</font>(msg, Res3.Result.stringof, <font color=red>" // "</font>, Res3.Post.stringof);
<font color=blue>pragma</font>(msg, Res4.Result.stringof, <font color=red>" // "</font>, Res4.Post.stringof);
<font color=blue>pragma</font>(msg, Res5.Result.stringof, <font color=red>" // "</font>, Res5.Post.stringof);
</pre>

<br><br>
<b>Features:</b><br>
<ul> <li>Any type is its own pattern. 'int' matches an int and so on.</li>
  <li>Patterns can be tested in succession (And) or in alternation (Or). Predefined compositions like Successively and Either are there to help you.</li>.
  <li>You can Repeat patterns min times, up to max times. There are predefined ZeroOrMore, OneOrMore, Option (aka ZeroOrOne) for your convenience.</li>
  <li>Patterns can (and will) backtrack to find a match.</li>
  <li>All patterns are tested only from the beginning of the tuple. In regex terms, it's as if they all begin with '^'. Use UnAnchored!Pattern to
    make a pattern consume input until it finds something.</li>
  <li>You can easily extend the module by defining your own patterns: just define a Match(T...) template inside a struct that alias itself to a correct
    match result.</li>
</ul>

<br><br>
<b>TODO:</b><br>
<ul> <li>Maybe extend that to all template parameters, and not only types.</li>
  <li>No capture is implemented yet. That would mean passing an entire state around, to remember previous captures to give them to
    a BackReference!(ref number) template. It's doable, but a bit to much for me right now.</li>
  <li>No named captures either...</li>
</ul><br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Match</span>
<script>explorer.outline.addDecl('Match');</script>

(Pattern,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The match engine, driving the entire pattern evaluation.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">AllMatches</span>
<script>explorer.outline.addDecl('AllMatches');</script>

(Pattern)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a tuple of all matches of a pattern in an input tuple. To distinguish them from one another, the matches are wrapped in Tuples.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>AllMatches</u>!(Pattern).In!(InputTuple) AM;
</pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// finds all couples where a type is followed by an int.
</font><font color=blue>alias</font> <u>AllMatches</u>!(And!(_,<font color=blue>int</font>)).In!( <font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>int</font>,string,<font color=blue>int</font>*,<font color=blue>int</font>,<font color=blue>int</font> ) Ints;
<font color=blue>assert</font>(<font color=blue>is</font>(AM == TypeTuple!(
                           Tuple!(<font color=blue>double</font>,<font color=blue>int</font>),
                           Tuple!(<font color=blue>int</font>*,<font color=blue>int</font>),
                           Tuple!(<font color=blue>int</font>,<font color=blue>int</font>)
                          )));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Replace</span>
<script>explorer.outline.addDecl('Replace');</script>

(Pattern,WithThis)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Replaces the first instance of <b><code>Pattern</code></b> with <b><code>WithThis</code></b> in an input typetuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Replace</u>!(And!(_,<font color=blue>int</font>), <font color=blue>float</font>).In!(<font color=blue>double</font>,<font color=blue>int</font>, string,string,<font color=blue>int</font>) Rep;
<font color=blue>assert</font>(<font color=blue>is</font>( Rep == TypeTuple!(<font color=blue>float</font>, string, string, <font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReplaceAll</span>
<script>explorer.outline.addDecl('ReplaceAll');</script>

(Pattern,WithThis)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Replaces every instance of <b><code>Pattern</code></b> with <b><code>WithThis</code></b> in an input typetuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>ReplaceAll</u>!(And!(_,<font color=blue>int</font>), <font color=blue>float</font>).In!(<font color=blue>double</font>,<font color=blue>int</font>, string,string,<font color=blue>int</font>) Rep;
<font color=blue>assert</font>(<font color=blue>is</font>( Rep == TypeTuple!(<font color=blue>float</font>, string, <font color=blue>float</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Transform</span>
<script>explorer.outline.addDecl('Transform');</script>

(Pattern,alias WithThis)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A cousin of <b><code>Replace</code></b>: finds the first match of <b><code>Pattern</code></b> in an input typetuple and replaces it with <b><code>WithThis!(Match)</code></b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// transforms the first integral type with its unsigned equivalent
</font><font color=blue>alias</font> <u>Transform</u>!(If!(isIntegral), Unsigned).In!( <font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>float</font>,<font color=blue>byte</font>,<font color=blue>ulong</font>,string ) T;
<font color=blue>assert</font>(<font color=blue>is</font>( T == TypeTuple!(<font color=blue>uint</font>,<font color=blue>double</font>,<font color=blue>float</font>,<font color=blue>byte</font>,<font color=blue>ulong</font>,string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransformAll</span>
<script>explorer.outline.addDecl('TransformAll');</script>

(Pattern,alias WithThis)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A cousin of <b><code>ReplaceAll</code></b>: finds all successive matches of <b><code>Pattern</code></b> in an input typetuple and replaces them with (M WithThis!(Match)).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// transforms all integral types with their unsigned equivalent
</font><font color=blue>alias</font> <u>TransformAll</u>!(If!(isIntegral), Unsigned).In!( <font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>float</font>,<font color=blue>byte</font>,<font color=blue>ulong</font>,string ) T;
<font color=blue>assert</font>(<font color=blue>is</font>( T == TypeTuple!(<font color=blue>uint</font>,<font color=blue>double</font>,<font color=blue>float</font>,<font color=blue>ubyte</font>,<font color=blue>ulong</font>,string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">match</span>
<script>explorer.outline.addDecl('match');</script>

(Pattern,alias action,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another take on pattern-matching. It takes couples of a pattern and a function (maybe a templated function)
as template parameters. When given a value as input, it will test the value type against all patterns
in succession. When a pattern matches, it will return the associated function's return.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>match</u>!(
             OneOrMore!<font color=blue>int</font>,     fun1,
             And!(<font color=blue>double</font>, <font color=blue>int</font>), fun2,
             _,                 fun3,
             ) matcher;
</pre>

<br><br>
<b>See Also:</b><br>
<b><code>dranges.patternmatch</code></b>, <b><code>dranges.functional.eitherFun</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">_</span>
<script>explorer.outline.addDecl('_');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches any type. Think '.' for regexes. Does not match the empty typetuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">End</span>
<script>explorer.outline.addDecl('End');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches the end of a tuple (aka, the empty typetuple). Think '$' for regexes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Or</span>
<script>explorer.outline.addDecl('Or');</script>

(Pattern1,Pattern2);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>It matches if <b><code>Pattern1</code></b> or <b><code>Pattern2</code></b> matches. More precisely, it tests <b><code>Pattern1</code></b>.
If it matches, <b><code>
<span class="currsymbol">Or</span>
<script>explorer.outline.addDecl('Or');</script>

</code></b> returns the match result.
If it fails, <b><code>
<span class="currsymbol">Or</span>
<script>explorer.outline.addDecl('Or');</script>

</code></b> will try the second pattern and return its match result (which may be a failure).
If it tested only the first pattern, it can backtrack when asked to, by testing the second pattern.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">And</span>
<script>explorer.outline.addDecl('And');</script>

(Pattern1,Pattern2);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Will match if and only if <b><code>Pattern1</code></b> matches and <b><code>Pattern2</code></b> matches after <b><code>Pattern1</code></b>.
It's the basic building block for all type patterns, since it threads them in succession.
When you need to test P1 and then P2 and then P3, it's <b><code>
<span class="currsymbol">And</span>
<script>explorer.outline.addDecl('And');</script>

</code></b> you need.
If the second pattern fails, it will ask the first pattern to backtrack (if possible) and test the second pattern again.
<br><br>
<b>See Also:</b><br>
<b><code>Successively</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Successively</span>
<script>explorer.outline.addDecl('Successively');</script>

(Patterns...) if (Patterns.length &gt; 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convenience template, equivalent to <b><code>And!(P1, And!(P2, And!(P3, ...)))</code></b>. It will try to match all the Pi:
if one fails, the entire template fails. It's composed of <b><code>And</code></b>s, so it will backtrack internally
as much as necessary to match all patterns.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Either</span>
<script>explorer.outline.addDecl('Either');</script>

(Patterns...) if (Patterns.length &gt; 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convenience template, equivalent to <b><code>Or!(P1, Or!(P2, Or!(...)))</code></b>. It will try <b><code>P1</code></b>, and stop there if it matches.
Else, it will test <b><code>P2</code></b> and so on. If forced to backtrack, it will continue with the yet untested patterns.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Repeat</span>
<script>explorer.outline.addDecl('Repeat');</script>

(Pattern,int min,int max) if (min &gt;= 0 &amp;&amp; max &gt;= 0 &amp;&amp; min &lt;= max)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Greedily matches <b><code>Pattern</code></b> at least <b><code>min</code></b> times up to (included) <b><code>max</code></b> times. If forced to backtrack, it will try one match less.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">LazyRepeat</span>
<script>explorer.outline.addDecl('LazyRepeat');</script>

(Pattern,int min,int max) if (min &lt;= max)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Repeat <b><code>Pattern min</code></b> times. If forced to backtrack, it will try one more match, up to <b><code>max</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ZeroOrMore</span>
<script>explorer.outline.addDecl('ZeroOrMore');</script>

(Pattern)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Tests for 0 or more <b><code>Pattern</code></b>. I stopped at 128 max due to template instantiation limits.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">OneOrMore</span>
<script>explorer.outline.addDecl('OneOrMore');</script>

(Pattern)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Tests for 1 or more <b><code>Pattern</code></b>. I stopped at 128 max due to template instantiation limits.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Option</span>
<script>explorer.outline.addDecl('Option');</script>

(Pattern)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>0 or 1 <b><code>Pattern</code></b><br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Not</span>
<script>explorer.outline.addDecl('Not');</script>

(Pattern);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Invert the pattern.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">None</span>
<script>explorer.outline.addDecl('None');</script>

(Patterns...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches only iff none of the <b><code>Patterns</code></b> match.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">isA</span>
<script>explorer.outline.addDecl('isA');</script>

(alias templ,Patterns...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b><code>
<span class="currsymbol">isA</span>
<script>explorer.outline.addDecl('isA');</script>

</code></b> is a very powerful pattern: it matches if the input type is an instance of <b><code>templ</code></b> (a templated type) with the inner types matching <b><code>Patterns</code></b>:
<pre class="d_code"><font color=blue>alias</font> <u>isA</u>!(Tuple, _, _) Tuple2; <font color=green>// matches any Tuple!(_,_): a Tuple with two types
</font><font color=blue>alias</font> <u>isA</u>!(Tuple, OneOrMore!_) Tuple1; <font color=green>// matches any Tuple with one or more type inside.
</font>                                       <font color=green>// So, it matchesTuple!(int, string, double) but not Tuple!()
</font><font color=blue>alias</font> <u>isA</u>!(Tuple, <font color=blue>int</font>, ZeroOrMore!_) Tuple3; <font color=green>// matches Tuple!(int, double) or Tuple!(int, double, string) or even Tuple!(int)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Inside</span>
<script>explorer.outline.addDecl('Inside');</script>

(alias templ,Patterns...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b><code>
<span class="currsymbol">Inside</span>
<script>explorer.outline.addDecl('Inside');</script>

</code></b> is like <b><code>isA</code></b>, but the match result is the inner types, *not* the global type:
<pre class="d_code"><font color=blue>alias</font> isA!(Tuple, _, _)    Tuple2;  <font color=green>// matches Tuple!(int, string), produces Tuple!(int, string)
</font><font color=blue>alias</font> <u>Inside</u>!(Tuple, _, _) Inside2; <font color=green>// matches Tuple!(int, string), but produces (int, string)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

(alias condition);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches if <b><code>T[0]</code></b> verifies the condition (ie if <b><code>condition!(T[0])</code></b> is statically <b>true</b>)
<pre class="d_code"><font color=blue>alias</font> <u>If</u>!(isIntegral) Integer; <font color=green>// will match int, byte, short, long, etc.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

(alias condition,Then,Else);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An extended version of the previous <b><code>
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

</code></b>. 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

 <b><code>T[0]</code></b> verifies the condition (ie if <b><code>condition!(T[0])</code></b> is statically <b>true</b>),
it'll use the <b><code>Then</code></b> pattern on <b><code>T</code></b>. Else, it'll use the <b><code>Else</code></b> pattern.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

(alias condition,alias Then,Else);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Variation on the same theme: <b><code>Then</code></b> is here a template that will be applied on the <b><code>
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

</code></b> match result.
That is, if <b><code>condition!(T[0])</code></b>, returns <b><code>Then!(T[0])</code></b>, else return <b><code>Else</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

(alias condition,Then,alias Else);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The same, with <b><code>Else</code></b> being an alias.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">If</span>
<script>explorer.outline.addDecl('If');</script>

(alias condition,alias Then,alias Else);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The same, with <b><code>Then</code></b> and <b><code>Else</code></b> being aliases.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ReleaseMatch</span>
<script>explorer.outline.addDecl('ReleaseMatch');</script>

(Pattern);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a pattern such that, if it matches, it puts back its match in the input tuple, for the next pattern
to consume.
<br><br>
<b>See Also:</b><br>
<b><code>LookAhead</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">DiscardMatch</span>
<script>explorer.outline.addDecl('DiscardMatch');</script>

(Pattern);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a pattern such that, if it matches, it discards its match: the match result is the empty typetuple.
<br><br>
<b>See Also:</b><br>
<b><code>Left</code></b>, <b><code>Right</code></b>, <b><code>LeftMost</code></b>, <b><code>RightMost</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Left</span>
<script>explorer.outline.addDecl('Left');</script>

(Pattern1,Pattern2)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches iff <b><code>Pattern1</code></b> and then <b><code>Pattern2</code></b> match, but returns only <b><code>Pattern1</code></b>'s match result.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Right</span>
<script>explorer.outline.addDecl('Right');</script>

(Pattern1,Pattern2)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches iff <b><code>Pattern1</code></b> and then <b><code>Pattern2</code></b> match, but returns only <b><code>Pattern2</code></b>'s match result.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">LeftMost</span>
<script>explorer.outline.addDecl('LeftMost');</script>

(Patterns...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches iff all <b><code>Patterns</code></b> match, but returns only the first (leftmost) pattern match result.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">RightMost</span>
<script>explorer.outline.addDecl('RightMost');</script>

(Patterns...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches iff all <b><code>Patterns</code></b> match, but returns only the last (rightmost) pattern match result.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">LookAhead</span>
<script>explorer.outline.addDecl('LookAhead');</script>

(Patterns...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Matches iff all <b><code>Patterns</code></b> match, returns the leftmost pattern match result, without consuming the rest.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Simultaneously</span>
<script>explorer.outline.addDecl('Simultaneously');</script>

(Patterns...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Tests the first pattern. If it matches, it releases its match and then tests the second pattern in the same manner. All
patterns will be tested in this way, getting them to match on the same input (more or less). Only if all of them match
simultaneously will <b><code>
<span class="currsymbol">Simultaneously</span>
<script>explorer.outline.addDecl('Simultaneously');</script>

</code></b> returns a match: the last pattern's match. Not to be confused with <b><code>And</code></b> or <b><code>Successively</code></b>
that test for matches while consuming the first patterns matches.
<pre class="d_code"><font color=green>// S matches if there are two types in a row and the first one is an int. Returns 'int'.
</font><font color=blue>alias</font> <u>Simultaneously</u>!(And!(_,_), <font color=blue>int</font>) S;
</pre>
<br><br>
<b>Note:</b><br>
I'm not sure this is interesting, as there is frequently a way to express the same pattern in another way.
I'm just playing along with <b><code>ReleaseMatch</code></b>, really.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">UnAnchored</span>
<script>explorer.outline.addDecl('UnAnchored');</script>

(Pattern);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a pattern so that it'll consume input until it finds a match.
Only if it reaches the end of the typetuple without matching does it return <b><code>NoMatch</code></b>.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:56:13 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


