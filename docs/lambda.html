
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.lambda</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.lambda");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.lambda</h1><!-- Generated by Ddoc from dranges\lambda.d -->
This module is a small expression template library to create anonymous functions (aka, lambdas)
in a syntax reminiscent of std.* 'string' functions or what is used in other programming
languages (like Scala, for example).
<br><br>
Future arguments are represented as <b><code>_0</code></b>, <b><code>_1</code></b>, <b><code>_2</code></b>, or simply <b><code>_</code></b>.
Anonymous functions are automatically constructed by putting them in arithmetic expressions.
Here are a few examples:
<pre class="d_code"><font color=blue>auto</font> l1 = _ + 1;
<font color=blue>auto</font> l2 = _0 + _1;
<font color=blue>auto</font> l3 = _2[_0.length-1.._1.length+1];
<font color=blue>auto</font> l4 = _2 ~ _3;

<font color=blue>auto</font> head = _[0]; <font color=green>// Or _.front
</font><font color=blue>auto</font> tail = _[1.._.length];
</pre>
Their main point is to be used in map/reduce/filter calls in lieu of 'string' functions:
<pre class="d_code"><font color=blue>auto</font> arr = [0,1,2,3,4];
<font color=blue>auto</font> plusOne = map!(_ + 1)(arr);
<font color=blue>auto</font> sum = reduce!(_0 + _1)(arr); <font color=green>// instead of reduce!("a + b")(arr);
</font></pre>

<b><code>_0 + _1</code></b> is a completly templated function that waits for two arguments and return their sum. Lambdas
are always generic in all their arguments and are automatically curried. <b><code>_0 + _1</code></b> can be called
with two arguments, but also with one. In that case <b><code>(_0 + _1)(1)</code></b> puts the 1 in place of all <b><code>_0</code></b>s in
the expression and returns the resulting lambda: <b><code>1 + _0</code></b>. This new lambda can itself be called
with another argument to give the sum.
This allows for some nifty tricks like:
<pre class="d_code"><font color=green>// create a range of functions: [ _+0, _+1, _+2, ...]
</font><font color=blue>auto</font> funRange = map!(_0 + _1)(arr);
<font color=blue>foreach</font>(fun; funRange) writeln(fun(10)); <font color=green>// writes 10,11,12,13,14.
</font></pre>

Features and authorized expressions:
<ul>   <li>Any basic binary and unary expression should work.</li>
    <li>== is OK. != is not, though (see below).</li>
    <li>opIndex is there, and slices too.</li>
    <li>opDispatch is used to allow expressions like : <b><code>.length</code></b>.</li>
    <li>Compared to 'string' functions, they can be passed around, are real callable objects
      and so should be compatible with all your usual idioms concerning functions.</li>
    <li>compared to template anonymous function, like <b><code>(i) { return i+1;}</code></b> they can be
      passed around, returned as results from other functions, etc. In D, closures can be returned
      but not templated closures. Here you can, at least for the expressions described above.</li>
    <li>They are composable. If you have two lambdas, you can sum them, call one with another, etc. You cannot
      do that with 'string' functions.</li>
    <li>They are not limited to two arguments. In fact, the real syntax for <b><code>_0</code></b> &co is <b><code>Arg!0</code></b>, <b><code>Arg!1</code></b>, etc.
      The <b><code>_x</code></b> shown here are just alias for your convenience.
      There is no limit to the number of arguments. And remember: the resulting expression will be fully generic
      and curried.</li>
</ul>
<br><br>

It's just an afternoon work really, so be prepared for bugs and such. As of this writing, the main limitations are:
<ul> <li>No <b><code>opCmp</code></b> (<b><code>&lt;</code></b>, <b><code>&lt;=</code></b>, <b><code>&gt;</code></b>, <b><code>&gt;=</code></b>). I couldn't find a way to do them that doesn't produce infinite template
    expansion, due to the way DMD rewrites <b><code>a &lt; b</code></b> as <b><code>a.opCmp(b) &lt; 0</code></b>: the <b><code>&lt; 0</code></b> part triggers another expansion,etc.
    This *really* annoys me, as it severely limits the interest of the library: you cannot do <b><code>filter!(_ &lt; 1)(range)</code></b>,
    which was one of the main motivations for writing this module. Any help would be appreciated.</li>
  <li>No <b><code>opCall</code></b>. That is, you cannot do <b><code>_0(_1)</code></b>. This is by design, because all the lambdas are callable structs: <b><code>0(1)</code></b> gets <b><code>0</code></b>
    called with <b><code>_1</code></b>, it does not construct another lamda. I could easily introduce a CallExpr constructor, but that'd mean calling lambdas
    with another syntax that the call operator <b><code>()</code></b>, which rather defeats the goal of this module.
    Maybe I could test for the arguments being expressions or not...</li>
  <li>No <b><code>!=</code></b>, because <b><code>a!=b</code></b> is rewritten as <b><code>!(a.opEquals(b))</code></b>. But <b><code>a.opEquals(b)</code></b> is a lambda, not a boolean. That
    makes the compiler chokes because it cannot implicitly convert the lambda to a boolean. As there is no <b><code>opImplicitCast</code></b> in D, I'm stuck.</li>
  <li>No <b><code>opCast(type)</code></b>. It seems that in <b><code>cast(type)lambda</code></b>, the compiler does not construct the CastExpr I want it too, but try to directly
    cast lambda into a type...</li>
  <li>No expression with standard functions. That is, no lambda like: <b><code>sin()+cos()</code></b>. That's because <b><code>sin</code></b> and <b><code>cos</code></b> want a <b><code>real</code></b>,
    not a lambda. A nasty workaround would be to use the method call syntax: <b><code>.sin + .cos</code></b> and play with <b><code>opDispatch</code></b>. But I find the resulting
    syntax quite ugly.</li>
</ul><br><br>

</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:50:58 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


