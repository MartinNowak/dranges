
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.phobos_extension</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.phobos_extension");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.phobos_extension</h1><!-- Generated by Ddoc from dranges\phobos_extension.d -->
This module provides modified versions of std.algorithm and std.range functions.
If you're interested, they should be put in your local copy of std.
<br><br>
The most simple/solid ones are map and filter. Chain and take are much more 'fragile'.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">hasLength</span>
<script>explorer.outline.addDecl('hasLength');</script>

(R)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alternate template to std.range.
<span class="currsymbol">hasLength</span>
<script>explorer.outline.addDecl('hasLength');</script>

, as 
<span class="currsymbol">hasLength</span>
<script>explorer.outline.addDecl('hasLength');</script>

 doesn't work
if R has its length method defined inside a static if.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Map</span>
<script>explorer.outline.addDecl('Map');</script>

(alias fun,Range) if (isInputRange!(Range));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An extended version of std.algorithm.
<span class="currsymbol">Map</span>
<script>explorer.outline.addDecl('Map');</script>

, that makes it propagate the
input range properties (bidirectional, etc.)
<ul><li>it defines back/popBack if the input range is bidirectional.</li>
<li>it defines opIndex if the range offers random-access.</li>
<li>it has a length if the input range has one.</li>
<li>it's infinite if the input range is infinite.</li>
<li>it can be sliced if the input range can also.</li>
</ul>
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3,4]; <font color=green>// random-access range with a length and slicing.
</font><font color=blue>auto</font> m = map!<font color=red>"a*a"</font>(r);

<font color=blue>assert</font>(equal(retro(m), [16,9,4,1,0][])); <font color=green>// bidirectional range
</font><font color=blue>assert</font>(m[3] == 9); <font color=green>// random-access range
</font><font color=blue>assert</font>(m.length == 5); <font color=green>// length
</font><font color=blue>assert</font>(equal(m[1..3], [1,4][])); <font color=green>// slicing
</font>
<font color=blue>auto</font> m2 = map!<font color=red>"a*a"</font>(cycle(r)); <font color=green>// cycle(r) is infinite
</font><font color=blue>assert</font>(isInfinite(<font color=blue>typeof</font>(m2))); <font color=green>// m2 is infinite also.
</font><font color=blue>assert</font>(!<font color=blue>is</font>(m2.length)); <font color=green>// cycle(r) doesn't have a length, so neither has m2.
</font></pre>
<br><br>
<b>Note:</b><br>
map caches its front and back. So be prudent if you use callable classes/structs
with an internal state (and why would you use a class as a callable if not to manage
state?).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Filter</span>
<script>explorer.outline.addDecl('Filter');</script>

(alias pred,Range) if (isInputRange!(Range));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An extended version of std.algorithm.
<span class="currsymbol">Filter</span>
<script>explorer.outline.addDecl('Filter');</script>

 that defines
back/popBack if the input range is bidirectional.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3,4];
<font color=blue>auto</font> f = filter!<font color=red>"a%2==0"</font>(r);
<font color=blue>assert</font>(equal(retro(f), [4,2,0])); <font color=green>// f is a bidirectional range
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Repeat</span>
<script>explorer.outline.addDecl('Repeat');</script>

(T);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>std.range.
<span class="currsymbol">Repeat</span>
<script>explorer.outline.addDecl('Repeat');</script>

 should have popBack defined.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Stride</span>
<script>explorer.outline.addDecl('Stride');</script>

(R) if (isInputRange!(R));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>std.range.
<span class="currsymbol">Stride</span>
<script>explorer.outline.addDecl('Stride');</script>

 assumes a bidirectional range. This slight modification
just add the necessary 'isBidirectionalRange!R' throughout the code.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Take</span>
<script>explorer.outline.addDecl('Take');</script>

(R) if (isInputRange!(R));
<br>Take!(R) 
<span class="currsymbol">take</span>
<script>explorer.outline.addDecl('take');</script>

(R)(size_t <span class="funcparam">n</span>, R <span class="funcparam">input</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A corrected version of std.range.take.
<br><br>
/+It uses slicing when possible, to get (hopefully) a better performance.+/
<br><br>

The std version has problems with its back/popBack methods, they simply do not work.
It seems these do work (to be thoroughly tested, though), but they depend on rather
strict conditions on the input range: back/popBack needs a random-access range
with a length.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ChainImpl</span>
<script>explorer.outline.addDecl('ChainImpl');</script>

(R...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An extended version of std.range.
<span class="currsymbol">ChainImpl</span>
<script>explorer.outline.addDecl('ChainImpl');</script>

.
<br><br>
In DMD 2.037, chain has some problems:
<br><br>

<ul><li>opIndex doesn't deal correctly with infinite ranges</li>
<li>the same for opIndexAssign</li></ul>
<br><br>

<pre class="d_code"><font color=blue>auto</font> c = chain([0,1,2][], cycle([4,5,6][]), [7,8,9][]); <font color=green>// infinite range inside.
</font><font color=blue>auto</font> c7 = c[7]; <font color=green>// doesn't work with std.range.chain.
</font></pre>

This version also provides some concatenation capabilities on the right
with another chain (with flattening), with another range and with an element.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Jun  3 00:11:59 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm2");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional2");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range2");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits2");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple2");

    explorer.packageExplorer.addModule("dranges.typetuple2");

    explorer.packageExplorer.addModule("dranges.variadic");

</script>
</body></html>


