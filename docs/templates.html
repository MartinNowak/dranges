
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.templates</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.templates");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.templates</h1><!-- Generated by Ddoc from dranges\templates.d -->
To Be Documented.
<br><br>
This module defines some useful 
<span class="currsymbol">templates</span>
<script>explorer.outline.addDecl('templates');</script>

 for the other modules and some 'meta-
<span class="currsymbol">templates</span>
<script>explorer.outline.addDecl('templates');</script>

'. Templates
transforming other 
<span class="currsymbol">templates</span>
<script>explorer.outline.addDecl('templates');</script>

, currying them, flipping their arguments, etc.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">UnWrap</span>
<script>explorer.outline.addDecl('UnWrap');</script>

(string Wrapper,T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a complex type (ie:Cycle!R, Retro!R) and get rid of the external type indicated
as a string. That is 
<span class="currsymbol">UnWrap</span>
<script>explorer.outline.addDecl('UnWrap');</script>

!("Cycle", Cycle!U) aliases itself to U. It's useful
to get some return types, when you extract internal values in a range and need to get their types.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> c = cycle([1,2,3][]);
<font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(c) == Cycle!(<font color=blue>int</font>[]))); <font color=green>// A cycle around an array of int
</font><font color=blue>alias</font> <u>UnWrap</u>!(<font color=red>"Cycle"</font>, <font color=blue>typeof</font>(c)) InternalType;
<font color=blue>assert</font>(<font color=blue>is</font>(InternalType == <font color=blue>int</font>[]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Wrap</span>
<script>explorer.outline.addDecl('Wrap');</script>

(string Wrapper,T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The converse of UnWrap.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FlipTemplate</span>
<script>explorer.outline.addDecl('FlipTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a template and flips its arguments.
So, given:
<pre class="d_code"><font color=blue>template</font> Foo(A,B) {}
</pre>
Then 
<span class="currsymbol">FlipTemplate</span>
<script>explorer.outline.addDecl('FlipTemplate');</script>

!Foo is equivalent to:
<pre class="d_code"><font color=blue>template</font> FlippedFoo(B,A) { <font color=blue>alias</font> Foo!(A,B) FlippedFoo;}
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransformTemplate</span>
<script>explorer.outline.addDecl('TransformTemplate');</script>

(alias templ,alias transformTypes)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalized version of FlipTemplate: takes a target template and
a transformation on types (another template). It will then apply
the transformation on the parameters before passing the result to the input
template.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Foo(A) {}; <font color=green>// Foo takes one type as param.
</font><font color=blue>alias</font> <u>TransformTemplate</u>!(Foo, First) TFoo; <font color=green>// TFoo is a variadic template. Any T... passed to it is transformed
</font>                                           <font color=green>// by First!T into T[0], before serving as parameter for Foo.
</font>                                           <font color=green>// So, TFoo is now a variadic version of Foo.
</font><font color=blue>assert</font>(<font color=blue>is</font>(TFoo!(<font color=blue>int</font>, <font color=blue>double</font>, string) == Foo!(<font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">T1</span>
<script>explorer.outline.addDecl('T1');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The template equivalent of unaryFun: takes a string as template argument and creates a simple template aliasing
the string. As for unaryFun, the resulting template argument is 'a'.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>T1</u>!<font color=red>"Tuple!(ReturnType!a, ParameterTypeTuple!a)"</font> FunTypes;

<font color=blue>assert</font>(<font color=blue>is</font>(FunTypes!(<font color=blue>int</font> <font color=blue>delegate</font>(<font color=blue>double</font>, string)) == Tuple!(<font color=blue>int</font>, <font color=blue>double</font>, string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">T2</span>
<script>explorer.outline.addDecl('T2');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The binaryFun equivalent for templates: given a string with 'a' and 'b', generates a template from it.
It's useful to quickly make a template, for example for a StaticMap of template composition.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>T2</u>!<font color=red>"a delegate(b)"</font> MkDelegate; <font color=green>// MkDelegate is a template taking two types a and b and becoming
</font>                                     <font color=green>// the type of delegates from b to a.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TN</span>
<script>explorer.outline.addDecl('TN');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The n-types generalization of T1 and T2: given a string in 'a', 'b', ... (up to 'z'), creates
a template from it.
<br><br>
<b>Example:</b><br>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">BindT</span>
<script>explorer.outline.addDecl('BindT');</script>

(alias Template,alias Param0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">BindF</span>
<script>explorer.outline.addDecl('BindF');</script>

(alias FunctionTemplate,alias Param0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CurryTemplate</span>
<script>explorer.outline.addDecl('CurryTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a n-args template and transform it into n 1-arg templates inside each other.
Very useful for many arguments templates, when you only have one arg right now, or want
to bind this arg. 
<span class="currsymbol">CurryTemplate</span>
<script>explorer.outline.addDecl('CurryTemplate');</script>

 also works with template alias parameters.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>CurryTemplate</u>!(StaticMap) CStaticMap; <font color=green>// StaticMap takes a template and then a T... (typetuple)
</font><font color=blue>alias</font> CStaticMap!Unqual SMU; <font color=green>// SMU is now a template taking a T... and mapping Unqual on it.
</font>
<font color=blue>assert</font>(<font color=blue>is</font>(SMU!(<font color=blue>int</font>, <font color=blue>const</font> <font color=blue>int</font>, <font color=blue>immutable</font> <font color=blue>double</font>, string) == TypeTuple!(<font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>, string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Max</span>
<script>explorer.outline.addDecl('Max');</script>

(alias a,alias b)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Aliases itself to the max of a and b.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Min</span>
<script>explorer.outline.addDecl('Min');</script>

(alias a,alias b)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Aliases itself to the min of a and b.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isTemplate</span>
<script>explorer.outline.addDecl('isTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to <b>true</b> iff templ is a template (standard, function, class or struct template).
Is that really kosher?<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateArity</span>
<script>explorer.outline.addDecl('TemplateArity');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateParametersTypeTuple</span>
<script>explorer.outline.addDecl('TemplateParametersTypeTuple');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a type instantiating a template (that is, T == A!(someTypes...) for some A)
and becomes the template's parameters typetuple; TypeTuple!(someTypes) in the previous example.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateFunctionPTT</span>
<script>explorer.outline.addDecl('TemplateFunctionPTT');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the parameters typetuple from a non-instantiated template function. It creates
a list of structs T0, T1, ..., Tn (n being TemplateArity!fun) and instantiates fun
to do that. So the resulting TypeTuple is defined for inexistant types!
<br><br>
<b>Limitation:</b><br>
Does not work if there are constraints.

<br><br>
<b>BUG:</b><br>
Not test for variadic templates.

<br><br>
<b>Example:</b><br>
<pre class="d_code">A foo(A,B)(A a, B b, Tuple!(B,A) c, B d) { <font color=blue>return</font> a;}
<font color=blue>alias</font> <u>TemplateFunctionPTT</u>!foo PTTfoo; <font color=green>// PTTfoo is TypeTuple!(T0, T1, Tuple!(T1,T0), T1)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">TemplateFunArity</span>
<script>explorer.outline.addDecl('TemplateFunArity');</script>

(alias templ)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the number of args of a non-instantiated template function
<br><br>
<b>Example:</b><br>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CompareTypes</span>
<script>explorer.outline.addDecl('CompareTypes');</script>

(T,U)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">string 
<span class="currsymbol">TemplateConstraints</span>
<script>explorer.outline.addDecl('TemplateConstraints');</script>

(alias templ)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the constraints of a template (the guard <b><font color=blue>if (...)</font></b> after the template name), if any. If there is
no constraint, returns the empty string.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Foo(<font color=blue>alias</font> A, B, C)
{
    <font color=blue>alias</font> A!(B,C) Foo;
}

<font color=blue>template</font> Bar(A,B,C) <font color=blue>if</font> (isIntegral!B &amp;&amp; <font color=blue>is</font>(C == CommonType!(A,B)))
{
    <font color=blue>alias</font> Tuple!(A,B,C) Bar;
}

<font color=blue>assert</font>(<u>TemplateConstraints</u>!Bar == <font color=red>"isIntegral!(B) &amp;&amp; is(C == CommonType!(A,B))"</font>);
<font color=blue>assert</font>(<u>TemplateConstraints</u>!Foo == <font color=red>""</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isAlias</span>
<script>explorer.outline.addDecl('isAlias');</script>

(alias a)<br>template 
<span class="currsymbol">isAlias</span>
<script>explorer.outline.addDecl('isAlias');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if a is an alias (a symbol bound by an alias template parameter). It's useful when you have
a variadic type (T...) and some of its components may be aliases instead of types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isType</span>
<script>explorer.outline.addDecl('isType');</script>

(T)<br>template 
<span class="currsymbol">isType</span>
<script>explorer.outline.addDecl('isType');</script>

(alias a)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if a is a type and not an alias. It's useful when you have
a variadic type (T...) and some of its components may be types or aliases..<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Constant</span>
<script>explorer.outline.addDecl('Constant');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The constant template.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Void</span>
<script>explorer.outline.addDecl('Void');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Null</span>
<script>explorer.outline.addDecl('Null');</script>

()</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Id</span>
<script>explorer.outline.addDecl('Id');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Compose</span>
<script>explorer.outline.addDecl('Compose');</script>

(Templates...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>
<span class="currsymbol">Compose</span>
<script>explorer.outline.addDecl('Compose');</script>

 n templates together.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Compose</u>!(Cycle, ArrayType) MkCycle; <font color=green>// Takes a T, makes a Cycle!(T[]).
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ArrayType</span>
<script>explorer.outline.addDecl('ArrayType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to T[]. Useful for template composition.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Apply</span>
<script>explorer.outline.addDecl('Apply');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Apply types T on successive templates (that is, instantiate them with T) and makes a TypeTuple from it.
It's the complement of StaticMap, which takes a template an applies it on successive types.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>Apply</u>!(SomeTypes).On!(Templates).
</pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Apply</u>!(<font color=blue>int</font>,<font color=blue>double</font>) Applier;
<font color=blue>alias</font> Applier.On!(MkDelegate, Tuple, Doubler, CommonType) Result;
<font color=blue>assert</font>(<font color=blue>is</font>(Result == TypeTuple!(<font color=blue>int</font> <font color=blue>delegate</font>(<font color=blue>double</font>), Tuple!(<font color=blue>int</font>,<font color=blue>double</font>), <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>double</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Instantiate</span>
<script>explorer.outline.addDecl('Instantiate');</script>

(alias templ1,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Like Apply.On, but reversed: first, the templates, then the type.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>Instantiate</u>!(SomeTemplates).With!(SomeTypes).
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">MkDelegate</span>
<script>explorer.outline.addDecl('MkDelegate');</script>

(ReturnType,ParameterTypes...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The type of a delegate with corresponding parameters.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransferParamsTo</span>
<script>explorer.outline.addDecl('TransferParamsTo');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Usage:</b><br>
<pre class="d_code"><u>TransferParamsTo</u>!(someTemplate).From!(someTemplatedType).
</pre>
It will extract the template parameters from <i><font color=blue>someTemplatedType</font></i> and instantiate <i><font color=blue>someTemplate</font></i> with them.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>TransferParamsTo</u>!Repeat MkRepeat;
<font color=blue>alias</font> MkRepeat.From!(Cycle!(<font color=blue>int</font>[])) R; <font color=green>// takes a Cycle!(Range), extracts Range, makes a Repeat from it.
</font><font color=blue>assert</font>(<font color=blue>is</font>(R == Repeat!(<font color=blue>int</font>[]))); <font color=green>// R is a Repeat!(int[])
</font></pre>

<br><br>
<b>Note:</b><br>
so, 
<span class="currsymbol">TransferParamsTo</span>
<script>explorer.outline.addDecl('TransferParamsTo');</script>

 can be seen as a function from a domain of types to another domain. It's a functor,
in a mathematical/Haskell sense (which has nothing to do with a C++ functor).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">Default</span>
<script>explorer.outline.addDecl('Default');</script>

;
<br>template 
<span class="currsymbol">SwitchOnType</span>
<script>explorer.outline.addDecl('SwitchOnType');</script>

(alias value,Type,alias Action,Rest...)<br>template 
<span class="currsymbol">SwitchOnType</span>
<script>explorer.outline.addDecl('SwitchOnType');</script>

(alias value,Type : Default,alias Action)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An small switch-like template to produce different code depending on the type of value. The 
<span class="currsymbol">Default</span>
<script>explorer.outline.addDecl('Default');</script>

 class
is used to indicate (wait for it) a default value.
<pre class="d_code"><font color=blue>int</font> i; <font color=blue>double</font> d; string s;
<font color=blue>alias</font> SwitchOnType!(i, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchi;
<font color=blue>alias</font> SwitchOnType!(d, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchd;
<font color=blue>alias</font> SwitchOnType!(s, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchs;
<font color=blue>assert</font>(switchi == <font color=red>"It's an int"</font>);
<font color=blue>assert</font>(switchd == <font color=red>"It's a double"</font>);
<font color=blue>assert</font>(switchs == <font color=red>"It's something else"</font>);
</pre>
<br><br>
<b>BUG:</b><br>
Well, not a bug really, but a severe limitation: the 'Action' alias are all evaluated at compile-time, there are not lazy.
I found out it drastically limits the interest of this template: it cannot be used as a way to mixin different pieces of code
based on a directing type.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Different predicate strings based on value's type.
</font><font color=blue>alias</font> SwitchOnType!(value,
                    <font color=blue>char</font>,    <font color=red>"a.field[1] == '"</font> ~ value ~ <font color=red>"'"</font>,         <font color=green>/+ Incorrect if value is an int +/</font>
                    string,  Format!(<font color=red>"a.field[1] == \"%s\" "</font>, value), <font color=green>/+ Incorrect if value is a char +/</font>
                    <u>Default</u>, <font color=red>"a.field[1] == "</font> ~ to!string(value)
                    ) predicate;
</pre>
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sat May 15 22:50:10 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

	explorer.packageExplorer.addModule("dranges.algorithm2");

	explorer.packageExplorer.addModule("dranges.associative");

	explorer.packageExplorer.addModule("dranges.eager");

	explorer.packageExplorer.addModule("dranges.experiments");

	explorer.packageExplorer.addModule("dranges.functional2");

	explorer.packageExplorer.addModule("dranges.morphism");

	explorer.packageExplorer.addModule("dranges.patternmatch");

	explorer.packageExplorer.addModule("dranges.phobos_extension");

	explorer.packageExplorer.addModule("dranges.predicate");

	explorer.packageExplorer.addModule("dranges.range2");

	explorer.packageExplorer.addModule("dranges.rangeofranges");

	explorer.packageExplorer.addModule("dranges.recursive");

	explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.templates");

	explorer.packageExplorer.addModule("dranges.traits2");

	explorer.packageExplorer.addModule("dranges.treerange");

	explorer.packageExplorer.addModule("dranges.tuple2");

	explorer.packageExplorer.addModule("dranges.typetuple2");

	explorer.packageExplorer.addModule("dranges.variadic");

	
</script>
</body></html>


