
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.templates</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.templates");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.templates</h1><!-- Generated by Ddoc from dranges\templates.d -->
This module defines some useful templates for the other modules and some 'meta-templates'. Templates
transforming other templates, currying them, flipping their arguments, etc.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud and Simen Kj&aelig;r&aring;s
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isInstanceOf</span>
<script>explorer.outline.addDecl('isInstanceOf');</script>

(T,alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to <b>true</b> if <b><code>T</code></b> is an instance of <b><code>templ</code></b>. To obtain the template parameters,
see TemplateParametersTypeTuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> cy = cycle([0,1,2,3]); <font color=green>// cy is a Cycle!(int[])
</font><font color=blue>alias</font> <font color=blue>typeof</font>(cy) Cy;
<font color=blue>assert</font>(<u>isInstanceOf</u>!(Cy, Cycle));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">staticSwitch</span>
<script>explorer.outline.addDecl('staticSwitch');</script>

(alias F,T...) if (allSatisfy!(isAlias,T))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Switches between template instantiations depending on the parameters passed.
<br><br>
<b>Author:</b><br>
Simen Kj&aelig;r&aring;s.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>staticSwitch</u>( foo, 1, 2, 3 ).With callFoo;
callFoo( 2 ); <font color=green>// Actually calls foo!(2)( )
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">BindT</span>
<script>explorer.outline.addDecl('BindT');</script>

(alias Template,alias Param0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bind <b><code>Param0</code></b> as the first parameter of <b><code>Template</code></b>.
<br><br>
<b>See Also:</b><br>
CurryTemplate, for a more powerful and up-to-date version.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">BindF</span>
<script>explorer.outline.addDecl('BindF');</script>

(alias FunctionTemplate,alias Param0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bind <b><code>Param0</code></b> as the first template parameter of a function template.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CurryTemplate</span>
<script>explorer.outline.addDecl('CurryTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a n-args template and transforms it into n 1-arg templates inside each other.
Very useful for templates with many arguments, when you only have one arg right now, or want
to bind this arg. 
<span class="currsymbol">CurryTemplate</span>
<script>explorer.outline.addDecl('CurryTemplate');</script>

 also works with template alias parameters (and will
wait for an alias, not a type).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// StaticMap takes a template and typetuple as parameters.
</font><font color=blue>alias</font> <u>CurryTemplate</u>!(StaticMap) CStaticMap; <font color=green>// CStaticMap takes a template and then a T... (typetuple)
</font><font color=blue>alias</font> CStaticMap!Unqual SMU; <font color=green>// SMU is now an independant template taking a T... and mapping Unqual on it.
</font>
<font color=blue>assert</font>(<font color=blue>is</font>(SMU!(<font color=blue>int</font>, <font color=blue>const</font> <font color=blue>int</font>, <font color=blue>immutable</font> <font color=blue>double</font>, string) == TypeTuple!(<font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>double</font>, string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">UnWrap</span>
<script>explorer.outline.addDecl('UnWrap');</script>

(string Wrapper,T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a complex type (ie:Cycle!R, Retro!R) and get rid of the external type indicated
as a string. That is 
<span class="currsymbol">UnWrap</span>
<script>explorer.outline.addDecl('UnWrap');</script>

!("Cycle", Cycle!U) aliases itself to U. It's useful
to get some return types, when you extract internal values in a range and need to get their types.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> c = cycle([1,2,3][]);
<font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(c) == Cycle!(<font color=blue>int</font>[]))); <font color=green>// A cycle around an array of int
</font><font color=blue>alias</font> <u>UnWrap</u>!(<font color=red>"Cycle"</font>, <font color=blue>typeof</font>(c)) InternalType;
<font color=blue>assert</font>(<font color=blue>is</font>(InternalType == <font color=blue>int</font>[]));
</pre>
<br><br>
<font color=red>Deprecated:</font><br>
use TemplateParameterTypeTuple instead.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Wrap</span>
<script>explorer.outline.addDecl('Wrap');</script>

(string Wrapper,T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The converse of UnWrap.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FlipTemplate</span>
<script>explorer.outline.addDecl('FlipTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a template and flips its arguments.
So, given:
<pre class="d_code"><font color=blue>template</font> Foo(A,B) {}
</pre>
Then 
<span class="currsymbol">FlipTemplate</span>
<script>explorer.outline.addDecl('FlipTemplate');</script>

!Foo is equivalent to:
<pre class="d_code"><font color=blue>template</font> FlippedFoo(B,A) { <font color=blue>alias</font> Foo!(A,B) FlippedFoo;}
</pre>
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Pair(A,B)
{
    <font color=blue>alias</font> Tuple!(A,B) Pair;
}

<font color=blue>alias</font> <u>FlipTemplate</u>!Pair FPair;

<font color=blue>assert</font>(<font color=blue>is</font>( Pair!(<font color=blue>int</font>,<font color=blue>double</font>) == Tuple!(<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(FPair!(<font color=blue>int</font>,<font color=blue>double</font>) == Tuple!(<font color=blue>double</font>,<font color=blue>int</font>)));
</pre>

This works for any number of parameters.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>FlipTemplate</u>!Tuple FTuple;
<font color=blue>assert</font>(<font color=blue>is</font>(FTuple!(<font color=blue>char</font>,<font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>void</font> <font color=blue>delegate</font>(string)) == Tuple!(<font color=blue>void</font> <font color=blue>delegate</font>(string),<font color=blue>double</font>,<font color=blue>int</font>,<font color=blue>char</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransformTemplate</span>
<script>explorer.outline.addDecl('TransformTemplate');</script>

(alias templ,alias transformTypes)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalized version of FlipTemplate: takes a target template and
a transformation on types (another template). It will then apply
the transformation on the parameters before passing the result to the input
template.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Foo(A) {}; <font color=green>// Foo takes one type as param.
</font><font color=green>// First is template defined in dranges.typetuple that takes a TypeTuple and alias itself to the first type.
</font><font color=blue>alias</font> <u>TransformTemplate</u>!(Foo, First) TFoo; <font color=green>// TFoo is a variadic template. Any T... passed to it is transformed
</font>                                           <font color=green>// by First!T into T[0], before serving as parameter for Foo.
</font>                                           <font color=green>// So, TFoo is now a variadic version of Foo.
</font><font color=blue>assert</font>(<font color=blue>is</font>(TFoo!(<font color=blue>int</font>, <font color=blue>double</font>, string) == Foo!(<font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">T1</span>
<script>explorer.outline.addDecl('T1');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The template equivalent of unaryFun: takes a string as template argument and creates a simple template aliasing
the string. As for unaryFun, the resulting template argument is 'a'.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>T1</u>!<font color=red>"Tuple!(ReturnType!a, ParameterTypeTuple!a)"</font> FunTypes;

<font color=blue>assert</font>(<font color=blue>is</font>(FunTypes!(<font color=blue>int</font> <font color=blue>delegate</font>(<font color=blue>double</font>, string)) == Tuple!(<font color=blue>int</font>, <font color=blue>double</font>, string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">T2</span>
<script>explorer.outline.addDecl('T2');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The binaryFun equivalent for templates: given a string with 'a' and 'b', generates a template from it.
It's useful to quickly make a template, for example for a StaticMap or template composition.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>T2</u>!<font color=red>"a delegate(b)"</font> MkDelegate; <font color=green>// MkDelegate is a template taking two types a and b and becoming
</font>                                     <font color=green>// the type of delegates from b to a.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TN</span>
<script>explorer.outline.addDecl('TN');</script>

(string s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The n-types generalization of T1 and T2: given a string in 'a', 'b', ... (up to 'z'), creates
a template from it. It will automatically determine the corresponding number of parameters
by using the same heuristics than for naryFun in dranges.functional2: it looks for lone letters
and takes the higher one
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>TN</u>!<font color=red>"a delegate(b,c,d)"</font> MkDelegate3; <font color=green>// finds a 'd', arity = 4, MkDelegate3 is a four parameters template
</font><font color=blue>assert</font>(<font color=blue>is</font>(MkDelegate!(<font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>char</font>,string) == <font color=blue>int</font> <font color=blue>delegate</font>(<font color=blue>double</font>,<font color=blue>char</font>,string)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Max</span>
<script>explorer.outline.addDecl('Max');</script>

(alias a,alias b)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Aliases itself to the max of a and b.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Min</span>
<script>explorer.outline.addDecl('Min');</script>

(alias a,alias b)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Aliases itself to the min of a and b.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isTemplate</span>
<script>explorer.outline.addDecl('isTemplate');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to <b>true</b> iff templ is a template (standard, function, class or struct template).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateArity</span>
<script>explorer.outline.addDecl('TemplateArity');</script>

(alias templ) if (isTemplate!(templ))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the number of parameters needed to instantiate template <b><code>templ</code></b>.
To represent variadic template, returns a negative number.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Foo0()    {}
<font color=blue>template</font> Foo1(A)   {}
<font color=blue>template</font> Foo2(A,B) {}
<font color=blue>template</font> FooVar(A,B,C...) {}

<font color=blue>assert</font>(<u>TemplateArity</u>!Foo0 == 0);
<font color=blue>assert</font>(<u>TemplateArity</u>!Foo1 == 1);
<font color=blue>assert</font>(<u>TemplateArity</u>!Foo2 == 2);
<font color=blue>assert</font>(<u>TemplateArity</u>!Foo3 == -3); <font color=green>// Three params, the last being variadic.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateParametersTypeTuple</span>
<script>explorer.outline.addDecl('TemplateParametersTypeTuple');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a type instantiating a template (that is, T == A!(someTypes...) for some A)
and becomes the template's parameters typetuple: TypeTuple!(someTypes) in the previous example.
It won't work for alias parameters, because they're not imported by this module.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>is</font>(<u>TemplateParametersTypeTuple</u>!(Cycle!(<font color=blue>int</font>[])) == TypeTuple!(<font color=blue>int</font>[])));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateName</span>
<script>explorer.outline.addDecl('TemplateName');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>If T is a template instantiation, becomes the template name. For a non-templated type,
it just becomes this type name.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>struct</font> Foo(T...) {}
<font color=blue>alias</font> Foo!(<font color=blue>int</font>, <font color=blue>double</font>) Foo_id;
<font color=blue>assert</font>(<u>TemplateName</u>!(Foo_id) == <font color=red>"Foo"</font>);

<font color=blue>assert</font>(<u>TemplateName</u>!(<font color=blue>int</font>) == <font color=red>"int"</font>);
</pre>
<br><br>
<b>Note:</b><br>
almost completly untested!<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TemplateFunctionPTT</span>
<script>explorer.outline.addDecl('TemplateFunctionPTT');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the parameters typetuple from a non-instantiated template function. It creates
a list of structs T0, T1, ..., Tn (n being TemplateArity!fun) and instantiates fun
to do that. So the resulting TypeTuple is defined for inexistant types!
<br><br>
<b>Limitation:</b><br>
Does not work if there are constraints on the types.

<br><br>
<b>BUG:</b><br>
Should be modified to work with variadic templates.

<br><br>
<b>Example:</b><br>
<pre class="d_code">A foo(A,B)(A a, B b, Tuple!(B,A) c, B d) { <font color=blue>return</font> a;}
<font color=blue>alias</font> <u>TemplateFunctionPTT</u>!foo PTTfoo; <font color=green>// PTTfoo is TypeTuple!(T0, T1, Tuple!(T1,T0), T1)
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">TemplateFunArity</span>
<script>explorer.outline.addDecl('TemplateFunArity');</script>

(alias templ)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the number of args of a non-instantiated template function. Not to be confused with
<b><code>TemplateArity</code></b> which gives the number of parameters for the template.
<br><br>
<b>Example:</b><br>
<pre class="d_code">A foo(A,B)(A a, B b, Tuple!(B,A) c, B d) { <font color=blue>return</font> a;}

<font color=blue>assert</font>(<u>TemplateFunArity</u>!foo == 4);
<font color=blue>assert</font>(TemplateArity!foo    == 2);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CompareTypes</span>
<script>explorer.outline.addDecl('CompareTypes');</script>

(T,U)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A small template to sort types.
<br><br>
<b>See Also:</b><br>
dranges.typetuple.SortTypes<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">string 
<span class="currsymbol">TemplateConstraints</span>
<script>explorer.outline.addDecl('TemplateConstraints');</script>

(alias templ)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the constraints of a template (the guard <b><font color=blue>if (...)</font></b> after the template name), if any. If there is
no constraint, returns the empty string.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> Foo(<font color=blue>alias</font> A, B, C)
{
    <font color=blue>alias</font> A!(B,C) Foo;
}

<font color=blue>template</font> Bar(A,B,C) <font color=blue>if</font> (isIntegral!B &amp;&amp; <font color=blue>is</font>(C == CommonType!(A,B)))
{
    <font color=blue>alias</font> Tuple!(A,B,C) Bar;
}

<font color=blue>assert</font>(<u>TemplateConstraints</u>!Bar == <font color=red>"isIntegral!(B) &amp;&amp; is(C == CommonType!(A,B))"</font>);
<font color=blue>assert</font>(<u>TemplateConstraints</u>!Foo == <font color=red>""</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isAlias</span>
<script>explorer.outline.addDecl('isAlias');</script>

(alias a)<br>template 
<span class="currsymbol">isAlias</span>
<script>explorer.outline.addDecl('isAlias');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if a is an alias (a symbol bound by an alias template parameter). It's useful when you have
a variadic type (T...) and some of its components may be aliases instead of types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isType</span>
<script>explorer.outline.addDecl('isType');</script>

(T)<br>template 
<span class="currsymbol">isType</span>
<script>explorer.outline.addDecl('isType');</script>

(alias a)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if T is a type and not an alias. It's useful when you have
a variadic type (T...) and some of its components may be types or aliases..<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Constant</span>
<script>explorer.outline.addDecl('Constant');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The constant template (akin to the constant function).
Once instantiated with a type, its next instantiation will gives the original type.
It's sometimes useful while mapping templates, composing templates or acting on types in general.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Constant</u>!<font color=blue>int</font> CInt;
<font color=blue>assert</font>(<font color=blue>is</font>(StaticMap!(CInt,<font color=blue>double</font>,<font color=blue>int</font>,string,<font color=blue>char</font>) == TypeTuple!(<font color=blue>int</font>,<font color=blue>int</font>,<font color=blue>int</font>,<font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Void</span>
<script>explorer.outline.addDecl('Void');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The void template: whatever types you give it, it's void.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Null</span>
<script>explorer.outline.addDecl('Null');</script>

()</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The <b>null</b> template: takes no type, is void (seems strange, but sometime useful)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Id</span>
<script>explorer.outline.addDecl('Id');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The identity template: becomes the types you gives it as parameters. If you give
it one type, it alias itself to this type, not TypeTuple!type.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Compose</span>
<script>explorer.outline.addDecl('Compose');</script>

(Templates...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compose n templates together. This is one very powerful meta-template, if
I may say so...
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Compose</u>!(Cycle, ArrayType) MkCycle; <font color=green>// Takes a T, makes a Cycle!(T[]).
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ArrayType</span>
<script>explorer.outline.addDecl('ArrayType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to T[]. Useful for template composition.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Apply</span>
<script>explorer.outline.addDecl('Apply');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Apply types <b><code>T</code></b> on successive templates (that is, instantiate them with <b><code>T</code></b>) and makes a TypeTuple from it.
It's the complement of <b><code>StaticMap</code></b>, which takes a template an applies it on successive types.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>Apply</u>!(SomeTypes).On!(Templates).
</pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Apply</u>!(<font color=blue>int</font>,<font color=blue>double</font>) Applier;
<font color=blue>alias</font> Applier.On!(MkDelegate, Tuple, Doubler, CommonType) Result;
<font color=blue>assert</font>(<font color=blue>is</font>(Result == TypeTuple!(<font color=blue>int</font> <font color=blue>delegate</font>(<font color=blue>double</font>), Tuple!(<font color=blue>int</font>,<font color=blue>double</font>), <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>double</font>)));
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">On</span>
<script>explorer.outline.addDecl('On');</script>

(alias templ1,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>ditto<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Instantiate</span>
<script>explorer.outline.addDecl('Instantiate');</script>

(alias templ1,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Like <b><code>Apply.On</code></b>, but reversed: first, the templates, then the type.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>Instantiate</u>!(SomeTemplates).With!(SomeTypes).
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">MkDelegate</span>
<script>explorer.outline.addDecl('MkDelegate');</script>

(ReturnType,ParameterTypes...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The type of a delegate with corresponding parameters.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransferParamsTo</span>
<script>explorer.outline.addDecl('TransferParamsTo');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Usage:</b><br>
<pre class="d_code"><u>TransferParamsTo</u>!(someTemplate).From!(someTemplatedType).
</pre>
It will extract the template parameters from <b><code>someTemplatedType</code></b> and instantiate <b><code>someTemplate</code></b> with them.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>TransferParamsTo</u>!Repeat MkRepeat;
<font color=blue>alias</font> MkRepeat.From!(Cycle!(<font color=blue>int</font>[])) R; <font color=green>// takes a Cycle!(Range), extracts Range, makes a Repeat from it.
</font><font color=blue>assert</font>(<font color=blue>is</font>(R == Repeat!(<font color=blue>int</font>[]))); <font color=green>// R is a Repeat!(int[])
</font></pre>

<br><br>
<b>Note:</b><br>
so, <b><code>TransferParamsTo</code></b> can be seen as a 'function' from a domain of types to another domain. It's a functor,
in a mathematical/Haskell sense (which has nothing to do with a C++ functor).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TransferParamsFrom</span>
<script>explorer.outline.addDecl('TransferParamsFrom');</script>

(alias templ)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The same, but with arguments inverted.
<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>TransferParamsFrom</u>!(someTemplatedType).To!(someTemplate)
</pre>

<br><br>
<b>See Also:</b><br>
TransferParamsTo<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">Default</span>
<script>explorer.outline.addDecl('Default');</script>

;
<br>template 
<span class="currsymbol">SwitchOnType</span>
<script>explorer.outline.addDecl('SwitchOnType');</script>

(alias value,Type,alias Action,Rest...)<br>template 
<span class="currsymbol">SwitchOnType</span>
<script>explorer.outline.addDecl('SwitchOnType');</script>

(alias value,Type : Default,alias Action)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An small switch-like template to produce different code depending on the type of value. The 
<span class="currsymbol">Default</span>
<script>explorer.outline.addDecl('Default');</script>

 class
is used to indicate (wait for it) a default value.
<pre class="d_code"><font color=blue>int</font> i; <font color=blue>double</font> d; string s;
<font color=blue>alias</font> SwitchOnType!(i, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchi;
<font color=blue>alias</font> SwitchOnType!(d, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchd;
<font color=blue>alias</font> SwitchOnType!(s, <font color=blue>int</font>, <font color=red>"It's an int"</font>, <font color=blue>double</font>, <font color=red>"It's a double"</font>, <u>Default</u>, <font color=red>"It's something else"</font>) switchs;
<font color=blue>assert</font>(switchi == <font color=red>"It's an int"</font>);
<font color=blue>assert</font>(switchd == <font color=red>"It's a double"</font>);
<font color=blue>assert</font>(switchs == <font color=red>"It's something else"</font>);
</pre>
<br><br>
<b>BUG:</b><br>
Well, not a bug really, but a severe limitation: the 'Action' alias are all evaluated at compile-time, there are not lazy.
I found out it drastically limits the interest of this template: it cannot be used as a way to mixin different pieces of code
based on a directing type.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Different predicate strings based on value's type.
</font><font color=blue>alias</font> SwitchOnType!(value,
                    <font color=blue>char</font>,    <font color=red>"a.field[1] == '"</font> ~ value ~ <font color=red>"'"</font>,         <font color=green>/+ Incorrect if value is an int +/</font>
                    string,  Format!(<font color=red>"a.field[1] == \"%s\" "</font>, value), <font color=green>/+ Incorrect if value is a char +/</font>
                    <u>Default</u>, <font color=red>"a.field[1] == "</font> ~ to!string(value)
                    ) predicate;
</pre>
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:56:12 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


