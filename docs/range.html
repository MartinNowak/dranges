
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.range</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.range");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.range</h1><!-- Generated by Ddoc from dranges\range.d -->
This module defines new ranges or rather, higher-order ranges: ranges acting on ranges
to transform them or present a new view. As far as possible, all higher-order ranges presented in this module
and in <b><code>dranges.algorithm</code></b> are "tight wrappers": they are bidirectional if their input 
<span class="currsymbol">range</span>
<script>explorer.outline.addDecl('range');</script>

 is bidirectional,
define <b><code>opIndex</code></b>, <b><code>opIndexAssign</code></b>, <b><code>length</code></b> if it's possible, etc. That way, a good input 
<span class="currsymbol">range</span>
<script>explorer.outline.addDecl('range');</script>

 (for example, a random-access 
<span class="currsymbol">range</span>
<script>explorer.outline.addDecl('range');</script>

)
will see its properties propagated through a chain of calls.
<ul> <li>Some of these are usual in other languages (Haskell, Scala, Clojure, ...) and are quite useful: <b><code>drop</code></b>, <b><code>dropWhile</code></b>, <b><code>takeWhile</code></b>, etc.</li>
  <li>Some are extension of standard functions: <b><code>delay</code></b> as a generic way to segment a 
<span class="currsymbol">range</span>
<script>explorer.outline.addDecl('range');</script>

.</li>
  <li>Some are there just for fun and served as exercices when I wanted to "grok" ranges (like <b><code>torus</code></b>, <b><code>bounce</code></b>, <b><code>emptyRange</code></b>, <b><code>once</code></b>).</li>
  </ul>
Also, once we admit <b><code>std.typecons.tuples</code></b> as a common way to return many values, tuple-returning
ranges can be acted upon in various ways, splicing/shredding/rotating/stitching them. As many ranges and algorithms
presented in this package produce tuples, having a rich way to act upon them permits all kinds of reuse.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">minLength</span>
<script>explorer.outline.addDecl('minLength');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Return:</b><br>
the smallest length of all non-infinite ranges passed as inputs. All finite ranges must have a length member.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>];
<font color=blue>int</font>[] r = [0,1,2,3];
<font color=blue>auto</font> c = repeat(5); <font color=green>// infinite
</font><font color=blue>auto</font> ml = <u>minLength</u>(s,r,c);
<font color=blue>assert</font>(ml == 4); <font color=green>// r length
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">R 
<span class="currsymbol">drop</span>
<script>explorer.outline.addDecl('drop');</script>

(R)(R <span class="funcparam">r</span>, size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a copy of r, with the first n elements dropped. Compare to
popFrontN which affects r. "n" is the first argument as in std.range.take
(which in turn takes this from Haskell)
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> d = <u>drop</u>(3, r1);
<font color=blue>assert</font>(equal(d, [3,4,5][]));
<font color=blue>assert</font>(equal(<u>drop</u>(0, r1), r1)); <font color=green>// drops 0 element -&gt; equal to r1
</font><font color=blue>assert</font>(<u>drop</u>(6, r1).empty); <font color=green>// drops all elements -&gt; empty range
</font><font color=blue>assert</font>(<u>drop</u>(100, r1).empty); <font color=green>// drops more than r1.length -&gt; empty range.
</font></pre>
<br><br>
<b>Note:</b><br>
It's not lazy: it drops all available elements during the call.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Take!(R) 
<span class="currsymbol">slice</span>
<script>explorer.outline.addDecl('slice');</script>

(R)(R <span class="funcparam">range</span>, int <span class="funcparam">begin</span>, int <span class="funcparam">end</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">R 
<span class="currsymbol">dropLast</span>
<script>explorer.outline.addDecl('dropLast');</script>

(R)(R <span class="funcparam">range</span>, size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Drops the last n elements of range. R must be bidirectional.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">R 
<span class="currsymbol">dropWhile</span>
<script>explorer.outline.addDecl('dropWhile');</script>

(alias pred, size_t step = 1, R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a copy of r, with the first elements dropped as long as pred if verified. Compare to
popFrontWhile which affects r.
<br><br>
The predicate may be unary:
<pre class="d_code">string s = <font color=red>"  , abcd  efg"</font>;
<font color=blue>auto</font> d1 = <u>dropWhile</u>!(isOneOf!<font color=red>" ,"</font>)(s); <font color=green>// isOneOf!" ," returns true for " " and for ","
</font><font color=blue>assert</font>(d1 == <font color=red>"abcd  efg"</font>);

<font color=blue>auto</font> r1 = [0,1,2,3,3,4,5];
<font color=blue>auto</font> d2 = <u>dropWhile</u>!<font color=red>"a&lt;4"</font>(r1);      <font color=green>// String predicate
</font><font color=blue>assert</font>(equal(d2, [4,5][]));
</pre>

Or it can be binary (or ternary, or whatever), possibly a string, as "a&lt;b".
<br><br>

The second (optional) argment is the step, which must be between 1 and the pred's arity. Step's default is 1.
<br><br>

If step == arity, it will drop the entire segment at each step.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> d3 = <u>dropWhile</u>!<font color=red>"a&lt;b"</font>(r1);     <font color=green>// drop as long as r1 is strictly increasing, testing with binary predicate "a&lt;b"
</font>                                   <font color=green>// It will test [0,1] and drop 0. Then test [1,2] and drop 1, ...
</font><font color=blue>assert</font>(equal(d3, [3,3,4,5][]));    <font color=green>// the result begins with a couple for which a&lt;b doesn"t hold
</font>
<font color=blue>auto</font> d4 = <u>dropWhile</u>!(<font color=red>"a&lt;b"</font>,2)(r1); <font color=green>// drop as long as r1 is strictly increasing, testing with binary predicate, step of 2
</font>                                   <font color=green>// It will test [0,1] and drop [0,1]. Then test [2,3] and drop it also.
</font>                                   <font color=green>// Then it will drop [3,4] and stop at 5.
</font><font color=blue>assert</font>(equal(d4, [5][]));

<font color=blue>auto</font> d5 = <u>dropWhile</u>!<font color=red>"a&lt;b &amp;&amp; b&lt;c"</font>(r1); <font color=green>// Growing range, with three args (step defaults to 1)
</font><font color=blue>assert</font>(equal(d5, [2,3,3,4,5][]));

<font color=blue>bool</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> a*b &lt; 3;}
<font color=blue>auto</font> d6 = <u>dropWhile</u>!foo(r1);            <font color=green>// binary fun as predicate
</font><font color=blue>assert</font>(equal(d6, [2,3,3,4,5][]));

<font color=blue>auto</font> d7 = <u>dropWhile</u>!<font color=red>"true"</font>(r1); <font color=green>// 0-arg predicate, always true -&gt; drops everything -&gt; d7 is empty
</font><font color=blue>assert</font>(d7.empty);

<font color=blue>int</font>[] e;
<font color=blue>assert</font>(<u>dropWhile</u>!<font color=red>"a&lt;4"</font>(e).empty); <font color=green>// dropping on an empty range: always empty
</font>
<font color=blue>auto</font> r2 = [1];
<font color=blue>auto</font> d8 = <u>dropWhile</u>!<font color=red>"a&lt;b"</font>(r2); <font color=green>// binary predicate: cannot be true applied on [1] -&gt; stops at once
</font><font color=blue>assert</font>(equal(d8, [1][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">popFrontWhile</span>
<script>explorer.outline.addDecl('popFrontWhile');</script>

(alias pred, size_t step = 1, R)(ref R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Advances range while predicate pred is <b>true</b>. It will change range!
The predicate can be a function or a string. If it's a binary (or more) predicate,
it will test as many elements (2, 3...) in one step.
<br><br>
There is an optional argument: the step, defaulting to 1.
<br><br>
<b>Returns:</b><br>
the number of elements popped.
<br><br>
<b>See Also:</b><br>
dropWhile.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = [0,1,2,3,4];
<font color=blue>auto</font> r3 = [0,1,2,1,0];
<font color=blue>auto</font> r4 = [0,1,2,3,2,1];
<font color=blue>auto</font> e;

<font color=blue>auto</font> a = <u>popFrontWhile</u>!<font color=red>"a&lt;2"</font>(r1); <font color=green>// standard use
</font><font color=blue>assert</font>(equal(r1, [2,3,4][]));
<font color=blue>assert</font>(a == 2);

a = <u>popFrontWhile</u>!<font color=red>"a&gt;5"</font>(r2);
<font color=blue>assert</font>(equal(r2, [0,1,2,3,4][])); <font color=green>// false predicate, nothing changed
</font><font color=blue>assert</font>(a == 0);

a = <u>popFrontWhile</u>!<font color=red>"a&lt;b"</font>(r3); <font color=green>// binary predicate, step defaults to 1.
</font><font color=blue>assert</font>(equal(r3, [2,1,0][]));
<font color=blue>assert</font>(a == 2);

a = <u>popFrontWhile</u>!(<font color=red>"a&lt;b"</font>,2)(r4); <font color=green>// binary predicate, step of 2.
</font><font color=blue>assert</font>(equal(r4, [2,1][]));
<font color=blue>assert</font>(a == 4);

a = <u>popFrontWhile</u>!<font color=red>"a&gt;5"</font>(e); <font color=green>// On an empty range, pops nothing.
</font><font color=blue>assert</font>(a == 0);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TakeWhile</span>
<script>explorer.outline.addDecl('TakeWhile');</script>

(alias pred,R) if (isForwardRange!(R) &amp;&amp; arity!(pred) &gt; 0);
<br>struct 
<span class="currsymbol">TakeWhile</span>
<script>explorer.outline.addDecl('TakeWhile');</script>

(alias pred,R) if (isForwardRange!(R) &amp;&amp; arity!(pred) == 0);
<br>TakeWhile!(pred,R) 
<span class="currsymbol">takeWhile</span>
<script>explorer.outline.addDecl('takeWhile');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes elements from range as long as pred is verified. Usually, the predicate
is a unary function. It can be a binary (or more) function, but only the first element is delivered.
Compared to dropWhile and such, there is no step option.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,4,6,1,1,1,0];
<font color=blue>auto</font> tw1 = takeWhile!<font color=red>"a&lt;6"</font>(r1); <font color=green>// unary predicate
</font><font color=blue>assert</font>(equal(tw1, [0,1,2,3,4,4][]));
<font color=blue>auto</font> tw2 = takeWhile!<font color=red>"a&lt;b"</font>(r1); <font color=green>// binary predicate
</font><font color=blue>assert</font>(equal(tw2, [0,1,2,3][]));
<font color=blue>bool</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b, <font color=blue>int</font> c) {<font color=blue>return</font> a&lt;b &amp;&amp; b&lt;c;} <font color=green>// ternary predicate
</font><font color=blue>auto</font> tw3 = takeWhile!foo(r1);
<font color=blue>assert</font>(equal(tw3, [0,1,2][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">R 
<span class="currsymbol">tail</span>
<script>explorer.outline.addDecl('tail');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Like the eponymous function found in all functional languages.
Returns the range minus its first element. If range is empty
it just returns it.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3];
<font color=blue>auto</font> tails = [r][];
<font color=blue>foreach</font>(i; 0..5) {
    r = <u>tail</u>(r);
    tails ~= r;
}
<font color=blue>assert</font>(equal(tails, [[0,1,2,3], [1,2,3], [2,3], [3], [], [] ][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tails!(R) 
<span class="currsymbol">tails</span>
<script>explorer.outline.addDecl('tails');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the successive application of tail on a range, up to the empty range.
If the input range is empty, 
<span class="currsymbol">tails</span>
<script>explorer.outline.addDecl('tails');</script>

 is empty.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3];
<font color=blue>auto</font> t = <u>tails</u>(r);
<font color=blue>assert</font>(equal(t, [[1,2,3], [2,3], [3], [] ][]));

<font color=blue>int</font>[] e;
<font color=blue>auto</font> t1 = <u>tails</u>(r[0..1]);
<font color=blue>assert</font>(equal(t1, [e][])); <font color=green>// One element -&gt; [] and then stops.
</font>
<font color=blue>auto</font> te = <u>tails</u>(e);
<font color=blue>assert</font>(te.empty); <font color=green>// No element -&gt; empty
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Heads!(R) 
<span class="currsymbol">heads</span>
<script>explorer.outline.addDecl('heads');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes n successive elements from range, with n going from 0 (an empty range) to range.length included.
It's more efficient for a range with a length: 
<span class="currsymbol">heads</span>
<script>explorer.outline.addDecl('heads');</script>

 knows when to stop. For a range
that doesn"t know its length, 
<span class="currsymbol">heads</span>
<script>explorer.outline.addDecl('heads');</script>

 has to calculate for each new head if it's the entire range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3];
<font color=blue>auto</font> h = <u>heads</u>(r);
<font color=blue>assert</font>(equal(h, [[], [0], [0,1], [0,1,2], [0,1,2,3] ][])); <font color=green>// from [] up to r itself.
</font>
<font color=blue>auto</font> f = filter!<font color=red>"a&lt;10"</font>(r); <font color=green>// equivalent to r, but doesn"t know its own length
</font><font color=blue>auto</font> hf = <u>heads</u>(f);
<font color=blue>foreach</font>(elem; hf) { <font color=green>// Compare it to f
</font>    <font color=blue>assert</font>(equal(elem, h.front)); <font color=green>// They are indeed the same
</font>    h.popFront;
    l++; <font color=green>// accumulate length
</font>}
popFrontN(hf, l); <font color=green>// get rid of all elements?
</font><font color=blue>assert</font>(hf.empty); <font color=green>// Yes, it's empty
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Chain!(typeof(take(R1.init,0)),R2,R1) 
<span class="currsymbol">insertAt</span>
<script>explorer.outline.addDecl('insertAt');</script>

(R1, R2)(size_t <span class="funcparam">n</span>, R1 <span class="funcparam">range1</span>, R2 <span class="funcparam">range2</span>);
<br>Chain!(typeof(take(R.init,0)),E[],R) 
<span class="currsymbol">insertAt</span>
<script>explorer.outline.addDecl('insertAt');</script>

(R, E)(size_t <span class="funcparam">n</span>, R <span class="funcparam">range</span>, E <span class="funcparam">element</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Inserts an element or an entire range into range1 at position n. Position 0 means before range1. If position &gt;= range1.length,
element/range2 is just concatenated at the end.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3];
<font color=blue>auto</font> m = map!<font color=red>"a*a"</font>(r1);

<font color=blue>auto</font> ia0 = <u>insertAt</u>(0, r1, m);
<font color=blue>auto</font> ia2 = <u>insertAt</u>(2, r1, m);
<font color=blue>auto</font> ia10 = <u>insertAt</u>(10, r1, m);

<font color=blue>assert</font>(equal(ia0, [0,1,4,9,  0,1,2,3][]));
<font color=blue>assert</font>(equal(ia2, [0,1,  0,1,4,9,  2,3][]));
<font color=blue>assert</font>(equal(ia10,[0,1,2,3,  0,1,4,9][]));

<font color=blue>auto</font> ia1 = <u>insertAt</u>(1, r1, 99);
<font color=blue>assert</font>(equal(ia1, [0,99,1,2,3][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(R,R) 
<span class="currsymbol">cutAt</span>
<script>explorer.outline.addDecl('cutAt');</script>

(R)(size_t <span class="funcparam">index</span>, R <span class="funcparam">range</span>);
<br>Tuple!(ElementType!(R)[],R) 
<span class="currsymbol">cutAt</span>
<script>explorer.outline.addDecl('cutAt');</script>

(R)(size_t <span class="funcparam">index</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Cuts a range in two parts, separating them at index index. It returns the parts as a tuple.
The second part will begin with range[index].
If slicing is available, it will use it and return a Tuple!(R,R). If not, it iterates the range
and returns a Tuple!( (ElementType!R)[], R ).
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5]; <font color=green>// Cutting an array (range with length and slicing)
</font><font color=blue>auto</font> c1 = <u>cutAt</u>(3, r1);
<font color=blue>assert</font>(first(c1) == [0,1,2][]);     <font color=green>// first part
</font><font color=blue>assert</font>(second(c1) == [3,4,5][]);    <font color=green>// second part
</font><font color=blue>assert</font>(equal(r1, [0,1,2,3,4,5][])); <font color=green>// r1 is unchanged
</font><font color=blue>auto</font> c2 = <u>cutAt</u>(0, r1);             <font color=green>// Cuts at position 0
</font><font color=blue>assert</font>(first(c2).empty);
<font color=blue>assert</font>(second(c2) == r1);
<font color=blue>auto</font> c3 = <u>cutAt</u>(1000, r1);          <font color=green>// Cuts farther than range.length. No exception is thrown, it returns (range, [])
</font><font color=blue>assert</font>(first(c3) == r1);
<font color=blue>assert</font>(second(c3).empty);
<font color=blue>auto</font> c4 = <u>cutAt</u>(5, stutter(3, r1)); <font color=green>// Cutting a range with a length but no slicing
</font><font color=blue>assert</font>(equal(first(c4), [0,0,0,1,1][]));
<font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(first(c4)) == <font color=blue>int</font>[]));           <font color=green>// The first part is an int[] (nothing more can be done generically)
</font><font color=blue>assert</font>(equal(second(c4), [1,2,2,2,3,3,3,4,4,4,5,5,5][]));
<font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(second(c4)) == Stutter!(<font color=blue>int</font>[]))); <font color=green>// The second part is still a Stutter
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(ElementType!(R)[],R) 
<span class="currsymbol">cutWhen</span>
<script>explorer.outline.addDecl('cutWhen');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterates on range as long as pred(elem) is verified. Then returns a tuple containing the first part as an array
and the second part as a truncated range.
<br><br>
<b>Note:</b><br>
It cannot return a Tuple!(R,R) as sometimes we cannot construct a R from the popped elements: if
R is a Map!() for example, there is no easy and generic way for the first part to be created as a Map also.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> cut = <u>cutWhen</u>!<font color=red>"a&lt;3"</font>(r1);
<font color=blue>assert</font>(equal(cut.field[0], [0,1,2][]));
<font color=blue>assert</font>(equal(cut.field[1], [3,4][]));

<font color=blue>assert</font>(equal(r1, [0,1,2,3,4][])); <font color=green>// r1 is unchanged
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Knit</span>
<script>explorer.outline.addDecl('Knit');</script>

(R...) if (allSatisfy!(isForwardRange,R));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An alternate (simpler) form of std.range.zip: produce a range of std.typecons.Tuples from
a variadic list. Used mainly to interact with other ranges, as Tuples are more generic
than Proxy. It will stops as soon as one of the input ranges is empty.
If only one range is given as input, it will still produce a tuple. So knit(r) != r
<br><br>
It's an extensible range: opIndex, back, popBack, length, opIndex, opIndexAssign and opSlice
are defined if possible (though some improvement could be made on dealing with infinite ranges).
If all ranges are infinite, 
<span class="currsymbol">Knit</span>
<script>explorer.outline.addDecl('Knit');</script>

 sees it and defines itself as infinite also.

<br><br>
<b>Note:</b><br>
it unqualifies the element types (ie: a string has immutable(char) for element type,
but the tuple will use only char).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> r2 = [3.14, 2.78, 0.25, -1.0, 0.0];
<font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>];

<font color=blue>auto</font> k = knit(r1,s,r2);
<font color=blue>assert</font>(k.front == tuple(0,<font color=red>"a"</font>,3.14));
<font color=blue>assert</font>(equal(k, [tuple(0,<font color=red>"a"</font>,3.14), tuple(1,<font color=red>"b"</font>,2.78), tuple(2,<font color=red>"c"</font>,0.25), tuple(3,<font color=red>"d"</font>,-1.0)][]));

<font color=green>// Defining more operations:
</font><font color=blue>assert</font>(k.length == s.length); <font color=green>// length is defined
</font><font color=green>// back and popBack are defined
</font><font color=blue>assert</font>(equal(retro(k),
            [tuple(3,<font color=red>"d"</font>,-1.0), tuple(2,<font color=red>"c"</font>,0.25), tuple(1,<font color=red>"b"</font>,2.78), tuple(0,<font color=red>"a"</font>,3.14)][]));
<font color=blue>assert</font>(k[2] == tuple(2, <font color=red>"c"</font>, 0.25)); <font color=green>// opIndex is defined
</font><font color=blue>assert</font>(equal(k[1..3], [tuple(1, <font color=red>"b"</font>, 2.78), tuple(2, <font color=red>"c"</font>, 0.25)][])); <font color=green>// opSlice is defined
</font>
<font color=green>// More operations impossible:
</font><font color=blue>auto</font> m = map!<font color=red>"a*a"</font>(r2); <font color=green>// no .length, .back, ... (except if you use phobos_extension.d)
</font><font color=blue>auto</font> k2 = knit(r1, r2, m);
<font color=blue>assert</font>(k2.front == tuple(0, 3.14, 3.14*3.14));
<font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(k2.length))); <font color=green>// so no .length defined for k2. Nor .back, etc.
</font>
<font color=green>// OpIndexAssign: needs ranges which are assignable (ie: no string, map...)
</font><font color=blue>auto</font> k3 = knit(r1, r2);
k3[2] = tuple(0, 0.0);
<font color=blue>assert</font>(equal(k3, [tuple(0, 3.14), tuple(1,2.78), tuple(0,0.0), tuple(3, -1.0), tuple(4, 0.0)][]));

<font color=green>// On empty ranges: empty
</font><font color=blue>assert</font>(knit(r1, emptyRange!<font color=blue>int</font>, r2).empty);
</pre>
<br><br>
<b>Limitation:</b><br>
It cannot be sorted, as front/back do not return by ref. std.range.Zip sort of cheats, inserting a
special proxySwap method inside its Proxy, which is treated specially by std.algo.sortImpl. If you
need a 
<span class="currsymbol">Knit</span>
<script>explorer.outline.addDecl('Knit');</script>

 to be sorted, you can call sortAsArray on it.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> ak = sortAsArray(k);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">StitchType!(R) 
<span class="currsymbol">stitch</span>
<script>explorer.outline.addDecl('stitch');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create a tuple-returning range from a variadic list of tuple-returning ranges by outputting their elements
all in parallel in one tuple.
(it's a bit like Knit, but it acts only on tuple-ranges and with auto-flattening of the tuples).
Tuple-returning ranges are knit, tmap, tfilter, segment, delay, ...
and obviously any map-like range with a tuple-returning function: map, comprehension, parallelComprehension, ...
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> r2 = [0.1, 0.2, 0.3, 0.4];
<font color=blue>auto</font> r3 = [<font color=red>"abc"</font>, <font color=red>"def"</font>, <font color=red>""</font>, <font color=red>"g"</font>];
<font color=blue>auto</font> r4 = [<font color=red>"a"</font>, <font color=red>"b"</font>, <font color=red>"c"</font>, <font color=red>"d"</font>, <font color=red>"e"</font>, <font color=red>"f"</font>];

<font color=blue>auto</font> k1 = knit(r1,r2); <font color=green>// returns Tuple!(int, double)
</font><font color=blue>auto</font> k2 = knit(r3,r4); <font color=green>// returns Tuple!(string, char)
</font><font color=blue>auto</font> tf = tfilter!<font color=red>"b&lt;2"</font>(r3,r1); <font color=green>// returns Tuple!(string, int);
</font>
<font color=blue>auto</font> s = <u>stitch</u>(k1,k2,tf); <font color=green>// returns Tuple!(int,double,string,char,string,int)
</font>
<font color=blue>assert</font>(s.front == tuple(0, 0.1, <font color=red>"abc"</font>, <font color=red>"a"</font>, <font color=red>"abc"</font>, 0));
s.popFront;
<font color=blue>assert</font>(s.front == tuple(1, 0.2, <font color=red>"def"</font>, <font color=red>"b"</font>, <font color=red>"def"</font>, 1));
s.popFront;
<font color=blue>assert</font>(s.empty); <font color=green>// tf stops there because now r1's elements are not less than 2. So s stops there also.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Map!(naryFun!(rotateTuple!(n,ElementType!(R).Types)),R) 
<span class="currsymbol">twist</span>
<script>explorer.outline.addDecl('twist');</script>

(int n, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a tuple-producing range and rotate each tuple by n positions. If n&gt;0,
it rotates to the left: takes the first n fields and put them at the end.
If n&lt;0 it rotates to the right: takes the last n fields and put them at the beginning.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = [3.14, 2.78, 1.414];
<font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>];

<font color=green>// Let's create a tuple-returning range.
</font><font color=blue>auto</font> k = knit(r1,r2,s);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(k)) == Tuple!(<font color=blue>int</font>,<font color=blue>double</font>,string)));
<font color=blue>assert</font>(equal(k, [tuple(0,3.14,<font color=red>"a"</font>), tuple(1,2.78,<font color=red>"b"</font>), tuple(2,1.414,<font color=red>"c"</font>)][]));

<font color=blue>auto</font> rot1 = <u>twist</u>!1(k);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(rot1)) == Tuple!(<font color=blue>double</font>,string,<font color=blue>int</font>)));
<font color=blue>assert</font>(equal(rot1, [tuple(3.14,<font color=red>"a"</font>,0), tuple(2.78,<font color=red>"b"</font>,1), tuple(1.414,<font color=red>"c"</font>,2)][]));

<font color=blue>auto</font> rot_1 = <u>twist</u>!(-1)(k);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(rot_1)) == Tuple!(string,<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(equal(rot_1, [tuple(<font color=red>"a"</font>,0,3.14), tuple(<font color=red>"b"</font>,1,2.78), tuple(<font color=red>"c"</font>,2,1.414)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Map!(naryFun!(reverseTuple!(ElementType!(R).Types)),R) 
<span class="currsymbol">reverse</span>
<script>explorer.outline.addDecl('reverse');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a tuple-producing range and 
<span class="currsymbol">reverse</span>
<script>explorer.outline.addDecl('reverse');</script>

 each tuple: the first field
becomes the last one, and so on.
<br><br>
<b>Note:</b><br>
I"d like another name. twist?

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = [3.14, 2.78, 1.414];
<font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>];

<font color=blue>auto</font> k = knit(r1,r2,s);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(k)) == Tuple!(<font color=blue>int</font>,<font color=blue>double</font>,string)));
<font color=blue>assert</font>(equal(k, [tuple(0,3.14,<font color=red>"a"</font>), tuple(1,2.78,<font color=red>"b"</font>), tuple(2,1.414,<font color=red>"c"</font>)][]));

<font color=blue>auto</font> rev = <u>reverse</u>(k);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(rev)) == Tuple!(string,<font color=blue>double</font>,<font color=blue>int</font>)));
<font color=blue>assert</font>(equal(rev, [tuple(<font color=red>"a"</font>,3.14,0), tuple(<font color=red>"b"</font>,2.78,1), tuple(<font color=red>"c"</font>,1.414,2)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">SpliceType!(n,R1,R2) 
<span class="currsymbol">splice</span>
<script>explorer.outline.addDecl('splice');</script>

(size_t n, R1, R2)(R1 <span class="funcparam">range1</span>, R2 <span class="funcparam">range2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a tuple-producing range, range1, and another range, range2 and creates a new tuple-returning range
which inserts the elements of range2 at position n into range1's elements. As for an array, index 0
is before all other elements, etc.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>];
<font color=blue>auto</font> k = knit(r1,s); <font color=green>// k returns Tuple!(int,string)
</font>
<font color=blue>auto</font> r2 = [-2.1, 0.0, 3.14];

<font color=blue>auto</font> spl = <u>splice</u>!1(k,r2); <font color=green>// splices r2 in the middle of k's elements.
</font><font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(spl)) == Tuple!(<font color=blue>int</font>,<font color=blue>double</font>,string)));
<font color=blue>assert</font>(equal(spl, [tuple(0,-2.1,<font color=red>"a"</font>), tuple(1,0.0,<font color=red>"b"</font>), tuple(2, 3.14, <font color=red>"c"</font>)][]));

<font color=blue>auto</font> spl2 = <u>splice</u>!0(spl,k); <font color=green>// splices k before all spl's elements.
</font><font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(spl2)) == Tuple!(Tuple!(<font color=blue>int</font>,string), <font color=blue>int</font>,<font color=blue>double</font>,string))); <font color=green>// non-flattening
</font><font color=blue>assert</font>(equal(spl2, [tuple(tuple(0,<font color=red>"a"</font>), 0,-2.1,<font color=red>"a"</font>), tuple(tuple(1,<font color=red>"b"</font>),1,0.0,<font color=red>"b"</font>), tuple(tuple(2,<font color=red>"c"</font>),2, 3.14, <font color=red>"c"</font>)][]));
</pre>

As std.typecons.Tuple is not auto-flattening, you can 
<span class="currsymbol">splice</span>
<script>explorer.outline.addDecl('splice');</script>

 tuple-producing ranges into one another.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> spl2 = <u>splice</u>!0(spl,k); <font color=green>// splices k before all spl's elements.
</font><font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(spl2)) == Tuple!(Tuple!(<font color=blue>int</font>,<font color=blue>char</font>), <font color=blue>int</font>,<font color=blue>double</font>,<font color=blue>char</font>))); <font color=green>// non-flattening
</font><font color=blue>assert</font>(equal(spl2, [tuple(tuple(0,<font color=red>"a"</font>), 0,-2.1,<font color=red>"a"</font>), tuple(tuple(1,<font color=red>"b"</font>),1,0.0,<font color=red>"b"</font>), tuple(tuple(2,<font color=red>"c"</font>),2, 3.14, <font color=red>"c"</font>)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ShredType!(array,R) 
<span class="currsymbol">shred</span>
<script>explorer.outline.addDecl('shred');</script>

(alias array, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a tuple-producing range and an array of indices ([0,1,2] for example, meaning "first, second and third fields")
and returns a tuple-producing range whose elements" fields are those indicated by array.
The indices can be repeated, omitted, put in any order and the array can be longer than the input tuple ([0,1,2,3,2,1,3,1,0]).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = [3.14, 2.78,1.414];
string s = <font color=red>"abcdef"</font>;

<font color=blue>auto</font> k = knit(r1,r2,s);

<font color=blue>auto</font> shr1 = <u>shred</u>!([1,0])(k); <font color=green>// inverting the order
</font><font color=blue>assert</font>(equal(shr1, [tuple(3.14,0), tuple(2.78,1), tuple(1.414,2)][]));

<font color=blue>auto</font> shr2 = <u>shred</u>!([1])(k); <font color=green>// taking only one field
</font><font color=blue>assert</font>(equal(shr2, [tuple(3.14), tuple(2.78), tuple(1.414)][]));

<font color=blue>auto</font> shr3 = <u>shred</u>!([2,0,1,1])(k); <font color=green>// repating some fields
</font><font color=blue>assert</font>(equal(shr3, [tuple(<font color=red>"a"</font>,0,3.14,3.14), tuple(<font color=red>"b"</font>,1,2.78,2.78), tuple(<font color=red>"c"</font>,2,1.414,1.414)][]));

<font color=blue>auto</font> shr4 = <u>shred</u>!([1,2,0])(shr3); <font color=green>// re-inverting the fields
</font><font color=blue>assert</font>(equal(shr4, k)); <font color=green>// this re-creates k
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ShredType!(n,R) 
<span class="currsymbol">shred</span>
<script>explorer.outline.addDecl('shred');</script>

(size_t n, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another version of 
<span class="currsymbol">shred</span>
<script>explorer.outline.addDecl('shred');</script>

 that takes only one index. It extracts the corresponding field
from a tuple-producing range's elements and returns that as a range, 'un-tuplified'.
That is, where 
<span class="currsymbol">shred</span>
<script>explorer.outline.addDecl('shred');</script>

!([1])(k) will produce a tuple-returning range (one-element tuples,
but tuples nonetheless), 
<span class="currsymbol">shred</span>
<script>explorer.outline.addDecl('shred');</script>

!1(k) will produce a standard range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = [3.14, 2.78,1.414];
<font color=blue>auto</font> s = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>];

<font color=blue>auto</font> k = knit(r1,r2,s);

<font color=blue>auto</font> shr1 = <u>shred</u>!([1,0])(k); <font color=green>// inverting the order
</font><font color=blue>assert</font>(equal(shr1, [tuple(3.14,0), tuple(2.78,1), tuple(1.414,2)][]));

<font color=blue>auto</font> shr2 = <u>shred</u>!([1])(k); <font color=green>// taking only one field
</font><font color=blue>assert</font>(equal(shr2, [tuple(3.14), tuple(2.78), tuple(1.414)][]));

<font color=blue>auto</font> shr3 = <u>shred</u>!([2,0,1,1])(k); <font color=green>// repating some fields
</font><font color=blue>assert</font>(equal(shr3, [tuple(<font color=red>"a"</font>,0,3.14,3.14), tuple(<font color=red>"b"</font>,1,2.78,2.78), tuple(<font color=red>"c"</font>,2,1.414,1.414)][]));

<font color=blue>auto</font> shr4 = <u>shred</u>!([1,2,0])(shr3); <font color=green>// re-inverting the fields
</font><font color=blue>assert</font>(equal(shr4, k)); <font color=green>// this re-creates k
</font>
<font color=blue>auto</font> shr5 = <u>shred</u>!1(k);
<font color=blue>assert</font>(equal(shr5, r2));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!("a",R) 
<span class="currsymbol">untuplify</span>
<script>explorer.outline.addDecl('untuplify');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a tuple-producing range whose elements are 1-element tuples (mainly, this can happen as the result
of some extracting, shredding, filtering, etc.) and "
<span class="currsymbol">untuplify</span>
<script>explorer.outline.addDecl('untuplify');</script>

" it, extracting the tuples values.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];

<font color=blue>auto</font> k = knit(r1);
<font color=blue>assert</font>(equal(k, [tuple(0), tuple(1), tuple(2), tuple(3), tuple(4)]));
<font color=blue>auto</font> u = untuple(k);
<font color=blue>assert</font>(equal(u, r1)); <font color=green>// u is [0,1,2,3,4]
</font></pre>
<br><br>
<b>See Also:</b><br>
shred.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Transverse</span>
<script>explorer.outline.addDecl('Transverse');</script>

(R...) if (allSatisfy!(isForwardRange,R) &amp;&amp; CompatibleRanges!(R));
<br>Transverse!(R) 
<span class="currsymbol">transverse</span>
<script>explorer.outline.addDecl('transverse');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A range that iterates alternatively on the ranges given at creation. It's related
to std.range.Transversal, but will iterated on all "columns" and will stop
as soon as one of them is empty.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> r2 = repeat(5);
<font color=blue>auto</font> r3 = [-2.0, -1.0, 0.0, 1.0];

<font color=blue>auto</font> t = transverse(r1, r2, r3);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(t)) == <font color=blue>double</font>)); <font color=green>// double is the common type for (int, int, double)
</font><font color=blue>assert</font>(equal(t, [0.0,5,-2,1,5,-1,2,5,0,3,5,1,4,5][])); <font color=green>// after 4,5, (the internal copy of) r3 is exhausted.
</font>
<font color=blue>auto</font> t2 = transverse(r1, emptyRange!<font color=blue>double</font>, emptyRange!<font color=blue>short</font>);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(t2)) == <font color=blue>double</font>));
<font color=blue>assert</font>(equal(t2, [0][])); <font color=green>// 0, then stops because it reaches emptyRange!double
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Transverse!(B,Cycle!(S)) 
<span class="currsymbol">interleave</span>
<script>explorer.outline.addDecl('interleave');</script>

(B, S)(B <span class="funcparam">bigRange</span>, S <span class="funcparam">smallRange</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Simple use of transverse.
Alternates between bigRange and smallRange, rolling smallRange into a cycle.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> i1 = <u>interleave</u>(<font color=red>"abcdef"</font>, <font color=red>","</font>);    <font color=green>// -&gt; a,b,c,d,e,f,
</font><font color=blue>auto</font> i2 = <u>interleave</u>(<font color=red>"abcdef"</font>, <font color=red>",;."</font>);  <font color=green>// -&gt; a,b;c.d,e;f.
</font><font color=blue>auto</font> r1 = [0,1,2,3,4];
<font color=blue>auto</font> i3 = <u>interleave</u>(r1,r1);
<font color=blue>assert</font>(equal(i3, [0,0,1,1,2,2,3,3,4,4][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Knit!(TypeNuple!(R,segLength)) 
<span class="currsymbol">segment</span>
<script>explorer.outline.addDecl('segment');</script>

(size_t segLength, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Cuts a range into segments of length segLength. segLength must be stricly positive.
<br><br>
To be compatible with other ranges, it produces tuples, not arrays. It's based on Knit
so if the original range defines back/popBack, length, opIndex or opIndexAssign, it will do so also.
<br><br>

It's used heavily internally by all ranges mapping a function or a predicate on a range.

<br><br>
<b>See Also:</b><br>
delay, parallel.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> s = <u>segment</u>!2(r1);
<font color=blue>assert</font>(equal(s, [tuple(0,1), tuple(1,2), tuple(2,3), tuple(3,4), tuple(4,5)][]));
<font color=blue>assert</font>(s.length == 5);         <font color=green>// .length
</font><font color=green>// back/popBack:
</font><font color=blue>assert</font>(equal(retro(s), retro([tuple(0,1), tuple(1,2), tuple(2,3), tuple(3,4), tuple(4,5)][])));
<font color=blue>assert</font>(s[3] == tuple(3,4));    <font color=green>// opIndex
</font>s[3] = tuple(0,0);             <font color=green>// opIndexAssign
</font><font color=blue>assert</font>(s[2] == tuple(2,0));    <font color=green>// it affects its neighbors.
</font><font color=blue>assert</font>(s[4] == tuple(0,5));
<font color=blue>assert</font>(r1 == [0,1,2,0,0,5][]); <font color=green>// affects r1 back (no .dup internally)
</font>
<font color=blue>auto</font> st = [<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>,<font color=red>"d"</font>,<font color=red>"e"</font>,<font color=red>"f"</font>]; <font color=green>// initial example with a string. Change due to DMD 2.041
</font><font color=blue>auto</font> s2 = <u>segment</u>!3(st);
<font color=blue>assert</font>(s2.front == tuple(<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"c"</font>));

r1 = [0,1,2,3,4,5]; <font color=green>// regenerates r1
</font><font color=blue>auto</font> s3 = <u>segment</u>!1(r1);
<font color=blue>assert</font>(equal(s3, [tuple(0), tuple(1), tuple(2), tuple(3), tuple(4), tuple(5)][]));

<font color=blue>auto</font> r2 = map!<font color=red>"a*a"</font>(r1);
<font color=blue>auto</font> s4 = <u>segment</u>!2(r2); <font color=green>// On a forward range
</font><font color=blue>assert</font>(equal(s4, [tuple(0,1), tuple(1,4), tuple(4,9), tuple(9,16), tuple(16,25)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Knit!(TypeNuple!(R,array.length)) 
<span class="currsymbol">delay</span>
<script>explorer.outline.addDecl('delay');</script>

(alias array, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalization of segment: given an array of indices (as template argument) and a range,
it will produce the corresponding "extracts" (disjointed segments, as tuples).
segment!n(r) is equivalent to 
<span class="currsymbol">delay</span>
<script>explorer.outline.addDecl('delay');</script>

!([0,1,2, ...,n])(r).
<br><br>
But 
<span class="currsymbol">delay</span>
<script>explorer.outline.addDecl('delay');</script>

 is much more powerful than segment.
<pre class="d_code"><u>delay</u>!([2,1,0])(r);  <font color=green>// You can invert the values
</font><u>delay</u>!([4,9,2,0])(r); <font color=green>// take them from everywhere in the range
</font><u>delay</u>!([0,0,1])(r); <font color=green>// repeat some values
</font></pre>

<br><br>
<b>See Also:</b><br>
segment, parallel.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> d = <u>delay</u>!([0,1])(r1); <font color=green>// will iterate on the pair ([0,1,2,3,4,5], [1,2,3,4,5]).
</font>                            <font color=green>// It's equivalent to segment!2(r1)
</font><font color=blue>assert</font>(equal(d, [tuple(0,1), tuple(1,2), tuple(2,3), tuple(3,4), tuple(4,5)][]));
<font color=blue>assert</font>(d.length == 5);         <font color=green>// .length
</font><font color=green>// back/popBack:
</font><font color=blue>assert</font>(equal(retro(d), retro([tuple(0,1), tuple(1,2), tuple(2,3), tuple(3,4), tuple(4,5)][])));

<font color=blue>auto</font> d2 = <u>delay</u>!([1,0])(r1); <font color=green>// inverting
</font><font color=blue>assert</font>(equal(d2, [tuple(1,0), tuple(2,1), tuple(3,2), tuple(4,3), tuple(5,4)][]));

<font color=blue>auto</font> d3 = <u>delay</u>!([0])(r1);   <font color=green>// one element
</font><font color=blue>assert</font>(equal(d3, [tuple(0), tuple(1), tuple(2), tuple(3), tuple(4), tuple(5)][]));

<font color=blue>auto</font> d4 = <u>delay</u>!([4,1,3,2])(r1); <font color=green>// disjoint extracts
</font><font color=blue>assert</font>(d4.front == tuple(4,1,3,2));
<font color=blue>assert</font>(d4.length == 2); <font color=green>// d4 is [(4,1,3,2),(5,2,4,3)]
</font>
<font color=blue>auto</font> d5 = <u>delay</u>!([0,0,1])(r1); <font color=green>// repeated values
</font><font color=blue>assert</font>(d5.front == tuple(0,0,1));

<font color=blue>auto</font> d6 = <u>delay</u>!([9,0])(r1);
<font color=blue>assert</font>(d6.empty);

<font color=blue>int</font>[] e;
<font color=blue>assert</font>(<u>delay</u>!([0,1])(e).empty);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Knit!(TypeNuple!(R,n)) 
<span class="currsymbol">parallel</span>
<script>explorer.outline.addDecl('parallel');</script>

(size_t n, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another "delay" cousin: takes a number (as template argument) and a range, and produces
a "knit" of n times the same range in 
<span class="currsymbol">parallel</span>
<script>explorer.outline.addDecl('parallel');</script>

.
<br><br>
<b>See Also:</b><br>
segment, delay.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5];
<font color=blue>auto</font> p = <u>parallel</u>!4(r1);
<font color=blue>assert</font>(equal(p, [tuple(0,0,0,0), tuple(1,1,1,1), tuple(2,2,2,2), tuple(3,3,3,3), tuple(4,4,4,4), tuple(5,5,5,5)][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Concat</span>
<script>explorer.outline.addDecl('Concat');</script>

(R) if (isRangeOfRanges!(R));
<br>Concat!(R) 
<span class="currsymbol">concat</span>
<script>explorer.outline.addDecl('concat');</script>

(R)(R <span class="funcparam">range</span>);
<br>R 
<span class="currsymbol">concat</span>
<script>explorer.outline.addDecl('concat');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A simple wrapper to concatenate elements of a range of ranges.
It's equivalent to flatten!1(range), but it's only a forward range.
<br><br>
On a simple range, it has no effect (it's the identity function).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[][] r1 = [[0,1,2], [3,4], [5]];
<font color=blue>auto</font> c = concat(r1);
<font color=blue>assert</font>(equal(c, [0,1,2,3,4,5][]));  <font color=green>// from an int[][] to an int[]
</font><font color=blue>assert</font>(equal(retro(c), retro([0,1,2,3,4,5][]))); <font color=green>// bidir range
</font>
<font color=blue>auto</font> r2 = [0,1,2,3];
<font color=blue>auto</font> ror = map!<font color=red>"take(a+1, repeat(a))"</font>(r2); <font color=green>// Equivalent to [[0], [1,1], [2,2,2], [3,3,3,3]]
</font><font color=blue>assert</font>(equal(concat(ror), [0,1,1,2,2,2,3,3,3,3][]));

string sentence = <font color=red>"the quick brown fox jumped over the lazy dog."</font>;
<font color=blue>auto</font> words = split(sentence); <font color=green>// a string[], so also a immutable(char)[][]
</font><font color=blue>auto</font> sentence2 = concat(words);
<font color=blue>assert</font>(array(sentence2) == <font color=red>"thequickbrownfoxjumpedoverthelazydog."</font>);

<font color=blue>assert</font>(equal(concat(c), c));        <font color=green>// c is a simple range, concat(c) has no effect.
</font></pre>
<br><br>
<b>BUG:</b><br>
doesn"t play so nice with retro. retro.popBack calls concat.popFront, but it seems to have no effect.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">FlattenType!(n,R) 
<span class="currsymbol">flatten</span>
<script>explorer.outline.addDecl('flatten');</script>

(size_t n = size_t.max, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Flatten a range of ranges (of ranges, etc.) n levels deep. n==0 does nothing. n == 1 is just concat(range),
n == 2 is concat(concat(range)), etc. The default is to go for the maximum flattening.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[][] r1 = [[0,1,2], [3,4], [5]];
<font color=blue>auto</font> f = <u>flatten</u>(r1);
<font color=blue>assert</font>(equal(f, [0,1,2,3,4,5][]));

<font color=blue>int</font>[][][] r2 = [r1, [[6]], r1];
<font color=blue>auto</font> f2 = <u>flatten</u>!2(r2);
<font color=blue>assert</font>(equal(f2, [0,1,2,3,4,5,6,0,1,2,3,4,5][]));
<font color=blue>assert</font>(equal(retro(f2), [5,4,3,2,1,0,6,5,4,3,2,1,0][])); <font color=green>// bidir range
</font>
<font color=blue>auto</font> f3 = <u>flatten</u>!0(r2); <font color=green>// No flattening -&gt; range unchanged.
</font><font color=blue>assert</font>(equal(f3, r2));

<font color=blue>auto</font> f4 = <u>flatten</u>(r2); <font color=green>// go for max flattening. Equals to flatten!2(r2)
</font><font color=blue>assert</font>(equal(f2, f4));

<font color=blue>auto</font> f5 = <u>flatten</u>!1(r2); <font color=green>// flatten one level
</font><font color=blue>assert</font>(equal(f5, [[0,1,2], [3,4], [5], [6], [0,1,2], [3,4], [5]][]));
<font color=blue>assert</font>(equal(retro(f5), [[5], [3,4], [0,1,2], [6], [5], [3,4], [0,1,2]][]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">truncate</span>
<script>explorer.outline.addDecl('truncate');</script>

(R...)(ref R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Small helper function: given a variadic list of ranges, truncates them to the shortest range's length.
This will modify the input ranges!
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3];
string s = <font color=red>"abcdefghijk"</font>;
<u>truncate</u>(r1, s);
<font color=blue>assert</font>(r1.length == s.length);
<font color=blue>assert</font>(equal(r1, [0,1,2,3][]));
<font color=blue>assert</font>(s == <font color=red>"abcd"</font>);
</pre>
<br><br>
<b>BUG:</b><br>
Does not work since DMD 2.04x, when strings were modified. Maybe by using byCodePoint or somesuch?<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Knit!(Numbers,R) 
<span class="currsymbol">indexed</span>
<script>explorer.outline.addDecl('indexed');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Emulates the standard Clojure/Python/Ruby function: given a range r,
it will produce an 
<span class="currsymbol">indexed</span>
<script>explorer.outline.addDecl('indexed');</script>

 range, with elements tuples(index, element).
<br><br>
If possible, 
<span class="currsymbol">indexed</span>
<script>explorer.outline.addDecl('indexed');</script>

 defines back, popBack, length, opIndex and opSlice.
<pre class="d_code"><font color=blue>auto</font> s = [<font color=red>"a"</font>, <font color=red>"b"</font>, <font color=red>"c"</font>, <font color=red>"d"</font>, <font color=red>"e"</font>, <font color=red>"f"</font>];
<font color=blue>auto</font> e = <u>indexed</u>(s); <font color=green>// (0,"a"), (1,"b"), (2,"c"), (3,"d"), (4, "e"), (5, "f")
</font><font color=blue>assert</font>(e.front == tuple(0, <font color=red>"a"</font>));
<font color=blue>assert</font>(e.length == s.length);
e.popFront;
<font color=blue>assert</font>(e.front == tuple(1, <font color=red>"b"</font>));
<font color=blue>assert</font>(e[3]    == tuple(4, <font color=red>"e"</font>)); <font color=green>// opIndex
</font><font color=blue>assert</font>(e.back  == tuple(5, <font color=red>"f"</font>)); <font color=green>// back
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Numbers</span>
<script>explorer.outline.addDecl('Numbers');</script>

;
<br>Numbers 
<span class="currsymbol">numbers</span>
<script>explorer.outline.addDecl('numbers');</script>

(int <span class="funcparam">to</span> = (int).max);
<br>Numbers 
<span class="currsymbol">numbers</span>
<script>explorer.outline.addDecl('numbers');</script>

(int <span class="funcparam">from</span>, int <span class="funcparam">to</span>, int <span class="funcparam">step</span> = 1);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A small range to get the numbers from from to to (open at to, it's never reached) with step step.
0-, 1-, 2- and 3-args version exist, see the examples.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> n0 = numbers();            <font color=green>// -&gt; 0,1,2,3,4, ... ,int.max
</font><font color=blue>auto</font> n1 = numbers(10);          <font color=green>// -&gt; 0,1,2,3,4,5,6,7,8,9
</font><font color=blue>auto</font> n2 = numbers(5,10);        <font color=green>// -&gt; 5,6,7,8,9
</font><font color=blue>auto</font> n3 = numbers(1,10,3);      <font color=green>// -&gt; 1,4,7
</font><font color=blue>auto</font> n4 = numbers(1,10,100);    <font color=green>// -&gt; 1
</font><font color=blue>auto</font> n5 = numbers(20,10, -1);   <font color=green>// -&gt; 20,19,18,17,16,15,14,13,12,11
</font><font color=blue>auto</font> n6 = numbers(20,10);       <font color=green>// step defaults to 1 -&gt; empty range
</font><font color=blue>assert</font>(n1[3] == 3);             <font color=green>// opIndex
</font><font color=blue>assert</font>(equal(n1[5..10], n2));   <font color=green>// opSlice
</font><font color=blue>assert</font>(equal(retro(n1), [9,8,7,6,5,4,3,2,1,0][])); <font color=green>// It's a bidirectional range
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Numberz</span>
<script>explorer.outline.addDecl('Numberz');</script>

(T);
<br>Numberz!(T) 
<span class="currsymbol">numberz</span>
<script>explorer.outline.addDecl('numberz');</script>

(T)(T <span class="funcparam">to</span>);
<br>Numberz!(T) 
<span class="currsymbol">numberz</span>
<script>explorer.outline.addDecl('numberz');</script>

(T)(T <span class="funcparam">from</span>, T <span class="funcparam">to</span>, T <span class="funcparam">step</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A templated struct for a range of numbers. It can be used with std.bigint, for example.
There is no argument-less version: numberz!BigInt() does not exists (as there is no BigInt.max).
<pre class="d_code"><font color=blue>auto</font> n1 = numberz(BigInt(<font color=red>"1000000000000000"</font>), BigInt(<font color=red>"2000000000000000"</font>));
    <font color=green>// -&gt; 1000000000000000, 1000000000000001, 1000000000000002, 1000000000000003, ..., 1000000000000010
</font><font color=blue>assert</font>(n1[3] == BigInt(<font color=red>"1000000000000003"</font>)); <font color=green>// opIndex with standard index
</font><font color=blue>assert</font>(n1[BigInt(<font color=red>"500000000000000"</font>)] == BigInt(<font color=red>"1500000000000000"</font>)); <font color=green>// Indexed with BigInt too
</font><font color=blue>assert</font>(n1.length == BigInt(<font color=red>"1000000000000000"</font>)); <font color=green>// .length returns a BigInt
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">NaturalNumbers</span>
<script>explorer.outline.addDecl('NaturalNumbers');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Simple range producing all natural numbers, alternating
between positive and negative numbers: 0, 1, -1, 2, -2, 3, -3, ...<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">EmptyRange</span>
<script>explorer.outline.addDecl('EmptyRange');</script>

(T);
<br>EmptyRange!(T) 
<span class="currsymbol">emptyRange</span>
<script>explorer.outline.addDecl('emptyRange');</script>

(T)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An empty range. Its element type is parameterized by T, to enable compatibility
(for ranges which check front's type).
<br><br>
<pre class="d_code"><font color=blue>auto</font> e = emptyRange!<font color=blue>int</font>; <font color=green>//uses the helper function. Otherwise: auto e = EmptyRange!int();
</font><font color=blue>assert</font>(e.empty);
<font color=blue>assert</font>(e.length == 0);
<font color=blue>assert</font>(asString(e) == <font color=red>""</font>);
<font color=blue>assert</font>(<font color=blue>is</font>(ElementType!(<font color=blue>typeof</font>(e)) == <font color=blue>int</font>));
<font color=blue>assert</font>(isInputRange!(<font color=blue>typeof</font>(e)));
<font color=blue>assert</font>(isForwardRange!(<font color=blue>typeof</font>(e)));
<font color=blue>assert</font>(isBidirectionalRange!(<font color=blue>typeof</font>(e)));
<font color=blue>assert</font>(isRandomAccessRange!(<font color=blue>typeof</font>(e)));
<font color=blue>assert</font>(hasLength!(<font color=blue>typeof</font>(e)));
<font color=blue>assert</font>(hasSlicing!(<font color=blue>typeof</font>(e)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Once</span>
<script>explorer.outline.addDecl('Once');</script>

(T);
<br>Once!(T) 
<span class="currsymbol">once</span>
<script>explorer.outline.addDecl('once');</script>

(T)(T <span class="funcparam">value</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A one-element range. This element is defined at creation and will be produced once. The range is then empty.
<pre class="d_code"><font color=blue>auto</font> e = once(1.1);
<font color=blue>assert</font>(e.front == 1.1);
<font color=blue>assert</font>(e.length == 1);
<font color=blue>assert</font>(asString(e) == <font color=red>"1.1"</font>);
e.popFront;
<font color=blue>assert</font>(e.empty);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Pi</span>
<script>explorer.outline.addDecl('Pi');</script>

;
<br>Pi 
<span class="currsymbol">piDigits</span>
<script>explorer.outline.addDecl('piDigits');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An infinite range giving the digits of pi, in base 10 (as ints).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> pi = take(piDigits, 10);
<font color=blue>assert</font>(equal(pi, [3,1,4,1,5,9,2,6,5,3]));
</pre>
It has a reasonable speed up to a few thousands digits, but slows down sharply afterwards.
On my machine: 1000 digits: 100 ms, 3000 digits: 300 ms, 10000 digits: 2.4 s, 30000 digits: 22 s<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">InfiniteBiDir</span>
<script>explorer.outline.addDecl('InfiniteBiDir');</script>

(R1,R2) if (isForwardRange!(R1) &amp;&amp; isForwardRange!(R1) &amp;&amp; isInfinite!(R1) &amp;&amp; isInfinite!(R2) &amp;&amp; !isBidirectionalRange!(R1) &amp;&amp; !isBidirectionalRange!(R2) &amp;&amp; CompatibleRanges!(R1,R2));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>It's an infinite bidirectional range: a range that has infinitely many values,
but knows its end:
<br><br>
n0 n1 n2 ... (infinitely many values)  ... m2 m1 m0
<br><br>

It's in fact a completly standard infinite bidirectional range, modelized with two (non-bidir) infinite ranges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ReplicateRange</span>
<script>explorer.outline.addDecl('ReplicateRange');</script>

(R) if (isForwardRange!(R));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Replicates a range n times. back, popBack, length and opIndex will be defined
if the subjacent R permits it.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3];
<font color=blue>auto</font> r2 = replicateRange(r1, 3);
<font color=blue>assert</font>(equal(r2, [0,1,2,3,0,1,2,3,0,1,2,3][]));
<font color=blue>assert</font>(r2.length == r1.length * 3);
<font color=blue>assert</font>(r2[3] == 3);

r2.popFront;
r2.popBack;
<font color=blue>assert</font>(equal(r2, [1,2,3,0,1,2,3,0,1,2][])); <font color=green>// You can truncate it at both ends
</font><font color=blue>assert</font>(r2.length == r1.length * 3 - 2); <font color=green>// length update
</font><font color=blue>assert</font>(r2[3] == 0); <font color=green>// Indexing is always 0-based, of course.
</font>
<font color=blue>assert</font>(replicateRange(r1, 0).empty); <font color=green>// if n == 0, replicateRange is an empty range
</font><font color=blue>assert</font>(equal(replicateRange(r1, 1), r1));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Stutter</span>
<script>explorer.outline.addDecl('Stutter');</script>

(R) if (isForwardRange!(R));
<br>Stutter!(R) 
<span class="currsymbol">stutter</span>
<script>explorer.outline.addDecl('stutter');</script>

(R)(uint <span class="funcparam">n</span>, R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Repeat n times each element of a range. If the input is a bidirectional range,
stutter will also be one (defines back and popBack), the same for a random-access range.
Also, if input has a length, stutter will have one.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3];
string s = <font color=red>"abc"</font>;
<font color=blue>auto</font> st1 = stutter(r1, 3);
<font color=blue>auto</font> st2 = stutter(s, 2);
<font color=blue>assert</font>(st1.length == r1.length * 3);
<font color=blue>assert</font>(equal(st1, [0,0,0,1,1,1,2,2,2,3,3,3][]));
<font color=blue>assert</font>(equal(st2, <font color=red>"aabbcc"</font>)); <font color=green>// Works on strings, too.
</font><font color=green>//
</font>st1.popFront;
st1.popBack;
<font color=blue>assert</font>(equal(st1, [0,0,1,1,1,2,2,2,3,3][]));
<font color=blue>assert</font>(st1.length == r1.length * 3 - 2);            <font color=green>// length update
</font><font color=blue>assert</font>(equal(retro(st1), [3,3,2,2,2,1,1,1,0,0][])); <font color=green>// Bidirectional range
</font><font color=blue>assert</font>(st1[2] == 1);                                <font color=green>// Random-access range
</font><font color=green>//
</font><font color=blue>assert</font>(stutter(r1, 0).empty);                       <font color=green>// stutter(_,0) -&gt; empty
</font><font color=blue>auto</font> e = emptyRange!<font color=blue>int</font>;
<font color=blue>assert</font>(stutter(e, 3).empty);                        <font color=green>// stutter(empty, n) -&gt; empty
</font><font color=blue>assert</font>(equal(stutter(r1,1), r1));                   <font color=green>// stutter(r,1) -&gt; r
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Concat!(Map!(unaryFun!(Format!("array(replicate(%s,a))",n)),R)) 
<span class="currsymbol">stutter2</span>
<script>explorer.outline.addDecl('stutter2');</script>

(size_t n, R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Another version, based on flatMap.
<pre class="d_code">flatMap!(Format!(<font color=red>"array(replicate(%s,a))"</font>, n))(r);
</pre>
It's a one-liner, but it's a forward range, no more (no opIndex, back, etc)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Extremities</span>
<script>explorer.outline.addDecl('Extremities');</script>

(R) if (isBidirectionalRange!(R));
<br>Extremities!(R) 
<span class="currsymbol">extremities</span>
<script>explorer.outline.addDecl('extremities');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A forward range which alternates between input's two extremities. It's a kind of dual to std.range.radial.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5,6];
<font color=blue>auto</font> ext = extremities(r1);
<font color=blue>assert</font>(ext.length == r1.length); <font color=green>// length is defined
</font><font color=blue>assert</font>(equal(ext, [0,6,1,5,2,4,3][]));
<font color=blue>assert</font>(extremities(emptyRange!<font color=blue>int</font>).empty); <font color=green>// extremities on an empty range -&gt; empty
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Cycle!(Chain!(R,Retro!(R))) 
<span class="currsymbol">bounce</span>
<script>explorer.outline.addDecl('bounce');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterate on a bidirectional range by going back and forth between its extremities.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r = [0,1,2,3];
<font color=blue>auto</font> b = <u>bounce</u>(r);
<font color=blue>assert</font>(equal(take(b, 10), [0,1,2,3,2,1,0,1,2,3][]));

<font color=blue>auto</font> r2 = [1];
<font color=blue>assert</font>(equal(take(<u>bounce</u>(r2), 10), replicate(10, 1))); <font color=green>// 1,1,1,1,...
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Without</span>
<script>explorer.outline.addDecl('Without');</script>

(R1,R2);
<br>Without!(R1,R2) 
<span class="currsymbol">without</span>
<script>explorer.outline.addDecl('without');</script>

(R1, R2)(R1 <span class="funcparam">range1</span>, R2 <span class="funcparam">range2</span>, bool <span class="funcparam">cyclic</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Produces a range with elements of r1 without those of r2. Equivalent to Haskell (\\).
By default, each element of r2 is used only once. With the boolean option cyclic set to <b>true</b>,
you get without(r1, cycle(r2)) and all occurences of an element of r2 in r1 are dropped.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4,5,6,2,3,4];

without(r1, [2,3,4][]);         <font color=green>// [0,1,5,6,2,3,4][] getting rid of 2,3,4. Those at the end are still there
</font>without(r1, [2,3,4,2,3][]);     <font color=green>// [0,1,5,6,4][] 2,3 at the end are eliminated
</font>without(r1, [2,3,4][], <font color=blue>true</font>);   <font color=green>// [0,1,5,6][] eliminate all 2, 3 and 4 from r1.
</font>without(<font color=red>"banana"</font>, <font color=red>"a"</font>, <font color=blue>true</font>);   <font color=green>// "bnn"
</font>without(r1, numbers(), <font color=blue>true</font>);   <font color=green>// (int[]).init (empty range) all are numbers eliminated from r1
</font>
r1.without([2,3,4][]);          <font color=green>// For arrays, you can also use an infix syntax
</font><font color=red>"banana"</font>.without(<font color=red>"a"</font>, <font color=blue>true</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">AsSet</span>
<script>explorer.outline.addDecl('AsSet');</script>

(R) if (isForwardRange!(R));
<br>struct 
<span class="currsymbol">AsSet</span>
<script>explorer.outline.addDecl('AsSet');</script>

(R : Cycle!(U),U);
<br>struct 
<span class="currsymbol">AsSet</span>
<script>explorer.outline.addDecl('AsSet');</script>

(R : Repeat!(U),U);
<br>AsSet!(R) 
<span class="currsymbol">asSet</span>
<script>explorer.outline.addDecl('asSet');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Helper struct to transform a range into a set. Each value is memoized when first output
and then filtered. 
<span class="currsymbol">AsSet</span>
<script>explorer.outline.addDecl('AsSet');</script>

 has no way to know if all values have been created, so on an infinite range
it may never stop, looking for a nth new value which will never come. 
<span class="currsymbol">AsSet</span>
<script>explorer.outline.addDecl('AsSet');</script>

 does know
about std.range periodic ranges (Cycle and Repeat) and extract the internal value.
<br><br>
<b>Example:</b><br>
<pre class="d_code">asSet([0,1,2,2,3,3,4,5,5,6,9,1,2,4,9][]); <font color=green>// 0,1,2,3,4,5,6,9, OK.
</font>asSet(cycle([4,5,6][])); <font color=green>// 4,5,6
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Cache</span>
<script>explorer.outline.addDecl('Cache');</script>

(R) if (isForwardRange!(R));
<br>Cache!(R) 
<span class="currsymbol">cache</span>
<script>explorer.outline.addDecl('cache');</script>

(R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Simple wrapper range to cache the front and back elements of another range.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">forEach</span>
<script>explorer.outline.addDecl('forEach');</script>

(alias fun, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To iterate on range using a function with side-effects. It doesn"t use the return values,
so it acts only through fun's side-effects. Mainly used to print a range.
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3,4];
<u>forEach</u>!(write)(r1); <font color=green>// writes "01234"
</font><font color=blue>int</font> sum;
<u>forEach</u>!((<font color=blue>int</font> a){sum += a;})(r1);
<font color=blue>assert</font>(sum == reduce!<font color=red>"a+b"</font>(r1)); <font color=green>// sum contains 0+1+2+3+4
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">string 
<span class="currsymbol">asString</span>
<script>explorer.outline.addDecl('asString');</script>

(R)(R <span class="funcparam">range</span>, string <span class="funcparam">sep</span> = "");
<br>string 
<span class="currsymbol">asString</span>
<script>explorer.outline.addDecl('asString');</script>

(R)(R <span class="funcparam">range</span>, string <span class="funcparam">pre</span>, string <span class="funcparam">sep</span>, string <span class="funcparam">post</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Greedily iterates on range and returns a string with all range elements
separated by sep. An overload exists, with three string parameters controlling
the beginning of the string, the separator and the end.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = [0,1,2,3];
string r2 = <font color=red>"abcdef"</font>;
<font color=blue>assert</font>(<u>asString</u>(r1) == <font color=red>"0123"</font>);
<font color=blue>assert</font>(<u>asString</u>(r2) == r2);
<font color=blue>assert</font>(<u>asString</u>(r2, <font color=red>","</font>) == <font color=red>"a,b,c,d,e,f"</font>);
<font color=blue>assert</font>(<u>asString</u>(r2, <font color=red>"["</font>, <font color=red>"-"</font>, <font color=red>"]"</font>) == <font color=red>"[a-b-c-d-e-f]"</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">wr</span>
<script>explorer.outline.addDecl('wr');</script>

(R)(R <span class="funcparam">range</span>, string <span class="funcparam">sep</span> = " ");
<br>void 
<span class="currsymbol">wr</span>
<script>explorer.outline.addDecl('wr');</script>

(R)(R <span class="funcparam">range</span>, string <span class="funcparam">pre</span>, string <span class="funcparam">sep</span>, string <span class="funcparam">post</span>);
<br>void 
<span class="currsymbol">wr</span>
<script>explorer.outline.addDecl('wr');</script>

(R)(R <span class="funcparam">range</span>, string <span class="funcparam">sep</span> = " ");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Small utility function to print a range. Mainly used for debugging/testing purposes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Chainable</span>
<script>explorer.outline.addDecl('Chainable');</script>

()</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A template to mixin to get some catenation operations defined on a range, based
on std.range.chain. If r1 is a range with mixin(
<span class="currsymbol">Chainable</span>
<script>explorer.outline.addDecl('Chainable');</script>

!()), r2 a range with
the same element type, and e an element, you can do:
<pre class="d_code">r1 ~ r2; <font color=green>// Concatenation on the right.
</font>e[] ~ r1;<font color=green>// Concatenation on the left with an array of elements.
</font>r1 ~ e;  <font color=green>// concatenation on the right with a new element.
</font>e ~ r1;  <font color=green>// concatenation on the left with a new element.
</font></pre>
What you don"t get is:
<pre class="d_code">r2 ~ r1; <font color=green>// No, r2 must define opCat. A templated opCat_r does not work if r1 and r2 both define it and opCat.
</font></pre>
<br><br>
<b>Note:</b><br>
it detects Chain!R and reacts accordingly. That is, it does not build Chain!(R, Chain!(U)), but Chain!(R,U).
<br><br>
<b>Note:</b><br>
to be really interesting, it needs some modifications of std.range.Chain, to give it opCat capabilities.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">append</span>
<script>explorer.outline.addDecl('append');</script>

(T, E)(T[] <span class="funcparam">array</span>, E <span class="funcparam">elem</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">prepend</span>
<script>explorer.outline.addDecl('prepend');</script>

(T, E)(T[] <span class="funcparam">array</span>, E <span class="funcparam">elem</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Store</span>
<script>explorer.outline.addDecl('Store');</script>

(R) if (isInputRange!(R));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A sort-of extension of standard ranges that remembers the previous values output through
front and back and can deliver them anew. The front can go back with retreat and the back
can "go forward" with advance. Use asNew/backAsNew to see if you can still retreat/advance.
<br><br>
<b>BUG:</b><br>
doesn"t quite work. I"m getting fed up with this: too many internal states to consider. I should
tackle this anew.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:56:12 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


