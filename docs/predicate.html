
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.predicate</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.predicate");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.predicate</h1><!-- Generated by Ddoc from dranges\predicate.d -->
This module contains some usual predicates, either on entire ranges or on their elements.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">some</span>
<script>explorer.outline.addDecl('some');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if 
<span class="currsymbol">some</span>
<script>explorer.outline.addDecl('some');</script>

 (at least one) element in range verify the predicate pred. False otherwise.
Typically, it's used with a unary (1-arg) predicate, but it accepts predicates of any arity.
If the predicate is a n-args function (n&gt;1), it will be presented with n-elements 'segments'
of the range, with a step of one: interleaved segments.
<br><br>
<b>See Also:</b><br>
dranges.range.segment.
<br><br>
<b>TODO:</b><br>
add an optional step argument?
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[] r1 = [0,1,2,3];
<font color=blue>int</font>[] r2 = [];
<font color=blue>assert</font>(<u>some</u>!<font color=red>"a&gt;0"</font>(r1));
<font color=blue>assert</font>(!<u>some</u>!<font color=red>"a&gt;3"</font>(r1));
<font color=blue>assert</font>(!<u>some</u>!<font color=red>"a&gt;0"</font>(r2)); <font color=green>// empty range: no element can verify the predicate
</font>
<font color=blue>assert</font>(<u>some</u>!<font color=red>"a&lt;b"</font>(r1));  <font color=green>// Increasing range
</font><font color=blue>assert</font>(!<u>some</u>!<font color=red>"b&lt;a"</font>(r1));
<font color=blue>assert</font>(!<u>some</u>!<font color=red>"a&lt;f"</font>(r1)); <font color=green>// 6-args function -&gt; no match -&gt; some is false
</font>
<font color=blue>assert</font>(<u>some</u>!<font color=red>"true"</font>(r1)); <font color=green>// degenerate case: nullary predicate.
</font><font color=blue>assert</font>(!<u>some</u>!<font color=red>"false"</font>(r1));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">all</span>
<script>explorer.outline.addDecl('all');</script>

(alias pred, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> if 
<span class="currsymbol">all</span>
<script>explorer.outline.addDecl('all');</script>

 elements in range verify the predicate pred. False otherwise. Typically,
it's used with a unary (1-arg) predicate, but it accepts predicates of any arity. If
the predicate is a n-args function (n&gt;1), it will be presented with n-elements 'segments'
of the range, with a step of one: interleaved segments.
<br><br>
<b>See Also:</b><br>
<b><code>dranges.range.segment</code></b>.
<br><br>
<b>TODO:</b><br>
add an optional step argument?
<pre class="d_code"><font color=blue>int</font>[] r1 = [0,1,2,3];
<font color=blue>int</font>[] r2 = [];
<font color=blue>assert</font>(<u>all</u>!<font color=red>"a&gt;=0"</font>(r1));
<font color=blue>assert</font>(!<u>all</u>!<font color=red>"a&gt;0"</font>(r1));
<font color=blue>assert</font>(<u>all</u>!<font color=red>"a&gt;0"</font>(r2)); <font color=green>// empty range: any property is verified by the (inexistent) elements
</font>
<font color=blue>assert</font>(<u>all</u>!<font color=red>"a&lt;b"</font>(r1));  <font color=green>// Binary function. Tests for an increasing range
</font><font color=blue>assert</font>(!<u>all</u>!<font color=red>"b&lt;a"</font>(r1));
<font color=blue>assert</font>(<u>all</u>!<font color=red>"a&lt;f"</font>(r1)); <font color=green>// 6-args function -&gt; no match -&gt; empty segment range -&gt; all is true
</font>
<font color=blue>assert</font>(<u>all</u>!<font color=red>"true"</font>(r1)); <font color=green>// degenerate case: nullary predicate.
</font><font color=blue>assert</font>(!<u>all</u>!<font color=red>"false"</font>(r1));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isStrictlyIncreasing</span>
<script>explorer.outline.addDecl('isStrictlyIncreasing');</script>

(R)(R <span class="funcparam">range</span>);
<br>bool 
<span class="currsymbol">isIncreasing</span>
<script>explorer.outline.addDecl('isIncreasing');</script>

(R)(R <span class="funcparam">range</span>);
<br>bool 
<span class="currsymbol">isStrictlyDecreasing</span>
<script>explorer.outline.addDecl('isStrictlyDecreasing');</script>

(R)(R <span class="funcparam">range</span>);
<br>bool 
<span class="currsymbol">isDecreasing</span>
<script>explorer.outline.addDecl('isDecreasing');</script>

(R)(R <span class="funcparam">range</span>);
<br>bool 
<span class="currsymbol">isConstant</span>
<script>explorer.outline.addDecl('isConstant');</script>

(R)(R <span class="funcparam">range</span>);
<br>bool 
<span class="currsymbol">hasNoPair</span>
<script>explorer.outline.addDecl('hasNoPair');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A bunch of small one-liners, using all. Their names may be subject to change, as
I don't like them much.
The tests are (respectively): "a<b", "a<=b", "a>b","a&gt;=b", "a==b" and "a!=b".<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">allDifferent</span>
<script>explorer.outline.addDecl('allDifferent');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Return:</b><br>
<b>true</b> iff all the range elements are different (as tested with inclusion in an associative array).
<br><br>
<b>TODO:</b><br>
Maybe another version with an aliased predicate? I don't know how to use an AA in this case, so that would
be much slower. But that would allow using approxEqual on floating point elements.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">someEmpty</span>
<script>explorer.outline.addDecl('someEmpty');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> iff some ranges in the variadic list ranges are empty. False otherwise.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">allEmpty</span>
<script>explorer.outline.addDecl('allEmpty');</script>

(R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>If <b>true</b> iff all ranges are empty.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">allVerify</span>
<script>explorer.outline.addDecl('allVerify');</script>

(alias pred, R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a variadic list of ranges, returns <b>true</b> iff all ranges in ranges verify
pred. The difference with std.traits.allSatisfy is that the latter act on types,
whereas 
<span class="currsymbol">allVerify</span>
<script>explorer.outline.addDecl('allVerify');</script>

 act on instances (values, whatever). The difference with 'all'
is that 'all' acts on one range, and tests the predicate on the range's elements.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[] r1 = [0,1,2];
string r2 = <font color=red>"abc"</font>;
<font color=blue>assert</font>(<u>allVerify</u>!<font color=red>"a.length &gt; 2"</font>(r1,r2));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">someVerify</span>
<script>explorer.outline.addDecl('someVerify');</script>

(alias pred, R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a variadic list of ranges, returns <b>true</b> iff some (at least one) ranges
in ranges verify the predicate pred.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[] r1 = [0,1,2];
string r2 = <font color=red>"abcde"</font>;
<font color=blue>assert</font>(<u>someVerify</u>!<font color=red>"a.length &gt; 4"</font>(r2));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isOneOf</span>
<script>explorer.outline.addDecl('isOneOf');</script>

(alias range)(Unqual!(ElementType!(typeof(range))) <span class="funcparam">element</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns <b>true</b> iff element is one of the elements of range.
Used as a predicate to find a subrange inside another range: <b><code>dropWhile!(
<span class="currsymbol">isOneOf</span>
<script>explorer.outline.addDecl('isOneOf');</script>

!"abc")(r1)</code></b>
It may never terminate if range is infinite,
but as an optimization, <b><code>
<span class="currsymbol">isOneOf</span>
<script>explorer.outline.addDecl('isOneOf');</script>

</code></b> detects <b><font color=blue>Cycle!U</font></b> and works only on the cycle internal range.
<br><br>
<b>See Also:</b><br>
<b><code>dranges.algorithm.contains</code></b>. Maybe I could define one with another...
<br><br>
<b>Example:</b><br>
<pre class="d_code">string s = <font color=red>"01212345"</font>;
<font color=blue>auto</font> m = map!(<u>isOneOf</u>!<font color=red>"012"</font>)(s);
<font color=blue>assert</font>(equal(m, [<font color=blue>true</font>,<font color=blue>true</font>,<font color=blue>true</font>,<font color=blue>true</font>,<font color=blue>true</font>,<font color=blue>false</font>,<font color=blue>false</font>,<font color=blue>false</font>][]));

<font color=blue>auto</font> c = cycle(<font color=red>"012"</font>);
<font color=blue>auto</font> m2 = map!(<u>isOneOf</u>!c)(s); <font color=green>// doesn't hang, as it's equivalent to isOneOf!"012"
</font><font color=blue>assert</font>(equal(m2, m));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">allEqual</span>
<script>explorer.outline.addDecl('allEqual');</script>

(T...)(T <span class="funcparam">vals</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns <b>true</b> iff if all values in the variadic list vals are equal.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>allEqual</u>(1,1.0,1.0000,1)); <font color=green>// The values are automatically converted
</font><font color=blue>assert</font>(<u>allEqual</u>(1)); <font color=green>// one element, always true.
</font><font color=blue>assert</font>(<u>allEqual</u>()); <font color=green>// no element, always true.
</font><font color=blue>assert</font>(!<u>allEqual</u>(1,2));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">equals</span>
<script>explorer.outline.addDecl('equals');</script>

(alias value, T)(T <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns <b>true</b> if t 
<span class="currsymbol">equals</span>
<script>explorer.outline.addDecl('equals');</script>

 value. If value and t don't have compatible types, it returns <b>false</b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[] r = [0,1,0,1,2,0,3];
<font color=blue>assert</font>(<u>equals</u>!0(r.front));

<font color=blue>auto</font> m = map!(<u>equals</u>!(0,<font color=blue>int</font>))(r);
<font color=blue>assert</font>(equal(m, [<font color=blue>true</font>,<font color=blue>false</font>,<font color=blue>true</font>,<font color=blue>false</font>,<font color=blue>false</font>,<font color=blue>true</font>,<font color=blue>false</font>][]));

<font color=blue>assert</font>(!<u>equals</u>!<font color=red>"a"</font>(r.front));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool delegate(T) 
<span class="currsymbol">equals</span>
<script>explorer.outline.addDecl('equals');</script>

(T)(T <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>curried form of 
<span class="currsymbol">equals</span>
<script>explorer.outline.addDecl('equals');</script>

.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isOdd</span>
<script>explorer.outline.addDecl('isOdd');</script>

(T)(T <span class="funcparam">t</span>);
<br>bool 
<span class="currsymbol">isEven</span>
<script>explorer.outline.addDecl('isEven');</script>

(T)(T <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Small simple predicates on integral types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Not</span>
<script>explorer.outline.addDecl('Not');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a predicate and inverts it. It's an attempt to get <b><code>std.functional.not</code></b> to work.
I've had some difficulties to use it in filters.
<br><br>
<b>See Also:</b><br>
<b><code>dranges.algorithm.separate</code></b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[] r = [0,1,2,3,4,5];
<font color=blue>auto</font> f1 = filter!isOdd(r);
<font color=blue>auto</font> f2 = filter!(<u>Not</u>!isEven)(r);
<font color=blue>assert</font>(equal(f1,f2));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Nub</span>
<script>explorer.outline.addDecl('Nub');</script>

(T);
<br>Nub!(T) 
<span class="currsymbol">nub</span>
<script>explorer.outline.addDecl('nub');</script>

(T)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Wed Nov 10 23:47:30 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


