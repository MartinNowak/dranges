
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.functional2</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.functional2");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.functional2</h1><!-- Generated by Ddoc from dranges\functional2.d -->
This module contains all the function-related templates.
Its main use used to be to generate functions from strings, with the <b><code>naryFun</code></b> template,
an extension of <b><code>std.functional.unaryFun</code></b> and <b><code>binaryFun</code></b>. Now, it presents a nice collection
of adaptors and transformers: functions or templates acting on functions to transform them.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">arity</span>
<script>explorer.outline.addDecl('arity');</script>

(alias fun) if (isFunction!(fun))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the arity of a function: unary, binary, etc. A 0-args function has an arity of 0.
<br><br>
<pre class="d_code"><font color=blue>int</font> foo0() { <font color=blue>return</font> 0;}
<font color=blue>int</font> foo1(<font color=blue>int</font> a) { <font color=blue>return</font> a;}
<font color=blue>int</font> foo2(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> a+b;}

<font color=blue>assert</font>(<u>arity</u>!foo0 == 0);
<font color=blue>assert</font>(<u>arity</u>!foo1 == 1);
<font color=blue>assert</font>(<u>arity</u>!foo2 == 2);
</pre>

It does not work on non-instantiated template functions (because they
are not functions) and gives an arity of 1 for variadic functions, because
their variadic list is considered as one arg.
<pre class="d_code">T foo(T)(T t) { ...};
<font color=blue>auto</font> a = <u>arity</u>!foo; <font color=green>// error !
</font><font color=blue>auto</font> b = <u>arity</u>!(foo!<font color=blue>int</font>); <font color=green>// OK.
</font><font color=green>//
</font><font color=blue>int</font> foov(<font color=blue>int</font> a...) { <font color=blue>return</font> 0;}
<font color=blue>assert</font>(<u>arity</u>!foov == 1);
</pre>

<br><br>
<b>See Also:</b><br>
<b><code>dranges.templates.TemplateFunArity</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReturnTypes</span>
<script>explorer.outline.addDecl('ReturnTypes');</script>

(Funs...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a bunch of functions names, gives the typetuple of their return types. Used by <b><code>juxtapose</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ParameterTypeTuples</span>
<script>explorer.outline.addDecl('ParameterTypeTuples');</script>

(alias fun,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a bunch of functions names, gives the (flattened) typetuple of their return values. Used by <b><code>juxtapose</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(StaticFilter!(isNotVoid,ReturnTypes!(Funs))) 
<span class="currsymbol">juxtapose</span>
<script>explorer.outline.addDecl('juxtapose');</script>

(Funs...)(ParameterTypeTuples!(Funs) <span class="funcparam">params</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes n functions and create a new one, taking as arguments the concatenation of all input functions
arguments and returning a tuple of their results. It will deal correctly with nullary (0-arg) functions
by inserting their return value at the right place and with void-returning functions.
Do not use variadic functions, though.
<br><br>
This template is very useful when dealing with tuple-returning ranges.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i*i;}       <font color=green>// int -&gt; int
</font><font color=blue>int</font> bar() { <font color=blue>return</font> 0;}              <font color=green>// ()  -&gt; int
</font><font color=blue>void</font> baz(string s) {}               <font color=green>// string -&gt; ()
</font><font color=blue>double</font>[] quux(<font color=blue>double</font> d, <font color=blue>double</font>[] f) <font color=green>// (double,double[]) -&gt; double[]
</font>    { <font color=blue>return</font> f ~ d;}

<font color=blue>alias</font> <u>juxtapose</u>!(foo,bar,baz,quux) jux; <font color=green>// jux takes (int,string, double, double[]), returns Tuple!(int,int,double[]);
</font>
<font color=blue>auto</font> ir = [0,1,2,3,4,5];
<font color=blue>auto</font> sr = [<font color=red>"abc"</font>, <font color=red>"def"</font>,<font color=red>"ghijk"</font>];
<font color=blue>auto</font> dr = [3.14,2.78,1.00,-1.414];
<font color=blue>auto</font> fr = [[0.1,0.2], [0.0,-1.0,-2.0]];

<font color=blue>auto</font> m = tmap!jux(ir,sr,dr,fr);
</pre>

<br><br>
<b>Note:</b><br>
another, more mathematical way, to look at it is that <b><code>juxtapose</code></b> creates a function whose type is the product the input functions' types.
In D, product of types are tuples.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">FlipnR!(fun) 
<span class="currsymbol">flipn</span>
<script>explorer.outline.addDecl('flipn');</script>

(alias fun)(size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Flip and curry range functions, like <b><code>take</code></b>, <b><code>drop</code></b>, etc. These take a range and a size_t arguments, like <b><code>take(r,3)</code></b>, etc.
But sometimes, you just want to create a curried function that will act on any range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>flipn</u>!take takeN; <font color=green>// takeN is a generic function, waiting for a number of elements to take.
</font><font color=blue>auto</font> take3 = takeN(3);  <font color=green>// take3 is a generic function, taking 3 elements on any range (returns take(range,3))
</font>
<font color=blue>auto</font> threes = map!take3([[0,1,2,3,4,5],[6,7,8,9], [10]]); <font color=green>// get the first three elements of each range
</font><font color=blue>auto</font> witness =          [[0,1,2],      [6,7,8],   [10]];
<font color=blue>foreach</font>(i, elem; witness)  {<font color=blue>assert</font>(equal(elem, threes.front)); threes.popFront;}
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">flip</span>
<script>explorer.outline.addDecl('flip');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Flips (reverses) the arguments of a function. It also works for template functions, even
variadic ones. Do not use it on standard variadic functions, though.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> sub(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i-j;}
<font color=blue>int</font> one(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>double</font> three(<font color=blue>double</font> a, <font color=blue>int</font> b, string c) { <font color=blue>return</font> a;}

<font color=blue>alias</font> <u>flip</u>!sub fsub;
<font color=blue>alias</font> <u>flip</u>!one fone;
<font color=blue>alias</font> <u>flip</u>!three fthree;

<font color=blue>assert</font>(fsub(1,2) == sub(2,1));
<font color=blue>assert</font>(fone(1) == one(1));
<font color=blue>assert</font>(fthree(<font color=red>"abc"</font>, 0, 3.14) == three(3.14, 0, <font color=red>"abc"</font>));

string conj(A,B)(A a, B b)
{
    <font color=blue>return</font> to!string(a)~to!string(b);
}

string conjAll(A...)(A a) <font color=green>// variadic template function
</font>{
    string result;
    <font color=blue>foreach</font>(i,elem;a) result ~= to!string(elem);
    <font color=blue>return</font> result;
}

<font color=blue>alias</font> <u>flip</u>!conj fconj;
<font color=blue>alias</font> <u>flip</u>!conjAll fconjAll;

<font color=blue>assert</font>(fconj(1,2) == <font color=red>"21"</font>);
<font color=blue>assert</font>(fconjAll(1,2,3,4) == <font color=red>"4321"</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">curry</span>
<script>explorer.outline.addDecl('curry');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a D function, and curries it (in the Haskell sense, not as Phobos' <b><code>std.functional.curry</code></b>): given
a n-args function, it creates n 1-arg functions nested inside one another. When
all original arguments are reached, it returns the result. It's useful to make 'incomplete'
functions to be completed by ranges elements.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> add(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i+j;}
<font color=blue>alias</font> <u>curry</u>!add cadd; <font color=green>// cadd waits for an int, will return an int delegate(int)
</font><font color=blue>auto</font> add3 = cadd(3); <font color=green>// add3 is a function that take an int and return this int + 3.
</font>
<font color=blue>auto</font> m = map!add3([0,1,2,3]);
<font color=blue>assert</font>(equal(m, [3,4,5,6]));

<font color=blue>bool</font> equals(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i==j;}
<font color=blue>alias</font> <u>curry</u>!equals cequals;
<font color=blue>auto</font> equals4 = cequals(4); <font color=green>// equals4 is a function taking an int and return true iff this int is 4.
</font><font color=blue>auto</font> f = filter!equals4([2,3,4,5,4,3,2,2,3,4]);
<font color=blue>assert</font>(equal(f, [4,4,4]));
</pre>

What's fun is that it'll work for template functions too.

<br><br>
<b>Example:</b><br>
<pre class="d_code">string conj(A, B)(A a, B b)
{
    <font color=blue>return</font> to!string(a)~to!string(b);
}

<font color=blue>alias</font> <u>curry</u>!conj cconj;
<font color=blue>auto</font> c1 = cconj(1); <font color=green>// c1 is a template function waiting for any type.
</font><font color=blue>assert</font>(c1('a') == <font color=red>"1a"</font>);
</pre>
<br><br>
<b>BUG:</b><br>
for now, it does not verify the compatibility of types while you give it the arguments. It's only
at the end that it sees whether or not it can call the function with these arguments.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// given a function like this, with dependencies between the arguments' types:
</font>A foo(A,B,C)(A a, Tuple!(B,A) b, Tuple!(C,B,A) c) { <font color=blue>return</font> a+b.field[1]+c.field[2];}
<font color=green>// if you curries it and gives it an int as first argument, the returned template function should really be:
</font><font color=blue>int</font> foo2(B,C)(Tuple!(B,<font color=blue>int</font>) b) { <font color=blue>return</font> anotherFunction;}
<font color=green>// because we now know A to be an int...
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">InvertibleFun!(A,B) 
<span class="currsymbol">invertibleFun</span>
<script>explorer.outline.addDecl('invertibleFun');</script>

(A, B)(B delegate(A) <span class="funcparam">fun</span>, A delegate(B) <span class="funcparam">funInv</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes two delegates: one from <b><code>A</code></b> to <b><code>B</code></b>, the other from <b><code>B</code></b> to <b><code>A</code></b>. <b><code>A</code></b> and <b><code>B</code></b> must be different types.
The functions are supposed to be the inverse of one another (that is: f(g(x)) == x), but that's not checked.
<b><code>invertibleFun</code></b> is then a function that accepts either a <b><code>A</code></b> or a <b><code>B</code></b> and then returns a <b><code>B</code></b> or a <b><code>A</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Apply!(T) 
<span class="currsymbol">apply</span>
<script>explorer.outline.addDecl('apply');</script>

(T...)(T <span class="funcparam">value</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a value argument and creates a function (in fact, a struct with an opCall) that will accept any delegate
and apply it to the original value. It's useful when you want to map a certain value on a range of functions:
just map <b><code>apply!value</code></b> to the range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> f0(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>int</font> f1(<font color=blue>int</font> i) { <font color=blue>return</font> i*i;}
<font color=blue>int</font> f2(<font color=blue>int</font> i) { <font color=blue>return</font> i*i*i;}

<font color=blue>auto</font> apply4 = <u>apply</u>(4); <font color=green>// will call any function with '4' as argument.
</font><font color=blue>auto</font> rangeFun = [&amp;f0, &amp;f1, &amp;f2];
<font color=blue>auto</font> map4 = map!apply4(rangeFun);
<font color=blue>assert</font>(equal(map4, [4, 4*4, 4*4*4]));

<font color=green>// This works for n-args functions too:
</font><font color=blue>double</font> g0(<font color=blue>int</font> i, <font color=blue>double</font> d) { <font color=blue>return</font> i+d;}

<font color=blue>auto</font> apply123 = <u>apply</u>(1, 2.30);
<font color=blue>assert</font>(apply123(&amp;g0) == 3.30);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">destructured</span>
<script>explorer.outline.addDecl('destructured');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a standard function into a destructuring one. Given:
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b, <font color=blue>int</font> c) {}
</pre>
then, <b><code>destructured!foo</code></b> is a function that accepts three <b><code>int</code></b>s as arguments, but also <b><code>Tuple!(int,int,int)</code></b>
or <b><code>int[]</code></b> or <b><code>int[3]</code></b> or even any class <b><code>C</code></b> or struct <b><code>S</code></b> if <b><code>C.tupleof</code></b>/<b><code>S.tupleof</code></b> gives three <b><code>int</code></b>s. In effect,
<b><code>destructured!foo</code></b> will try to destructure (decompose, crack open, if you will) anything passed to it, to find three <b><code>int</code></b>s in a row to give
to <b><code>foo</code></b>.
<br><br>
<b>Note:</b><br>
It's still 'in construction', as it depends on the <b><code>_()</code></b> function from <b><code>dranges.reftuple</code></b>. The doc
should be extended.
<br><br>
<b>TODO:</b><br>
also if t is itself a tuple _(params) = t;<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">mapper</span>
<script>explorer.outline.addDecl('mapper');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function <b><code>foo</code></b> taking a <b><code>T</code></b> into a function accepting a <b><code>T[]</code></b> as an argument
and which applies <b><code>foo</code></b> to each element of the array, returning the resulting array.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i*i;}
<font color=blue>alias</font> <u>mapper</u>!foo mfoo;

<font color=blue>assert</font>(mfoo([0,1,2,3,4]) == [0,1,4,9,16]);
</pre>

If <b><code>foo</code></b> takes more than one argument, <b><code>mapper!foo</code></b> waits for a <b><code>Tuple!(Args)[]</code></b> or accepts
a variadic number of arguments, as long as the types and their numbers correspond.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> bar(<font color=blue>int</font> i, <font color=blue>double</font> j, string s) { <font color=blue>return</font> (to!<font color=blue>int</font>(i*j));}
<font color=blue>alias</font> <u>mapper</u>!bar mbar;

<font color=blue>assert</font>(mbar(1,3.14,<font color=red>"ab"</font>, 2,-0.5,<font color=red>"hello!"</font>, 0,0,<font color=red>""</font>) == [3,-3,0]);
</pre>
<br><br>
<b>TODO:</b><br>
expand tuples [tuple(a,b), tuple(a,b), ...]<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">tupler</span>
<script>explorer.outline.addDecl('tupler');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function <b><code>foo</code></b> accepting a <b><code>T</code></b> into a function accepting
a <b><code>Tuple!(T,T,T,...T)</code></b> (or any tuple with compatible types). It will apply
<b><code>foo</code></b> to all elements of the tuple and return the tuple of these results.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i*i;}
<font color=blue>alias</font> <u>tupler</u>!foo tfoo;
<font color=blue>auto</font> t = tuple(0,1,2,3,4);

<font color=blue>assert</font>(tfoo(t) == tuple(0,1,4,9,16));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">voidFun</span>
<script>explorer.outline.addDecl('voidFun');</script>

(...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The void function: takes any arguments, returns <b><code>void</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">nullFun</span>
<script>explorer.outline.addDecl('nullFun');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The null function: takes no argument, returns <b><code>void</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] delegate(...) 
<span class="currsymbol">constantFun</span>
<script>explorer.outline.addDecl('constantFun');</script>

(T...)(T <span class="funcparam">t</span>);
<br>Tuple!(T) delegate(...) 
<span class="currsymbol">constantFun</span>
<script>explorer.outline.addDecl('constantFun');</script>

(T...)(T <span class="funcparam">t</span>);
<br>void delegate(...) 
<span class="currsymbol">constantFun</span>
<script>explorer.outline.addDecl('constantFun');</script>

(T...)(T <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes any value, returns a constant function: one that accepts any arguments and will always return
the initial value. If called with no argument, it will produce the equivalent of <b><code>voidFun</code></b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> one = <u>constantFun</u>(1);
<font color=blue>assert</font>(equal(map!one([<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"abc"</font>]), [1,1,1]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ExtendFun!(fun) 
<span class="currsymbol">extendFun</span>
<script>explorer.outline.addDecl('extendFun');</script>

(alias fun)();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a function <b><code>foo</code></b> and 'extends' it, allowing it to accept any type of argument.
If the arguments types are compatible with <b><code>foo</code></b>, returns foo(args) otherwise, it just returns
the argument.
<br><br>
That may seem a strange template to define, but it's quite useful for mapping a tuple (see <b><code>dranges.tuple2.mapTuple</code></b>).
Suppose you have a tuple and what to change only the strings in it. Define <b><code>foo</code></b> to act on strings, extend it with
<b><code>extendFun!foo</code></b> and voila, you can then map <b><code>extendFun!foo</code></b> on your tuple: the strings will be transformed, leaving the
other types untouched. I learnt the trick from a Haskell article.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>import</font> dranges.tuple2;

<font color=blue>auto</font> t = tuple(<font color=red>"bin"</font>, 1024, 3.14159,
               <font color=red>"src"</font>, 0,    1.0,
               <font color=red>"myDirectory/foo"</font>, 100, -2.3);

string foo(string s) { <font color=blue>return</font> <font color=red>"std/"</font> ~ s;}

<font color=blue>auto</font> efoo = <u>extendFun</u>!foo; <font color=green>// beware: it's not alias extendFun!foo efoo;, as for other templates around here.
</font>
<font color=blue>auto</font> t2 = mapTuple ! efoo (t);

<font color=blue>assert</font>(t2 == tuple(<font color=red>"std/bin"</font>, 1024, 3.14159,
                   <font color=red>"std/src"</font>, 0,    1.0,
                   <font color=red>"std/myDirectory/foo"</font>, 100, -2.3));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ExtendFun0!(fun,D) 
<span class="currsymbol">extendFun0</span>
<script>explorer.outline.addDecl('extendFun0');</script>

(alias fun, D)(D <span class="funcparam">defaultValue</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as before, but with a default value returned when extendFun is offered
an arg that <b><code>foo</code></b> cannot accept. The default value can be of any type.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>import</font> dranges.tuple2;

<font color=blue>auto</font> t = tuple(<font color=red>"bin"</font>, 1024, 3.14159,
               <font color=red>"src"</font>, 0,    1.0,
               <font color=red>"myDirectory/foo"</font>, 100, -2.3);

string foo(string s) { <font color=blue>return</font> <font color=red>"std/"</font> ~ s;}

<font color=blue>auto</font> efoo = <u>extendFun0</u>!foo(0);

<font color=blue>auto</font> t2 = mapTuple ! efoo (t);

<font color=blue>assert</font>(t2 == tuple(<font color=red>"std/bin"</font>,               0, 0,
                   <font color=red>"std/src"</font>,               0, 0,
                   <font color=red>"std/myDirectory/foo"</font>,   0, 0));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">eitherFun</span>
<script>explorer.outline.addDecl('eitherFun');</script>

(F...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This is just a wrapper around the <b><code>match</code></b> function found in <b><code>dranges.pattermatch</code></b>, here to emphasize
the way <b><code>match</code></b> is just a many-types-to-many-types 'function'. Explained a bit more clearly, <b><code>eitherFun</code></b>
takes any number of functions and keep them near its hot little heart. When passed an argument, it will
successively test each function and returns the result of the first one that matches. No match means it will
throw a NoMatch exception. Functions are tested the same order they were passed as arguments.
<br><br>
How is this different from overloading, will you ask? I'm glad you did:
<br><br>

<ul> <li>first, you can use it to 'group' many different functions, from different origins and different names.</li>
  <li>second (and that may be the most important point), it's a template, so the return
type of <b><code>eitherFun</code></b> can be different for each argument type. So you can use it to map a range, but also a tuple, with <b><code>dranges.tuple2.mapTuple</code></b></li>.
  <li>third, it accepts template functions. In fact, it even accepts 'string' functions, as in "a+b*c-d.expand". See the <b><code>patternmatch</code></b>
module documentation for more explanations.</li>
  <li>fourth, once it's defined, you can pass it around as one entity. Most notably, it can becomes the argument
    of another meta-function there or even the argument to another <b><code>eitherFun!</code></b></li>
</ul>
<br><br>

So, in functional languages terms, it's a sum of functions (just as <b><code>juxtapose</code></b> is a product).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>    f1(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>double</font> f2(<font color=blue>double</font> d) { <font color=blue>return</font> d*d;}
<font color=blue>int</font>    f3(<font color=blue>int</font> i, string s) { <font color=blue>return</font> i;}
string f4(string s, <font color=blue>int</font> i) { <font color=blue>return</font> s;}

<font color=blue>alias</font> <u>eitherFun</u>!(f1,f2,f3,f4) efun; <font color=green>// efun accepts either an int, or a double, or a (int,string) or a (string, int)
</font>
<font color=blue>assert</font>(efun(1) == 1);
<font color=blue>assert</font>(efun(1.5) == 2.25);
<font color=blue>assert</font>(efun(1,<font color=red>"abc"</font>) == 1);
<font color=blue>assert</font>(efun(<font color=red>"abc"</font>,1) == <font color=red>"abc"</font>);

<font color=green>// Let's extend it, then.
</font><font color=blue>int</font>[] f5(<font color=blue>int</font>[] i) { <font color=blue>return</font> i.reverse;}

<font color=blue>alias</font> <u>eitherFun</u>!(efun, f5) efun5;   <font color=green>// efun5 will test f1, then f2, ... and f5 at last resort.
</font><font color=green>// alias eitherFun(f5, efun) efun5bis would have tested f5 first, then f1, ...
</font>
<font color=blue>assert</font>(efun5(1) == 1);              <font color=green>// efun5 is like efun
</font><font color=blue>assert</font>(efun5(1.5) == 2.25);
<font color=blue>assert</font>(efun5(1,<font color=red>"abc"</font>) == 1);
<font color=blue>assert</font>(efun5(<font color=red>"abc"</font>,1) == <font color=red>"abc"</font>);
<font color=blue>assert</font>(efun5([0,1,2]) == [2,1,0]);  <font color=green>// except it also accepts an array of ints as argument.
</font></pre>

<br><br>
<b>Note:</b><br>
as said before, functions are tested in the same order they were passed as arguments. So a function can 'swallow' arguments
that could have been accepted by another, downstream function.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">adaptFun</span>
<script>explorer.outline.addDecl('adaptFun');</script>

(alias pre,alias fun,alias post = "a")</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A simple adapter, when you have a complicated function you do not (or cannot) want to touch. It
applies the <b><code>pre</code></b> preprocessing to the arguments, calls fun and then postprocess the result. The
default for post is "a", that is the identity string function. So the two args version of <b><code>adaptFun</code></b>
just deals with adapting the arguments.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">powerFun</span>
<script>explorer.outline.addDecl('powerFun');</script>

(alias fun,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The composition 'power' of a function: <b><code>fun(fun(fun(x)...))</code></b>, n times. n == 1 is the same
as <b><code>fun</code></b> and n = 0 is the identity function (just returns the arguments).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> inc(<font color=blue>int</font> i) { <font color=blue>return</font> i+1;}
string conc(string s) { <font color=blue>return</font> s ~ s;}

<font color=blue>alias</font> <u>powerFun</u>!(inc, 5) plus5; <font color=green>// calls inc(inc(inc(inc(inc(t))))), so returns t+5
</font><font color=blue>alias</font> <u>powerFun</u>!(inc, 1) plus1;
<font color=blue>alias</font> <u>powerFun</u>!(inc, 0) plus0;

<font color=blue>assert</font>(plus5(4) == 9);
<font color=blue>assert</font>(plus1(4) == 5);
<font color=blue>assert</font>(plus0(4) == 4);

<font color=blue>alias</font> <u>powerFun</u>!(conc, 2) conc2;

<font color=blue>assert</font>(conc(<font color=red>"abc"</font>) == <font color=red>"abcabc"</font>);
<font color=blue>assert</font>(conc2(<font color=red>"abc"</font>) == <font color=red>"abcabcabcabc"</font>);
<font color=blue>assert</font>(conc2(<font color=red>"abc"</font>) == conc(conc(<font color=red>"abc"</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">DefaultValues!(fun,arity!(fun),D) 
<span class="currsymbol">withDefaultValues</span>
<script>explorer.outline.addDecl('withDefaultValues');</script>

(alias fun, D...)(D <span class="funcparam">defaults</span>);
<br>DefaultValues!(fun,arity,D) 
<span class="currsymbol">withDefaultValues</span>
<script>explorer.outline.addDecl('withDefaultValues');</script>

(alias fun, size_t arity, D...)(D <span class="funcparam">defaults</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a function and store default values for its last arguments. For a n-arg function,
you can provided d default values, d being between 0 and n. These values will be applied
to the last d arguments.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i, <font color=blue>int</font> j, <font color=blue>double</font> k) { <font color=blue>return</font> i+j+to!<font color=blue>int</font>(k);}
<font color=blue>auto</font> dfoo = <u>withDefaultValues</u>!(foo)(2,1.5); <font color=green>// two default values provided -&gt; 2 for j and 1.5 for k
</font>                                            <font color=green>// so dfoo can accept 1, 2 or 3 arguments.
</font>
<font color=blue>assert</font>(dfoo(1)         == foo(1, 2, 1.5)); <font color=green>// 1 arg given -&gt; dfoo use two defaults
</font><font color=blue>assert</font>(dfoo(1, 1)      == foo(1, 1, 1.5)); <font color=green>// 2 args -&gt; one default
</font><font color=blue>assert</font>(dfoo(1, 1, 0.5) == foo(1, 1, 0.5)); <font color=green>// 3 args -&gt; no default
</font></pre>

Most of the time, <b><code>withDefaultValues</code></b> will determine the arity of your function. In case of doubt, you can provide it as
a second template argument, like this:
<pre class="d_code">A bar(A,B)(A a0, A a1, B a2, Tuple!(A,B) a3) { <font color=blue>return</font> a0;} <font color=green>// template function, withDefaultValues cannot determine the arity is 4
</font><font color=blue>auto</font> dbar = <u>withDefaultValues</u>!(bar, 4)(2, tuple(2, 3.14));
</pre>

<br><br>
<b>TODO:</b><br>
No, that should be possible now that I have a template to determine the arity even of template functions.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">construct</span>
<script>explorer.outline.addDecl('construct');</script>

(Struct) if (is(Struct == struct))<br>template 
<span class="currsymbol">construct</span>
<script>explorer.outline.addDecl('construct');</script>

(Class) if (is(Class == class))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Accepts a <b><code>class</code></b> or <b><code>struct</code></b> name as template argument and creates a factory function that creates
the corresponding <b><code>class</code></b>/<b><code>struct</code></b>. It allows one to map a constructor on a range, to create a
range of classes. It's not possible normally.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>class</font> C {
    <font color=blue>int</font> i;
    <font color=blue>this</font>(<font color=blue>int</font> _i) { i = _i;}
}

<font color=blue>auto</font> arr = [0,1,2,3];

<font color=green>// auto m = map!C(arr); // does not work.
</font><font color=blue>alias</font> <u>construct</u>!C CC;
<font color=blue>auto</font> m = map!CC(arr); <font color=green>// works;
</font><font color=green>// m is like [new C(0), new C(1), new C(2), new C(3)]
</font></pre>

What's fun is when you use it on many-args constructors or structs:
<pre class="d_code"><font color=blue>struct</font> S { <font color=blue>int</font> i; <font color=blue>double</font> d;}

<font color=blue>alias</font> <u>construct</u>!S CS;

<font color=blue>auto</font> s = tmap!CS([0,1,2,3], [-1.1,-2.2,3.3,4.]); <font color=green>// Yeah, tmap
</font><font color=blue>assert</font>(equal(s, [S(0,-1.1), S(1, -2.2), S(2, 3.3), S(3, 4.0)]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">arrayify</span>
<script>explorer.outline.addDecl('arrayify');</script>

(alias fun)(CommonType!(ParameterTypeTuple!(fun))[] <span class="funcparam">args</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function accepting <b><code>(T, T, T, ...)</code></b> into a function accepting <b><code>(T[])</code></b>. The new function
will consume as many arguments as needed, but won't throw if there are more.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i, <font color=blue>int</font> j, <font color=blue>int</font> k) { <font color=blue>return</font> i+j+k;}

<font color=blue>alias</font> <u>arrayify</u>!foo afoo;
<font color=blue>assert</font>(afoo([1,2,3]) == 1+2+3);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">rangify</span>
<script>explorer.outline.addDecl('rangify');</script>

(alias fun) if (isFunction!(fun) &amp;&amp; is(CommonType!(ParameterTypeTuple!(fun))))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function accepting a <b><code>(T,T,T,...)</code></b> into a function accepting a range of <b><code>T</code></b>s.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">tuplify</span>
<script>explorer.outline.addDecl('tuplify');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function into a tuple-accepting function. Useful to map a standard function
on a tuple-producing range. A parameterless function (zero args) is left untouched.
<br><br>
<b>See Also:</b><br>
<b><code>tmap</code></b>, <b><code>tfilter</code></b>, <b><code>comp</code></b> and <b><code>pComp</code></b> in <b><code>dranges.algorithm2.d</code></b>.

<br><br>
<b>Example:</b><br>
<pre class="d_code">string foo3(<font color=blue>int</font> a, string b, <font color=blue>double</font> c) {
    <font color=blue>return</font> to!string(a) ~ <font color=red>"+"</font> ~ b ~ <font color=red>"+"</font> ~ to!string(c);
}

<font color=blue>auto</font> tfoo3 = <u>tuplify</u>!foo3;
<font color=blue>auto</font> t = tuple(1, <font color=red>"a"</font>, 3.0);
<font color=blue>auto</font> result = tfoo3(t);
<font color=blue>assert</font>(result == <font color=red>"1+a+3"</font>);

string foo() {
    <font color=blue>return</font> <font color=red>"aha"</font>;
}
<font color=blue>auto</font> tfoo = <u>tuplify</u>!foo;
<font color=blue>assert</font>(tfoo() == <font color=red>"aha"</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">addArgs</span>
<script>explorer.outline.addDecl('addArgs');</script>

(alias fun, T...)(ParameterTypeTuple!(fun) <span class="funcparam">args</span>, T <span class="funcparam">newArgs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A simple adaptor for <b><code>fun</code></b>, making it accept supplementary arguments of type <b><code>T...</code></b>.
<br><br>
<b>See Also:</b><br>
<b><code>makeVariadic</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">makeVariadic</span>
<script>explorer.outline.addDecl('makeVariadic');</script>

(alias fun)(ParameterTypeTuple!(fun) <span class="funcparam">args</span>,...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a standard function, and makes it variadic: it will accept any number of surnumerary arguments of any type
after the 'normal' ones that it had before. It's useful to 'adapt' a function to a range (with
automatic unpacking of tuples, like for <b><code>tmap</code></b>).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>alias</font> <u>makeVariadic</u>!foo vfoo;
<font color=blue>auto</font> i = vfoo(1, 2,3,'a', <font color=red>"hello there!"</font>);
<font color=blue>assert</font>(i == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CompatibilityFuncArgs</span>
<script>explorer.outline.addDecl('CompatibilityFuncArgs');</script>

(alias fun,ARGS...) if (isFunction!(fun))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> iff <b><code>fun</code></b> can be applied on the TypeTuple <b><code>ARGS</code></b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(<font color=red>"a+b"</font>, <font color=blue>int</font>, <font color=blue>int</font>)); <font color=green>// 'string' function are templated by unaryFun or binaryFun
</font>                                                 <font color=green>// They will always be compatible with their args
</font><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(binaryFun!<font color=red>"a+b"</font>, <font color=blue>int</font>, <font color=blue>int</font>));

<font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>double</font> b) { <font color=blue>return</font> a;}
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, <font color=blue>double</font>));
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, <font color=blue>int</font>)); <font color=green>// You can pass an int as second argument for foo, as it will be converted
</font><font color=blue>assert</font>(!<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>double</font>, <font color=blue>double</font>));  <font color=green>// But not a double as first arg.
</font><font color=blue>assert</font>(!<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, string));

<font color=blue>int</font> bar() { <font color=blue>return</font> 0;}
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!bar); <font color=green>// For bar, no args...
</font><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(bar, TypeTuple!())); <font color=green>// For bar, no args...
</font>
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!((<font color=blue>int</font> a) { <font color=blue>return</font> -a;}, <font color=blue>int</font>)); <font color=green>// Works for anonymous functions
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(string fun,uint Nparam)<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(string fun)<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(alias fun,uint Nparam) if (!is(typeof(fun) : string))<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(alias fun) if (!is(typeof(fun) : string))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalization of <b><code>std.functional.unaryFun</code></b> and <b><code>.binaryFun</code></b> for as many params as you need, in the 'a' - 'z' (included)
range. You can indicate the desired final arity if you want, but otherwise a compile-time heuristics
tries to determine the string's 'arity'.
As for <b><code>unaryFun</code></b> and <b><code>binaryFun</code></b>, 'a' means first argument, 'b' the second and so on.
As for <b><code>unaryFun</code></b> and <b><code>binaryFun</code></b>, it creates a templated function, with the type of each parameter left undecided.
As for <b><code>unaryFun</code></b> and <b><code>binaryFun</code></b>, it does not change <b><code>fun</code></b> if it's already a function.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>naryFun</u>!(<font color=red>"a+b*c-d"</font>) test4;  <font color=green>// Creates a templated 4-args function test4(A, B, C, D)(A a, B b, C c, D d) { return a+b*c-d;}
</font><font color=blue>assert</font>(test4(1,2,3,4) == 3);        <font color=green>// instantiate test4!(int, int, int, int)
</font><font color=blue>assert</font>(test4(1.0,2.0,3,4) == 3.0);  <font color=green>// instantiate test4!(double, double, int, int)
</font>
<font color=blue>alias</font> <u>naryFun</u>!(<font color=red>"a+b"</font>,3) test3;      <font color=green>// You can create a fun with more args than necessary, if you wish
</font><font color=blue>assert</font>(test3(1,2,100) == 3);        <font color=green>// without the 3, naryFun!"a+b" would create a binary function.
</font><font color=blue>assert</font>(test3(1.0,2.0,100) == 3.0);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"sin(a)+cos(b)*c"</font> testsincos; <font color=green>// functional2.d imports a lot of other D modules, to have their functions accessible.
</font>
<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"tuple(a,a,a)"</font> toTuple;
<font color=blue>assert</font>(toTuple(1) == tuple(1,1,1));

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"a.expand[1]"</font> tuple1; <font color=green>// tuple1 will be created, but can be used only on types defining a .expand field.
</font><font color=blue>assert</font>(tuple1(toTuple(1)) == 1);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"[b,a,c]"</font> arrayTwister; <font color=green>// will return a static array
</font><font color=blue>assert</font>(arrayTwister(0,1,2) == [1,0,2]);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"f"</font> projection6; <font color=green>// 'a' -&gt; 1 arg, 'b' -&gt; binary, ..., 'f' -&gt; 6-args function. In this case, returning only its sixth argument.
</font><font color=blue>assert</font>(projection6(0,1,2,3,4,5) == 5);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"3"</font> test0;               <font color=green>// A 0-arg function. It's exactly: int test0() { return 3;}
</font><font color=blue>assert</font>(test0 == 3);                    <font color=green>// Constant return
</font><font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(test0) == <font color=blue>function</font>)); <font color=green>// But it's a function, not a constant.
</font>
<font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> a*b;}
<font color=blue>alias</font> <u>naryFun</u>!(foo) nfoo;           <font color=green>// function test
</font><font color=blue>assert</font>(nfoo(2,3) == 6);

<font color=blue>int</font> bar() { <font color=blue>return</font> 1;}
<font color=blue>alias</font> <u>naryFun</u>!bar nbar;             <font color=green>// 0-arg function test
</font><font color=blue>assert</font>(nbar == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Prepare</span>
<script>explorer.outline.addDecl('Prepare');</script>

(alias fun,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Internal template to transform a function or a 'string' function
to be applied on a tuple. The <b><code>T...</code></b> part must contains the information
about the args types. It's used to instantiate the correct function
from the template function created by <b><code>naryFun</code></b>.
<br><br>
It's used internally by all the tuple-mapping functions: <b><code>tmap</code></b>, <b><code>tfilter</code></b>, etc.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Mon Jun 28 22:17:00 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm2");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional2");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range2");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits2");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple2");

    explorer.packageExplorer.addModule("dranges.typetuple2");

    explorer.packageExplorer.addModule("dranges.variadic");

</script>
</body></html>


