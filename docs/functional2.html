
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.functional2</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.functional2");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.functional2</h1><!-- Generated by Ddoc from dranges\functional2.d -->
This module contains all the function-related templates.
Its main use is to generate functions from strings, with the naryFun template,
an extension of std.functional.unaryFun and binaryFun and to transform functions.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">arity</span>
<script>explorer.outline.addDecl('arity');</script>

(alias fun) if (isFunction!(fun))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the 
<span class="currsymbol">arity</span>
<script>explorer.outline.addDecl('arity');</script>

 of a function: unary, binary, etc. A 0-args function has a 
<span class="currsymbol">arity</span>
<script>explorer.outline.addDecl('arity');</script>

 of 0.
<br><br>
<pre class="d_code"><font color=blue>int</font> foo0() { <font color=blue>return</font> 0;}
<font color=blue>int</font> foo1(<font color=blue>int</font> a) { <font color=blue>return</font> a;}
<font color=blue>int</font> foo2(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> a+b;}
T foo3(T, U)(T t, U u) { <font color=blue>return</font> t;} <font color=green>// templated
</font><font color=blue>assert</font>(<u>arity</u>!foo0 == 0);
<font color=blue>assert</font>(<u>arity</u>!foo1 == 1);
<font color=blue>assert</font>(<u>arity</u>!foo2 == 2);
</pre>

It does not work on non-instantiated template functions (because they
are not functions) and gives an 
<span class="currsymbol">arity</span>
<script>explorer.outline.addDecl('arity');</script>

 of 1 for variadic functions, because
their variadic list is considered as one arg.
<pre class="d_code">T foo(T)(T t) { ...};
<font color=blue>auto</font> a = <u>arity</u>!foo; <font color=green>// error !
</font><font color=blue>auto</font> b = <u>arity</u>!(foo!<font color=blue>int</font>); <font color=green>// OK.
</font><font color=green>//
</font><font color=blue>int</font> foov(<font color=blue>int</font> a...) { <font color=blue>return</font> 0;}
<font color=blue>assert</font>(<u>arity</u>!foov == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReturnTypes</span>
<script>explorer.outline.addDecl('ReturnTypes');</script>

(Funs...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a bunch of functions names, gives the typetuple of their return types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ParameterTypeTuples</span>
<script>explorer.outline.addDecl('ParameterTypeTuples');</script>

(alias fun,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a bunch of functions names, gives the (flattened) typetuple of their return values.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(StaticFilter!(isNotVoid,ReturnTypes!(Funs))) 
<span class="currsymbol">juxtapose</span>
<script>explorer.outline.addDecl('juxtapose');</script>

(Funs...)(ParameterTypeTuples!(Funs) <span class="funcparam">params</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes n functions and create a new one, taking as arguments the concatenation of all input functions
arguments and returning a tuple of their results. It will deal correctly with nullary (0-arg) functions
by inserting their return value at the right place and with void-returning functions.
Do not use variadic functions, though.
<br><br>
This template is very useful when dealing with tuple-returning ranges.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i*i;}       <font color=green>// int -&gt; int
</font><font color=blue>int</font> bar() { <font color=blue>return</font> 0;}              <font color=green>// ()  -&gt; int
</font><font color=blue>void</font> baz(string s) {}               <font color=green>// string -&gt; ()
</font><font color=blue>double</font>[] quux(<font color=blue>double</font> d, <font color=blue>double</font>[] f) <font color=green>// (double,double[]) -&gt; double[]
</font>    { <font color=blue>return</font> f ~ d;}

<font color=blue>alias</font> <u>juxtapose</u>!(foo,bar,baz,quux) jux; <font color=green>// jux takes (int,string, double, double[]), returns Tuple!(int,int,double[]);
</font>
<font color=blue>auto</font> ir = [0,1,2,3,4,5];
<font color=blue>auto</font> sr = [<font color=red>"abc"</font>, <font color=red>"def"</font>,<font color=red>"ghijk"</font>];
<font color=blue>auto</font> dr = [3.14,2.78,1.00,-1.414];
<font color=blue>auto</font> fr = [[0.1,0.2], [0.0,-1.0,-2.0]];

<font color=blue>auto</font> m = tmap!jux(ir,sr,dr,fr);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">FlipnR!(fun) 
<span class="currsymbol">flipn</span>
<script>explorer.outline.addDecl('flipn');</script>

(alias fun)(size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Flip and curry range functions, like take, drop, etc. These take a range and a size_t arguments, like take(r,3), etc.
But sometimes, you just want to create a curried function that will act on any range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>flipn</u>!take takeN; <font color=green>// takeN is a generic function, waiting for a number of elements to take.
</font><font color=blue>auto</font> take3 = takeN(3);  <font color=green>// take3 is a generic function, taking 3 elements on any range (returns take(range,3))
</font>
<font color=blue>auto</font> threes = map!take3([[0,1,2,3,4,5],[6,7,8,9], [10]]); <font color=green>// get the first three elements of each range
</font><font color=blue>auto</font> witness =          [[0,1,2],      [6,7,8],   [10]];
<font color=blue>foreach</font>(i, elem; witness)  {<font color=blue>assert</font>(equal(elem, threes.front)); threes.popFront;}
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">flip</span>
<script>explorer.outline.addDecl('flip');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Flips (reverses) the arguments of a function. It also works for template functions, even
variadic ones. Do not use it on standard variadic functions, though.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> sub(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i-j;}
<font color=blue>int</font> one(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>double</font> three(<font color=blue>double</font> a, <font color=blue>int</font> b, string c) { <font color=blue>return</font> a;}

<font color=blue>alias</font> <u>flip</u>!sub fsub;
<font color=blue>alias</font> <u>flip</u>!one fone;
<font color=blue>alias</font> <u>flip</u>!three fthree;

<font color=blue>assert</font>(fsub(1,2) == sub(2,1));
<font color=blue>assert</font>(fone(1) == one(1));
<font color=blue>assert</font>(fthree(<font color=red>"abc"</font>, 0, 3.14) == three(3.14, 0, <font color=red>"abc"</font>));

string conj(A,B)(A a, B b)
{
    <font color=blue>return</font> to!string(a)~to!string(b);
}

string conjAll(A...)(A a) <font color=green>// variadic template function
</font>{
    string result;
    <font color=blue>foreach</font>(i,elem;a) result ~= to!string(elem);
    <font color=blue>return</font> result;
}

<font color=blue>alias</font> <u>flip</u>!conj fconj;
<font color=blue>alias</font> <u>flip</u>!conjAll fconjAll;

<font color=blue>assert</font>(fconj(1,2) == <font color=red>"21"</font>);
<font color=blue>assert</font>(fconjAll(1,2,3,4) == <font color=red>"4321"</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">makeVariadic</span>
<script>explorer.outline.addDecl('makeVariadic');</script>

(alias fun)(ParameterTypeTuple!(fun) <span class="funcparam">args</span>,...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a standard function, and makes it variadic: it will accept any number of surnumerary arguments
after the 'normal' ones that it had before. It's useful to 'adapt' a function to a range (with
automatic unpacking of tuples, like for tmap).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> foo(<font color=blue>int</font> i) { <font color=blue>return</font> i;}
<font color=blue>alias</font> <u>makeVariadic</u>!foo vfoo;
<font color=blue>auto</font> i = vfoo(1, 2,3,'a', <font color=red>"hello there!"</font>);
<font color=blue>assert</font>(i == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">curry</span>
<script>explorer.outline.addDecl('curry');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a D function, and curries it (in the Haskell sense, not as Phobos' <b><code>std.functional.curry</code></b>): given
a n-args functions, it creates n 1-arg functions nested inside one another. When
all original arguments are reached, it returns the result. It's useful to make 'incomplete'
functions to be completed by ranges elements.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font> add(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i+j;}
<font color=blue>alias</font> <u>curry</u>!add cadd; <font color=green>// cadd waits for an int, will return an int delegate(int)
</font><font color=blue>auto</font> add3 = cadd(3); <font color=green>// add3 is a function that take an int and return this int + 3.
</font>
<font color=blue>auto</font> m = map!add3([0,1,2,3]);
<font color=blue>assert</font>(equal(m, [3,4,5,6]));

<font color=blue>bool</font> equals(<font color=blue>int</font> i, <font color=blue>int</font> j) { <font color=blue>return</font> i==j;}
<font color=blue>alias</font> <u>curry</u>!equals cequals;
<font color=blue>auto</font> equals4 = cequals(4); <font color=green>// equals4 is a function taking an int and return true iff this int is 4.
</font><font color=blue>auto</font> f = filter!equals4([2,3,4,5,4,3,2,2,3,4]);
<font color=blue>assert</font>(equal(f, [4,4,4]));
</pre>

What's fun is that it'll work for template functions too.

<br><br>
<b>Example:</b><br>
<pre class="d_code">string conj(A, B)(A a, B b)
{
    <font color=blue>return</font> to!string(a)~to!string(b);
}

<font color=blue>alias</font> <u>curry</u>!conj cconj;
<font color=blue>auto</font> c1 = cconj(1); <font color=green>// c1 is a template function waiting for any type.
</font><font color=blue>assert</font>(c1('a') == <font color=red>"1a"</font>);
</pre>
<br><br>
<b>BUG:</b><br>
for now, it does not verify the compatibility of types while you give it the arguments. It's only
at the end that it sees whether or not it can call the function with these arguments.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// given a function like this, with dependencies between the arguments' types:
</font>A foo(A,B,C)(A a, Tuple!(B,A) b, Tuple!(C,B,A) c) { <font color=blue>return</font> a+b.field[1]+c.field[2];}
<font color=green>// if you curries it and gives it an int as first argument, the returned template function should really be:
</font><font color=blue>int</font> foo2(B,C)(Tuple!(B,<font color=blue>int</font>) b) { <font color=blue>return</font> anotherFunction;}
<font color=green>// because we now know A to be an int...
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">InvertibleFun</span>
<script>explorer.outline.addDecl('InvertibleFun');</script>

(A,B);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">apply</span>
<script>explorer.outline.addDecl('apply');</script>

(alias value)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">destructured</span>
<script>explorer.outline.addDecl('destructured');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">mapper</span>
<script>explorer.outline.addDecl('mapper');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">tupler</span>
<script>explorer.outline.addDecl('tupler');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">voidFun</span>
<script>explorer.outline.addDecl('voidFun');</script>

(...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">nullFun</span>
<script>explorer.outline.addDecl('nullFun');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">extendFun</span>
<script>explorer.outline.addDecl('extendFun');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">extendFun</span>
<script>explorer.outline.addDecl('extendFun');</script>

(alias fun,alias Default)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">eitherFun</span>
<script>explorer.outline.addDecl('eitherFun');</script>

(F...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">adaptFun</span>
<script>explorer.outline.addDecl('adaptFun');</script>

(alias pre,alias fun,alias post = "a")</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">power</span>
<script>explorer.outline.addDecl('power');</script>

(alias fun,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">DefaultValues!(fun,arity!(fun),D) 
<span class="currsymbol">withDefaultValues</span>
<script>explorer.outline.addDecl('withDefaultValues');</script>

(alias fun, D...)(D <span class="funcparam">defaults</span>);
<br>DefaultValues!(fun,arity,D) 
<span class="currsymbol">withDefaultValues</span>
<script>explorer.outline.addDecl('withDefaultValues');</script>

(alias fun, size_t arity, D...)(D <span class="funcparam">defaults</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">arrayify</span>
<script>explorer.outline.addDecl('arrayify');</script>

(alias fun)(CommonType!(ParameterTypeTuple!(fun))[] <span class="funcparam">args</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">rangify</span>
<script>explorer.outline.addDecl('rangify');</script>

(alias fun) if (isFunction!(fun) &amp;&amp; is(CommonType!(ParameterTypeTuple!(fun))))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ReturnType!(fun) 
<span class="currsymbol">addArgs</span>
<script>explorer.outline.addDecl('addArgs');</script>

(alias fun, T...)(ParameterTypeTuple!(fun) <span class="funcparam">args</span>, T <span class="funcparam">newArgs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">CompatibilityFuncArgs</span>
<script>explorer.outline.addDecl('CompatibilityFuncArgs');</script>

(alias fun,ARGS...) if (isFunction!(fun))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> iff fun can be applied on the TypeTuple ARGS.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(<font color=red>"a+b"</font>, <font color=blue>int</font>, <font color=blue>int</font>)); <font color=green>// 'string' function are templated by unaryFun or binaryFun
</font>                                                 <font color=green>// They will always be compatible with their args
</font><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(binaryFun!<font color=red>"a+b"</font>, <font color=blue>int</font>, <font color=blue>int</font>));

<font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>double</font> b) { <font color=blue>return</font> a;}
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, <font color=blue>double</font>));
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, <font color=blue>int</font>)); <font color=green>// You can pass an int as second argument for foo, as it will be converted
</font><font color=blue>assert</font>(!<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>double</font>, <font color=blue>double</font>));  <font color=green>// But not a double as first arg.
</font><font color=blue>assert</font>(!<u>CompatibilityFuncArgs</u>!(foo, <font color=blue>int</font>, string));

<font color=blue>int</font> bar() { <font color=blue>return</font> 0;}
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!bar); <font color=green>// For bar, no args...
</font><font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!(bar, TypeTuple!())); <font color=green>// For bar, no args...
</font>
<font color=blue>assert</font>(<u>CompatibilityFuncArgs</u>!((<font color=blue>int</font> a) { <font color=blue>return</font> -a;}, <font color=blue>int</font>)); <font color=green>// Works for anonymous functions
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(string fun,uint Nparam)<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(string fun)<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(alias fun,uint Nparam) if (!is(typeof(fun) : string))<br>template 
<span class="currsymbol">naryFun</span>
<script>explorer.outline.addDecl('naryFun');</script>

(alias fun) if (!is(typeof(fun) : string))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A generalization of std.functional.unaryFun and .binaryFun for as many params as you need, in the 'a' - 'z' (included)
range. You can indicate the desired final arity if you want but otherwise a compile-time heuristics
tries to determine the string's 'arity'.
As for unaryFun and binaryFun, 'a' means first argument, 'b' the second and so on.
As for unaryFun and binaryFun, it creates a templated function, with the type of each parameter left undecided.
As for unaryFun and binaryFun, it does not change fun if it's already a function.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>naryFun</u>!(<font color=red>"a+b*c-d"</font>) test4;  <font color=green>// Creates a templated 4-args function test4(A, B, C, D)(A a, B b, C c, D d) { return a+b*c-d;}
</font><font color=blue>assert</font>(test4(1,2,3,4) == 3);        <font color=green>// instantiate test4!(int, int, int, int)
</font><font color=blue>assert</font>(test4(1.0,2.0,3,4) == 3.0);  <font color=green>// instantiate test4!(double, double, int, int)
</font>
<font color=blue>alias</font> <u>naryFun</u>!(<font color=red>"a+b"</font>,3) test3;      <font color=green>// You can create a fun with more args than necessary, if you wish
</font><font color=blue>assert</font>(test3(1,2,100) == 3);        <font color=green>// without the 3, naryFun!"a+b" would create a binary function.
</font><font color=blue>assert</font>(test3(1.0,2.0,100) == 3.0);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"sin(a)+cos(b)*c"</font> testsincos; <font color=green>// functional2.d imports a lot of other D modules, to have their functions accessible.
</font>
<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"tuple(a,a,a)"</font> toTuple;
<font color=blue>assert</font>(toTuple(1) == tuple(1,1,1));

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"a.expand[1]"</font> tuple1; <font color=green>// tuple1 will be created, but can be used only on types defining a .expand field.
</font><font color=blue>assert</font>(tuple1(toTuple(1)) == 1);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"[b,a,c]"</font> arrayTwister; <font color=green>// will return a static array
</font><font color=blue>assert</font>(arrayTwister(0,1,2) == [1,0,2]);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"f"</font> projection6; <font color=green>// 'a' -&gt; 1 arg, 'b' -&gt; binary, ..., 'f' -&gt; 6-args function. In this case, returning only its sixth argument.
</font><font color=blue>assert</font>(projection6(0,1,2,3,4,5) == 5);

<font color=blue>alias</font> <u>naryFun</u>!<font color=red>"3"</font> test0;               <font color=green>// A 0-arg function. It's exactly: int test0() { return 3;}
</font><font color=blue>assert</font>(test0 == 3);                    <font color=green>// Constant return
</font><font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(test0) == <font color=blue>function</font>)); <font color=green>// But it's a function, not a constant.
</font>
<font color=blue>int</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b) { <font color=blue>return</font> a*b;}
<font color=blue>alias</font> <u>naryFun</u>!(foo) nfoo;           <font color=green>// function test
</font><font color=blue>assert</font>(nfoo(2,3) == 6);

<font color=blue>int</font> bar() { <font color=blue>return</font> 1;}
<font color=blue>alias</font> <u>naryFun</u>!bar nbar;             <font color=green>// 0-arg function test
</font><font color=blue>assert</font>(nbar == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">tuplify</span>
<script>explorer.outline.addDecl('tuplify');</script>

(alias fun)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a function into a tuple-accepting function. Useful to map a standard function
on a tuple-producing range. A parameterless function (zero args) is left untouched.
<br><br>
<b>See Also:</b><br>
tmap, tfilter, comprehension, parallelComprehension in algorithm2.d
<br><br>
<b>Example:</b><br>
<pre class="d_code">string foo3(<font color=blue>int</font> a, string b, <font color=blue>double</font> c) {
    <font color=blue>return</font> to!string(a) ~ <font color=red>"+"</font> ~ b ~ <font color=red>"+"</font> ~ to!string(c);
}

<font color=blue>auto</font> tfoo3 = <u>tuplify</u>!foo3;
<font color=blue>auto</font> t = tuple(1, <font color=red>"a"</font>, 3.0);
<font color=blue>auto</font> result = tfoo3(t);
<font color=blue>assert</font>(result == <font color=red>"1+a+3"</font>);

string foo() {
    <font color=blue>return</font> <font color=red>"aha"</font>;
}
<font color=blue>auto</font> tfoo = <u>tuplify</u>!foo;
<font color=blue>assert</font>(tfoo() == <font color=red>"aha"</font>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Prepare</span>
<script>explorer.outline.addDecl('Prepare');</script>

(alias fun,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Internal template to transform a function or a 'string' function
to be applied on a tuple. The R... part must contains the information
about the args types. It's used to instantiate the correct function
from the template function created by naryFun.
<br><br>
It's used internally by all the tuple-mapping functions: tmap, tfilter, etc.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">construct</span>
<script>explorer.outline.addDecl('construct');</script>

(Struct) if (is(Struct == struct))</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>To Be Documented.
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Jun  3 00:11:58 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm2");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional2");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range2");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits2");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple2");

    explorer.packageExplorer.addModule("dranges.typetuple2");

    explorer.packageExplorer.addModule("dranges.variadic");

</script>
</body></html>


