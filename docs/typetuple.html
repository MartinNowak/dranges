
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.typetuple</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.typetuple");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.typetuple</h1><!-- Generated by Ddoc from dranges\typetuple.d -->
This module defines templates on typetuples (complementary, sometimes similar to std.
<span class="currsymbol">typetuple</span>
<script>explorer.outline.addDecl('typetuple');</script>

/std.traits):
reversing, rotating, extracting, filtering, unfolding, etc, all on typetuples.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud and Simen Kj&aelig;r&aring;s.
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Init</span>
<script>explorer.outline.addDecl('Init');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the .init value of a typetuple. When you have a typetuple (T...)
inside a template, you cannot do (T.init), DMD does not accept it. Use 
<span class="currsymbol">Init</span>
<script>explorer.outline.addDecl('Init');</script>

!T instead.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SameTuple</span>
<script>explorer.outline.addDecl('SameTuple');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compares tuples that might contain a mixture of types and values.
<br><br>
<b>Author:</b><br>
Simen Kj&aelig;r&aring;s.

<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>SameTuple</u>!(FirstTuple).As!(SecondTuple);
</pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>static</font> <font color=blue>assert</font>(<u>SameTuple</u>!(<font color=blue>int</font>, <font color=blue>int</font>).As!(<font color=blue>int</font>, <font color=blue>int</font>));
<font color=blue>static</font> <font color=blue>assert</font>(<u>SameTuple</u>!(<font color=blue>int</font>, <font color=red>"foo"</font>).As!(<font color=blue>int</font>, <font color=red>"foo"</font>));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>SameTuple</u>!(<font color=blue>int</font>, <font color=red>"foo"</font>).As!(<font color=red>"foo"</font>, <font color=blue>int</font>));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Contained</span>
<script>explorer.outline.addDecl('Contained');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks if one tuple contains another.
<br><br>
<b>Author:</b><br>
Simen Kj&aelig;r&aring;s.

<br><br>
<b>Usage:</b><br>
<pre class="d_code"><u>Contained</u>!(SmallTuple).In!(BigTuple);
</pre>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>static</font> <font color=blue>assert</font>(<u>Contained</u>!(<font color=blue>int</font>).In!(<font color=blue>float</font>, <font color=blue>int</font>));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>Contained</u>!(<font color=blue>int</font>).In!(<font color=blue>float</font>, <font color=red>"foo"</font>));
<font color=blue>static</font> <font color=blue>assert</font>(<u>Contained</u>!(<font color=blue>int</font>,<font color=red>"foo"</font>).In!(<font color=blue>float</font>, <font color=blue>int</font>, <font color=red>"foo"</font>, <font color=red>"bar"</font>));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">allTuplesSatisfy</span>
<script>explorer.outline.addDecl('allTuplesSatisfy');</script>

(alias F,uint tupleLength,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Evaluates to <b><font color=blue>F!(T[0..tupleLength]) &amp;&amp; F!(T[tupleLength..2*tupleLength]) &amp;&amp; ... &amp;&amp; F[T[$-tupleLength..$]]</font></b>.
<br><br>
<b>Author:</b><br>
Simen Kj&aelig;r&aring;s.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>static</font> <font color=blue>assert</font>(<u>allTuplesSatisfy</u>!(Contained!(<font color=blue>int</font>).In, 2, <font color=blue>int</font>, <font color=blue>float</font>, <font color=red>"foo"</font>, <font color=blue>int</font>));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>allTuplesSatisfy</u>!(Contained!(<font color=blue>int</font>).In, 2, <font color=blue>int</font>, <font color=blue>float</font>, <font color=red>"foo"</font>,string));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">RepeatTuple</span>
<script>explorer.outline.addDecl('RepeatTuple');</script>

(uint num,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Repeats a type or typetuple <b><font color=blue>num</font></b> times.
<br><br>
<b>Author:</b><br>
Simen Kj&aelig;r&aring;s.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>static</font> <font color=blue>assert</font>(SameTuple!(<u>RepeatTuple</u>!(4, <font color=blue>int</font>)).As!(<font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>int</font>, <font color=blue>int</font>));
<font color=blue>static</font> <font color=blue>assert</font>(SameTuple!(<u>RepeatTuple</u>!(4, <font color=red>"foo"</font>)).As!(<font color=red>"foo"</font>, <font color=red>"foo"</font>, <font color=red>"foo"</font>, <font color=red>"foo"</font>));
<font color=blue>static</font> <font color=blue>assert</font>(SameTuple!(<u>RepeatTuple</u>!(2, <font color=blue>int</font>, <font color=red>"foo"</font>)).As!(<font color=blue>int</font>, <font color=red>"foo"</font>, <font color=blue>int</font>, <font color=red>"foo"</font>));
<font color=blue>static</font> <font color=blue>assert</font>(!SameTuple!(<u>RepeatTuple</u>!(2, <font color=blue>int</font>)).As!());
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ExtractType</span>
<script>explorer.outline.addDecl('ExtractType');</script>

(alias array,R...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Extracts some types from the variadic type tuple R according to the indices given by array (a static array).
[0,1,2] means 'the first, second and third types'. The indices can be repeated or omitted and the array
can be longer than R ([0,1,2,2,3,0,0,2,3]...). In the latter case, the resulting type tuple will obviously be longer
than R.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>ExtractType</u>!([0,1],TT) E1;
<font color=blue>alias</font> <u>ExtractType</u>!([1,0],TT) E2;
<font color=blue>alias</font> <u>ExtractType</u>!([1],TT) E3;
<font color=blue>alias</font> <u>ExtractType</u>!([1,0,2,2,0],TT) E4;

<font color=blue>assert</font>(<font color=blue>is</font>(E1 == TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E2 == TypeTuple!(<font color=blue>double</font>,<font color=blue>int</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E3 == TypeTuple!(<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(E4 == TypeTuple!(<font color=blue>double</font>,<font color=blue>int</font>,string,string,<font color=blue>int</font>)));
</pre>
<br><br>
<b>Note:</b><br>
why a static array instead of free parameters like this: <b><code>
<span class="currsymbol">ExtractType</span>
<script>explorer.outline.addDecl('ExtractType');</script>

!(0,2,3,1, TT)</code></b>? Because the type tuple and the
index list are both of variable length, and the tuple can contain any template parameter, including ints. A simplified version
working only on pure types tuples could use <b><code>StaticTakeWhile</code></b> to get the parameters that are of integral type and then deduce
the rest is the type tuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n,R...) if (R.length &gt; 0 &amp;&amp; n &gt;= 0)<br>template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n,R...) if (R.length &gt; 0 &amp;&amp; n &lt; 0)<br>template 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

(int n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>If n&gt;0, it rotate a TypeTuple on the left by n positions (it takes the first n types and puts them at the end).
for n== 0, it does nothing (it's the identity template).
If n&lt;0, it rotates on the right (takes the last n types and puts them at the beginning).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>RotateTypes</u>!(1,TT) R1;   <font color=green>// (double, string, int)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(0,TT) R0;   <font color=green>// (int, double, string)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(5,TT) R5;   <font color=green>// (string, int, double)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(-1,TT) R_1; <font color=green>// (string, int, double)
</font><font color=blue>alias</font> <u>RotateTypes</u>!(-5,TT) R_5; <font color=green>// (double, string, int)
</font>
<font color=blue>assert</font>(<font color=blue>is</font>(R1 == TypeTuple!(<font color=blue>double</font>,string,<font color=blue>int</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(R0 == TT));
<font color=blue>assert</font>(<font color=blue>is</font>(R5 == TypeTuple!(string,<font color=blue>int</font>,<font color=blue>double</font>))); <font color=green>// equivalent to Rotate!(2,TT)
</font><font color=blue>assert</font>(<font color=blue>is</font>(R_1 == TypeTuple!(string,<font color=blue>int</font>,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(R_5 == TypeTuple!(<font color=blue>double</font>,string,<font color=blue>int</font>))); <font color=green>// equivalent to Rotate!(-2,TT) and also to Rotate!(1,TT)
</font>
<font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>) TT2;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>RotateTypes</u>!(1,TT2) == TT2)); <font color=green>// one type: unchanged by rotation
</font>
<font color=blue>alias</font> StaticFilter!(isIntegral, TT2) F; <font color=green>// double is not an integral type -&gt; F is empty
</font><font color=blue>assert</font>(<font color=blue>is</font>(<u>RotateTypes</u>!(1,F) == F)); <font color=green>// zero type: also unchanged by rotation.
</font></pre>

To Be Documented: curried version: alias 
<span class="currsymbol">RotateTypes</span>
<script>explorer.outline.addDecl('RotateTypes');</script>

!1 R1;<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReverseTypes</span>
<script>explorer.outline.addDecl('ReverseTypes');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a type tuple and reverses it.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string) TT;
<font color=blue>alias</font> <u>ReverseTypes</u>!TT R;
<font color=blue>assert</font>(<font color=blue>is</font>(R == TypeTuple!(string,<font color=blue>double</font>,<font color=blue>int</font>)));

<font color=blue>alias</font> TypeTuple!(<font color=blue>double</font>) TT2;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>ReverseTypes</u>!TT2 == TT2)); <font color=green>// one type: unchanged by inversion.
</font>
<font color=blue>alias</font> StaticFilter!(isIntegral, TT2) F; <font color=green>// double is not an integral type -&gt; F is empty
</font><font color=blue>assert</font>(<font color=blue>is</font>(<u>ReverseTypes</u>!F == F)); <font color=green>// no type: unchanged by inversion.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SwapTypes</span>
<script>explorer.outline.addDecl('SwapTypes');</script>

(size_t i1,size_t i2,R...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Swap the types at index i1 and index i2 in a TypeTuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string, <font color=blue>short</font>) Test;

<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(1,3,Test) == TypeTuple!(<font color=blue>int</font>,<font color=blue>short</font>,string,<font color=blue>double</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(3,1,Test) == TypeTuple!(<font color=blue>int</font>,<font color=blue>short</font>,string,<font color=blue>double</font>)));

<font color=blue>assert</font>(<font color=blue>is</font>(<u>SwapTypes</u>!(1,1,Test) == Test));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SegmentTypes</span>
<script>explorer.outline.addDecl('SegmentTypes');</script>

(int n,T...) if (n &gt; 0 &amp;&amp; T.length % n == 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Cut a typetuple into segments of length n. The segments are <b><code>std.typecons.Tuple</code></b>s, not type tuples,
to avoid auto-flattening. It will not compile if n == 0 or if n do not cut the typetuple in equal parts.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string, <font color=blue>int</font> <font color=blue>delegate</font>()) Types;
<font color=blue>alias</font> <u>SegmentTypes</u>!(2, Types) Segments;
<font color=blue>assert</font>(<font color=blue>is</font>(Segment == TypeTuple!(Tuple!(<font color=blue>int</font>,<font color=blue>double</font>), Tuple!(string, <font color=blue>int</font> <font color=blue>delegate</font>())) ));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">AllEqual</span>
<script>explorer.outline.addDecl('AllEqual');</script>

(alias a,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> iff all elements of the variadic list are equal (as tested by ==).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">AllEqual</span>
<script>explorer.outline.addDecl('AllEqual');</script>

(Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Is <b>true</b> iff all types in the typetuple are equal.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TypeNuple</span>
<script>explorer.outline.addDecl('TypeNuple');</script>

(T,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>creates a TypeTuple of n T's, repeated. If n == 0, it becomes the empty TypeTuple: TypeTuple!().
<pre class="d_code"><font color=blue>alias</font> <u>TypeNuple</u>!(<font color=blue>int</font>, 3) TN3;
<font color=blue>assert</font>(<font color=blue>is</font>(TN3 == TypeTuple!(<font color=blue>int</font>,<font color=blue>int</font>,<font color=blue>int</font>)));
<font color=blue>alias</font> <u>TypeNuple</u>!(<font color=blue>int</font>, 1) TN1;
<font color=blue>assert</font>(<font color=blue>is</font>(TN1 == TypeTuple!(<font color=blue>int</font>)));
<font color=blue>assert</font>(!<font color=blue>is</font>(TN1 == <font color=blue>int</font>)); <font color=green>// TypeTuple!int is not an int.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TypeNuple</span>
<script>explorer.outline.addDecl('TypeNuple');</script>

(alias a,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>ditto
 ditto<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Expansion</span>
<script>explorer.outline.addDecl('Expansion');</script>

(T : U[n],U,size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Transforms a static array into a TypeTuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Expansion</u>!(<font color=blue>int</font>[3]) E; <font color=green>// Gives TypeTuple!(int, int, int).
</font></pre>

<br><br>
<b>Note:</b><br>
int[1] gives TypeTuple!(int), which is not of type int.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FlattenTuple</span>
<script>explorer.outline.addDecl('FlattenTuple');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>D's typetuple automatically flatten, which is interesting on certain occasions, but not when you're
trying to create a deeply nested structure, sich as a tree of types. For those occasions, using std.Typecons.Tuple
is a possibility. This template is for going back: given a typetuple, possibliy containing nested tuples, it flattens
them all and returns a flat typetuple.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string) Flat;
<font color=blue>alias</font> TypeTuple!(Tuple!(<font color=blue>int</font>,<font color=blue>double</font>), string, Tuple!Flat, Tuple!(<font color=blue>int</font>, Tuple!<font color=blue>int</font>)) Nested;

<font color=blue>assert</font>(<font color=blue>is</font>(<u>FlattenTuple</u>!Flat == Flat));
<font color=blue>assert</font>(<font color=blue>is</font>(Flatten!Nested == TypeTuple!(<font color=blue>int</font>,<font color=blue>double</font>,string,<font color=blue>int</font>,<font color=blue>double</font>,string,<font color=blue>int</font>,<font color=blue>int</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Interleave</span>
<script>explorer.outline.addDecl('Interleave');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Usage:</b><br>
<pre class="d_code"><u>Interleave</u>!(FirstTypeTuple).With!(SecondTypeTuple):
</pre>
Given T0, T1, T2, ..., Ti and U0, U1, ... Uj, it will interleavs the types and becomes T0, U0, T1, U1, ...
If one of the tuples is longer than the other, its tail will be appended.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>byte</font>,<font color=blue>short</font>,<font color=blue>int</font>,<font color=blue>long</font>,<font color=blue>ubyte</font>,<font color=blue>ushort</font>,<font color=blue>uint</font>,<font color=blue>ulong</font>) IntegralTypes;
<font color=blue>alias</font> TypeTuple!(<font color=blue>float</font>,<font color=blue>double</font>,<font color=blue>real</font>) FloatTypes;
<font color=blue>alias</font> <u>Interleave</u>!IntegralTypes.With!FloatTypes NumericalTypes;

<font color=blue>assert</font>(<font color=blue>is</font>(NumericalTypes == TypeTuple!(<font color=blue>byte</font>,<font color=blue>float</font>,<font color=blue>short</font>,<font color=blue>double</font>,<font color=blue>int</font>,<font color=blue>real</font>,<font color=blue>long</font>,<font color=blue>ubyte</font>,<font color=blue>ushort</font>,<font color=blue>uint</font>,<font color=blue>ulong</font>)));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticMap</span>
<script>explorer.outline.addDecl('StaticMap');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Just an exercice: blind-coding std.traits.staticMap. Aliases
itself to the TypeTuple (F!T0, F!T1, ...)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticFilter</span>
<script>explorer.outline.addDecl('StaticFilter');</script>

(alias Pred,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The filter equivalent to StaticMap: alias itself to a TypeTuple
containing the types in T that verify the predicate Pred
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>double</font>, string, <font color=blue>long</font>) TT;
<font color=blue>assert</font>(<font color=blue>is</font>(<u>StaticFilter</u>!(isIntegral, TT) == TypeTuple!(<font color=blue>int</font>, <font color=blue>long</font>)));
<font color=blue>assert</font>(<font color=blue>is</font>(<u>StaticFilter</u>!(hasLength2, <font color=blue>int</font>[], <font color=blue>int</font>[3], <font color=blue>int</font>) == TypeTuple!(<font color=blue>int</font>[], <font color=blue>int</font>[3])));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticReduce</span>
<script>explorer.outline.addDecl('StaticReduce');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Aliases itself to a repeated application of the binary template F on the types of T, like reduce
does on ranges.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>template</font> CT(T,T2) {
    <font color=blue>alias</font> CommonType!(T,T2) CT;
}

<font color=blue>template</font> Tup(T1,T2) {
    <font color=blue>alias</font> Tuple!(T1, T2) Tup; <font color=green>// That's std.typecons.Tuple, NOT std.typetuple.TypeTuple
</font>}

<font color=blue>alias</font> <u>StaticReduce</u>!(CT, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>long</font>) SR1; <font color=green>// Equivalent to CommonType!(int,double,int,long)
</font><font color=blue>assert</font>(<font color=blue>is</font>(SR1 == <font color=blue>double</font>));
<font color=blue>alias</font> <u>StaticReduce</u>!(Tup, <font color=blue>int</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>long</font>) SR2;
<font color=blue>assert</font>(<font color=blue>is</font>(SR2 == Tuple!(<font color=blue>int</font>, Tuple!(<font color=blue>double</font>, Tuple!(<font color=blue>int</font>, <font color=blue>long</font>))))); <font color=green>// Non-flattening tuples
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TypeOf</span>
<script>explorer.outline.addDecl('TypeOf');</script>

(alias a)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>alias itself to the type of alias a.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">MapOnAlias</span>
<script>explorer.outline.addDecl('MapOnAlias');</script>

(alias Mapper,alias current,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps the <b><code>Mapper</code></b> template on the alias list.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ReduceOnAlias</span>
<script>explorer.outline.addDecl('ReduceOnAlias');</script>

(alias Reducer,alias current,Rest...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as <b><code>StaticReduce</code></b>, but on an alias list.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticReduce0</span>
<script>explorer.outline.addDecl('StaticReduce0');</script>

(alias F,alias accumulator,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Folds (reduces) the T list, given a reducing template F and an initial accumulator value.
F must be a binary template and accumulator a value accepted by F as first parameter.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticScan</span>
<script>explorer.outline.addDecl('StaticScan');</script>

(alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the TypeTuple resulting from the sucessive applications of F to reduce
the T list.
<br><br>
<b>See Also:</b><br>
<b><code>dranges.algorithm.scan</code></b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticIterate</span>
<script>explorer.outline.addDecl('StaticIterate');</script>

(size_t times,alias F,T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the typetuple (T, F!(T), F!(F!(T)), F!(F!(F!(T))), ...), up to times applications of F.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticIterateOnAlias</span>
<script>explorer.outline.addDecl('StaticIterateOnAlias');</script>

(size_t times,alias F,alias value)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The same, but on an alias list. Useful for iterating on values: 0,1,2,3...<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticUnfold</span>
<script>explorer.outline.addDecl('StaticUnfold');</script>

(size_t times,alias F,State...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a template F and a state State, unfolds F times times.
Applying F on a type must give a typetuple whose first element is the result and the rest
the next state.
<br><br>
<b>See Also:</b><br>
<b><code>dranges.algorithm2.unfold</code></b>, to get some grip on this.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticStride</span>
<script>explorer.outline.addDecl('StaticStride');</script>

(alias step,T...) if (step &gt; 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a typetuple T, gives (T[0], T[step], T[2*step], T[3*step],...)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticTakeWhile</span>
<script>explorer.outline.addDecl('StaticTakeWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes elements in a typetuple as long as the predicate template <b><code>pred</code></b> is <b>true</b>
for the current element.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> TypeTuple!(<font color=blue>int</font>, <font color=blue>short</font>, <font color=blue>byte</font>, <font color=blue>double</font>, <font color=blue>int</font>, <font color=blue>long</font>) Types;
<font color=blue>alias</font> <u>StaticTakeWhile</u>!(isIntegral, Types) FirstIntegrals;
asser(<font color=blue>is</font>( FirstIntegrals == TypeTuple!(<font color=blue>int</font>,<font color=blue>short</font>,<font color=blue>byte</font>))); <font color=green>// stopped when double was encountered
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticDropWhile</span>
<script>explorer.outline.addDecl('StaticDropWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The cousin of <b><code>StaticTakeWhile</code></b>. Drops types from a typetuple as long as the predicate is <b>true</b>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRotateWhile</span>
<script>explorer.outline.addDecl('StaticRotateWhile');</script>

(alias pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Rotates a typetuple as long as the predicate template <b><code>pred</code></b> is <b>true</b> for the first element.
If a complete rotation is done (<b><code>pred</code></b> gives <b>true</b> for all elements of T), <b><code>StaticRotateWhile</code></b> recognizes this and aliases itself to Types
instead of cycling forever...<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias to)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The TypeTuple (0,1,2, ..., to) (to is included)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias from,alias to)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The TypeTuple (from, from+1, ..., to) (to is included)<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">StaticRange</span>
<script>explorer.outline.addDecl('StaticRange');</script>

(alias from,alias to,alias step)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The TypeTuple (from, from+step, from+2*step, ... to). to is not necessarily included if step 'jumps' above it.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">SortTypes</span>
<script>explorer.outline.addDecl('SortTypes');</script>

(alias Pred,Types...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sort types in Types, according to predicate Pred. Pred is a binary template
that must alias itself to 0 if types are equal, to -1 if T1 &lt; T2 and +1 if T1 &gt; T2.
If you do not care for the precise ordering (such as when you just want to verify that two tuples
are the same), you can use dranges.templates.CompareTypes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">NthType</span>
<script>explorer.outline.addDecl('NthType');</script>

(size_t n)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the nth field/type in a TypeTuple. Useful for template composition.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">First</span>
<script>explorer.outline.addDecl('First');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as NthType. Alias itself to the first type in a typetuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Second</span>
<script>explorer.outline.addDecl('Second');</script>

(T...) if (T.length &gt; 1)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as NthType. Alias itself to the second type in a typetuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Last</span>
<script>explorer.outline.addDecl('Last');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to the last type in a TypeTuple. As the previous template, it's sometimes useful
while composing templates.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Tail</span>
<script>explorer.outline.addDecl('Tail');</script>

(T...) if (T.length)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Alias itself to all types except the first in a TypeTuple.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Doubler</span>
<script>explorer.outline.addDecl('Doubler');</script>

(T...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Doubles a TypeTuple. ie: from (int, double), makes a (int,double,int,double).<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Nov 11 21:56:13 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


