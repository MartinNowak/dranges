
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.associative</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.associative");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.associative</h1><!-- Generated by Ddoc from dranges\associative.d -->
Functions acting upon 
<span class="currsymbol">associative</span>
<script>explorer.outline.addDecl('associative');</script>

 arrays: filtering them, etc.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Philippe Sigaud
<br><br>

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">dup</span>
<script>explorer.outline.addDecl('dup');</script>

(K, V)(V[K] <span class="funcparam">aa</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Simple helper function to duplicate an associative array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">AsRange</span>
<script>explorer.outline.addDecl('AsRange');</script>

(K,V);
<br>AsRange!(K,V) 
<span class="currsymbol">asRange</span>
<script>explorer.outline.addDecl('asRange');</script>

(K, V)(V[K] <span class="funcparam">aa</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>There may be a need for an 'asRange' function that takes a container
and returns a range iterating over the entire content. In this particular case, asRange takes
an associative array of type V[K] and returns (K,V) tuples.
It's a random-access range, with a length. opIndexAssign is defined and will
change the original associative array.
<br><br>
<b>Note:</b><br>
I'm a bit ambivalent on this one. front/back returns tuples, because that's the
entire content and because if you only want keys or values, you can use the homonym
properties. But for opIndex (indexed on keys) you already know the key, so it returns
only a value. The same for opIndexApply. I'm wondering if that's OK or not.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> aa = [<font color=red>"Hello"</font>:5, <font color=red>"World!"</font>:6, <font color=red>"a"</font>:99, <font color=red>""</font>:0, <font color=red>"Howdy"</font>:6];
<font color=blue>auto</font> aa_range = aa.asRange;
<font color=blue>assert</font>(equal(aa_range, [tuple(<font color=red>"a"</font>,99), tuple(<font color=red>""</font>,0), tuple(<font color=red>"Hello"</font>,5), tuple(<font color=red>"World!"</font>,6), tuple(<font color=red>"Howdy"</font>,6)][]));
<font color=blue>assert</font>(aa_range.length == 5); <font color=green>// has a length
</font><font color=blue>assert</font>(aa_range[<font color=red>"Hello"</font>] == 5); <font color=green>// opIndex. Returns a value.
</font>aa_range[<font color=red>"Hello"</font>] = 100; <font color=green>// opIndexAssign.
</font><font color=blue>assert</font>(aa[<font color=red>"Hello"</font>] == 100); <font color=green>// changes the original AA.
</font>aa[<font color=red>"Howdy"</font>] = 66; <font color=green>// If we change the original AA after .asRange was called
</font><font color=blue>assert</font>(aa_range[<font color=red>"Howdy"</font>] == 66); <font color=green>// The range presents the udpated view.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(ElementType!(VR))[ElementType!(KR)] 
<span class="currsymbol">toAssoc</span>
<script>explorer.outline.addDecl('toAssoc');</script>

(KR, VR)(KR <span class="funcparam">keysRange</span>, VR <span class="funcparam">valuesRange</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(ElementType!(VR))[ElementType!(KR)] 
<span class="currsymbol">addToAssoc</span>
<script>explorer.outline.addDecl('addToAssoc');</script>

(KR, VR)(Unqual!(ElementType!(VR))[ElementType!(KR)] <span class="funcparam">aa</span>, KR <span class="funcparam">keysRange</span>, VR <span class="funcparam">valuesRange</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(ElementType!(VR))[ElementType!(KR)] 
<span class="currsymbol">addToAssoc</span>
<script>explorer.outline.addDecl('addToAssoc');</script>

(KR, VR)(Unqual!(ElementType!(VR))[ElementType!(KR)] <span class="funcparam">aa</span>, KR <span class="funcparam">keysRange</span>, VR <span class="funcparam">valuesRange</span>, ElementType!(VR) delegate(ElementType!(VR), ElementType!(VR)) <span class="funcparam">onCollision</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">append</span>
<script>explorer.outline.addDecl('append');</script>

(K, V)(V[K] <span class="funcparam">aa</span>, K <span class="funcparam">key</span>, V <span class="funcparam">value</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">prepend</span>
<script>explorer.outline.addDecl('prepend');</script>

(K, V)(V[K] <span class="funcparam">aa</span>, K <span class="funcparam">key</span>, V <span class="funcparam">value</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">filterOnKeys</span>
<script>explorer.outline.addDecl('filterOnKeys');</script>

(alias pred, K, V)(V[K] <span class="funcparam">aa</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Filtering on keys<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isKV</span>
<script>explorer.outline.addDecl('isKV');</script>

(K,V)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A constraint template to detect associative arrays of a certain type. It's a curried (nested) template:

<span class="currsymbol">isKV</span>
<script>explorer.outline.addDecl('isKV');</script>

!(int,string) is itself a template.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>isKV</u>(<font color=blue>int</font>,string) IntString;
<font color=blue>assert</font>(IntString!(string[<font color=blue>int</font>]));
<font color=blue>assert</font>(!IntString!(<font color=blue>double</font>[<font color=blue>int</font>]));
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">merge</span>
<script>explorer.outline.addDecl('merge');</script>

(K, V, T...)(V[K] <span class="funcparam">aa</span>, T <span class="funcparam">aas</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Merge AA.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V[K] 
<span class="currsymbol">mergeWith</span>
<script>explorer.outline.addDecl('mergeWith');</script>

(alias fun = "c", K, V, T...)(V[K] <span class="funcparam">aa</span>, T <span class="funcparam">aas</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Merge AA, with a merging function if some keys exist on more than one array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(R).Types[1][ElementType!(R).Types[0]] 
<span class="currsymbol">toAA</span>
<script>explorer.outline.addDecl('toAA');</script>

(R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(VR)[ElementType!(KR)] 
<span class="currsymbol">toAA</span>
<script>explorer.outline.addDecl('toAA');</script>

(KR, VR)(KR <span class="funcparam">keyRange</span>, VR <span class="funcparam">valueRange</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Wed Nov 10 23:47:30 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.set");

	explorer.packageExplorer.addModule("dranges.stack");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple");

    explorer.packageExplorer.addModule("dranges.tuplepattern");

	explorer.packageExplorer.addModule("dranges.tupletree");

	explorer.packageExplorer.addModule("dranges.typepattern");

    explorer.packageExplorer.addModule("dranges.typetuple");

    explorer.packageExplorer.addModule("dranges.variadic");
</script>
</body></html>


