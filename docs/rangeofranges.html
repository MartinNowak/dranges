
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.rangeofranges</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.rangeofranges");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.rangeofranges</h1><!-- Generated by Ddoc from dranges\rangeofranges.d -->
To Be Documented.
<br><br>
This module contains functions creating or acting upon range of ranges (of whatever rank): mapping them, transforming
a linear range into a range of ranges, zipping them, creating them by tensorial product, etc.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Transpose</span>
<script>explorer.outline.addDecl('Transpose');</script>

(R) if (isRangeOfRanges!(R) &amp;&amp; hasLength2!(R) &amp;&amp; hasLength2!(ElementType!(R)));
<br>UnWrap!("Transpose",R) 
<span class="currsymbol">transpose</span>
<script>explorer.outline.addDecl('transpose');</script>

(R)(R <span class="funcparam">ror</span>);
<br>Transpose!(R) 
<span class="currsymbol">transpose</span>
<script>explorer.outline.addDecl('transpose');</script>

(R)(R <span class="funcparam">ror</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a range of ranges and transposes it. If it's applied a second time, transpose detects this
and gives back the original range. It's a thin wrapper around R: it acts by ref on the subjacent
range.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[][] mat = [[0,1,2,3], [4,5,6,7], [8,9,10,11]];
<font color=green>// transpose(mat) is [[0, 4, 8] [1, 5, 9] [2, 6, 10] [3, 7, 11]]
</font><font color=blue>assert</font>(asString(transpose(transpose(mat))) == asString(mat));
<font color=blue>auto</font> t = transpose(mat);
t[2] = [0,0,0][]; <font color=green>// opIndexAssign
</font><font color=green>// t is [[0, 4, 8] [1, 5, 9] [0, 0, 0] [3, 7, 11]]
</font><font color=blue>auto</font> t2 = transpose(t);
<font color=blue>assert</font>(asString(t2, <font color=red>" "</font>) == <font color=red>"[0, 1, 0, 3] [4, 5, 0, 7] [8, 9, 0, 11]"</font>);
</pre>
<br><br>
<b>TODO:</b><br>
Compare to std.range.transverse, look at std.range.transposed.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Cycle!(Cycle!(ElementType!(R))[]) 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

(R)(R <span class="funcparam">rangeofranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Takes a range of ranges and wraps it around itself to make it a 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

:
each subrange becomes a cycle and the global range is also a cycle. It's an infinite
range whose elements are also all infinite.
If the initial range offers random access, individual elements of a 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

 can be reached
by two applications of opIndex (see in the example below).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>int</font>[][] r1 = [[0,1,2],[3,4,5]];
<font color=blue>auto</font> toroid = <u>torus</u>(r1);

    <font color=green>// toroid is (more or less) :
</font>    <font color=green>//          ......
</font>    <font color=green>// ... 0 1 2 0 1 2 0 1 2 0 1 2 ...
</font>    <font color=green>// ... 3 4 5 3 4 5 3 4 5 3 4 5 ...
</font>    <font color=green>// ... 0 1 2 0 1 2 0 1 2 0 1 2 ...
</font>    <font color=green>// ... 3 4 5 3 4 5 3 4 5 3 4 5 ...
</font>    <font color=green>// ... 0 1 2 0 1 2 0 1 2 0 1 2 ...
</font>    <font color=green>// ... 3 4 5 3 4 5 3 4 5 3 4 5 ...
</font>    <font color=green>//          ......
</font>
<font color=blue>assert</font>(isInfinite!(<font color=blue>typeof</font>(toroid))); <font color=green>// a torus is an infinite range (necklace-like in this direction)
</font>
<font color=blue>foreach</font>(line; take(10, toroid)) <font color=blue>assert</font>(isInfinite!(<font color=blue>typeof</font>(line))); <font color=green>// each element is infinite (a cycle)
</font><font color=blue>assert</font>(equal(take(10, toroid.front), [0,1,2,0,1,2,0,1,2,0][]));
toroid.popFront; <font color=green>// pops the first line
</font><font color=blue>assert</font>(equal(take(10, toroid.front), [3,4,5,3,4,5,3,4,5,3][]));
<font color=blue>assert</font>(equal(take(10, map!<font color=red>"a.front"</font>(toroid)), [3,0,3,0,3,0,3,0,3,0][])); <font color=green>// the front of each element is a cycle
</font><font color=blue>assert</font>(equal(take(10, map!<font color=red>"a[1]"</font>(toroid)), [4,1,4,1,4,1,4,1,4,1][])); <font color=green>// second 'column'
</font><font color=blue>assert</font>(toroid[1][2] == 2); <font color=green>// Elements are accessible with a twofold application of opIndex. second 'line', third 'column' -&gt; '2'
</font><font color=blue>assert</font>(toroid[1][2] == toroid[1 + 2][2 +3]); <font color=green>// Periodic with a period of 2 in a direction, 3 in the other.
</font></pre>
<br><br>
<b>TODO:</b><br>
maybe add an opIndex(i,j) operation, to get 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

[1,2] instead of 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

[1][2].
<br><br>
<b>TODO:</b><br>
some kind of slicing, to extract a rectangular section from the 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

. Maybe with a syntax like 
<span class="currsymbol">torus</span>
<script>explorer.outline.addDecl('torus');</script>

[[1,2],[3,4]]<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(unaryFun!(fun)(E.init)) 
<span class="currsymbol">depthMap</span>
<script>explorer.outline.addDecl('depthMap');</script>

(alias fun, int downToRank = 0, E)(E <span class="funcparam">elem</span>);
<br>Map!(unaryFun!(
<span class="currsymbol">depthMap</span>
<script>explorer.outline.addDecl('depthMap');</script>

!(fun,downToRank,ElementType!(R))),R) 
<span class="currsymbol">depthMap</span>
<script>explorer.outline.addDecl('depthMap');</script>

(alias fun, int downToRank = 0, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps fun at depth downToRank inside a range of ranges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RecursiveMapType!(fun,downToRank,R) 
<span class="currsymbol">recursiveMap</span>
<script>explorer.outline.addDecl('recursiveMap');</script>

(alias fun, int downToRank = 1, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps fun from the bottow (down to rank downToRank) up, calling fun at each level on the result of the previous (innermost) level.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NTake!(R,Indices) 
<span class="currsymbol">nTake</span>
<script>explorer.outline.addDecl('nTake');</script>

(R, Indices...)(R <span class="funcparam">range</span>, Indices <span class="funcparam">indices</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A n-dimensional generalization of take: given a range of ranges of rank k and n&lt;k indices n0, n1, n2, ... , nn, it
will lazily take the first n0 elements of the range, the first n1 elements for each range inside the first, and so on.
It's a 'hypercubic' take, if you want.
<br><br>
So, given a rank-3 range (a range of ranges of ranges) of length 3*4*5, 
<span class="currsymbol">nTake</span>
<script>explorer.outline.addDecl('nTake');</script>

(range, 2, 10, 2) will produce
a rank-3 range of length 2*4*2.
<br><br>

You can give it less indices than the rank of the range: it will left untouched the innermost ranges. So, given the previous
3*4*5 rank-3 range, 
<span class="currsymbol">nTake</span>
<script>explorer.outline.addDecl('nTake');</script>

(range, 2,2) will produce a rank-3 range of dimension 2*2*5 and 
<span class="currsymbol">nTake</span>
<script>explorer.outline.addDecl('nTake');</script>

(range, 2)
is the same than take(range,2) (and returns a rank-3 2*4*5 range).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NDrop!(R,Indices) 
<span class="currsymbol">nDrop</span>
<script>explorer.outline.addDecl('nDrop');</script>

(R, Indices...)(R <span class="funcparam">range</span>, Indices <span class="funcparam">indices</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The same, for drop.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NTake!(NDrop!(R,Indices[__dollar / 2 .. __dollar]),Indices[0 .. __dollar / 2]) 
<span class="currsymbol">nSlice</span>
<script>explorer.outline.addDecl('nSlice');</script>

(R, Indices...)(R <span class="funcparam">range</span>, Indices <span class="funcparam">indices</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TMapType!(fun,R1,R2) 
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

(alias fun, R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
<br>TMapType!(
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

!(fun,R1,ElementType!(R2)),Repeat!(R1),R2) 
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

(alias fun, R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
<br>TMapType!(
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

!(fun,ElementType!(R1),R2),R1,Repeat!(R2)) 
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

(alias fun, R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
<br>TMapType!(
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

!(fun,ElementType!(R1),ElementType!(R2)),R1,R2) 
<span class="currsymbol">recursiveBiMap</span>
<script>explorer.outline.addDecl('recursiveBiMap');</script>

(alias fun, R1, R2)(R1 <span class="funcparam">r1</span>, R2 <span class="funcparam">r2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>maps two range of ranges together.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">TensorProduct!(tuple,TypeNuple!(R,n)) 
<span class="currsymbol">power</span>
<script>explorer.outline.addDecl('power');</script>

(size_t n, R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>
<span class="currsymbol">power</span>
<script>explorer.outline.addDecl('power');</script>

 of a range: a range multiplied (by tensorial product) by itself n times. Generates a range of ranges, of rank n from a range of rank 1 (flat).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TensorProduct</span>
<script>explorer.outline.addDecl('TensorProduct');</script>

(alias fun = tuple,R...) if (R.length &amp;&amp; isForwardRange!(R[__dollar - 1]));
<br>TensorProduct!(fun,R) 
<span class="currsymbol">tensorProduct</span>
<script>explorer.outline.addDecl('tensorProduct');</script>

(alias fun = tuple, R...)(R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The product of n ranges, creating a rank-n range of ranges at the same time.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">RecursiveIndex</span>
<script>explorer.outline.addDecl('RecursiveIndex');</script>

(R...) if (R.length &amp;&amp; isForwardRange!(R[__dollar - 1]));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RecursiveIndex!(R) 
<span class="currsymbol">recursiveIndex</span>
<script>explorer.outline.addDecl('recursiveIndex');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Indexes a range of ranges (of whatever rank): each element is transformed into a tuple(#,#,#, value), the numbers being
the 0-based coordinates. It's a n-dim generalization of indexed.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">rlength</span>
<script>explorer.outline.addDecl('rlength');</script>

(R)(R <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>gives the complete length of a range of ranges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">AsRangeOfRanges</span>
<script>explorer.outline.addDecl('AsRangeOfRanges');</script>

(R) if (isForwardRange!(R));
<br>AsRangeOfRanges!(R) 
<span class="currsymbol">asRangeOfRanges</span>
<script>explorer.outline.addDecl('asRangeOfRanges');</script>

(R)(R <span class="funcparam">r</span>, int <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">NDRangeType!(R,Indices) 
<span class="currsymbol">asNDimRange</span>
<script>explorer.outline.addDecl('asNDimRange');</script>

(R, Indices...)(R <span class="funcparam">r</span>, Indices <span class="funcparam">indices</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(R) 
<span class="currsymbol">nthElement</span>
<script>explorer.outline.addDecl('nthElement');</script>

(R)(R <span class="funcparam">range</span>, size_t <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the 
<span class="currsymbol">nthElement</span>
<script>explorer.outline.addDecl('nthElement');</script>

 of each subrange in a range of range. A transversal slice, if you will.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun May 16 15:31:08 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

	explorer.packageExplorer.addModule("dranges.algorithm2");

	explorer.packageExplorer.addModule("dranges.associative");

	explorer.packageExplorer.addModule("dranges.eager");

	explorer.packageExplorer.addModule("dranges.experiments");

	explorer.packageExplorer.addModule("dranges.functional2");

	explorer.packageExplorer.addModule("dranges.morphism");

	explorer.packageExplorer.addModule("dranges.patternmatch");

	explorer.packageExplorer.addModule("dranges.phobos_extension");

	explorer.packageExplorer.addModule("dranges.predicate");

	explorer.packageExplorer.addModule("dranges.range2");

	explorer.packageExplorer.addModule("dranges.rangeofranges");

	explorer.packageExplorer.addModule("dranges.recursive");

	explorer.packageExplorer.addModule("dranges.reftuple");

	explorer.packageExplorer.addModule("dranges.templates");

	explorer.packageExplorer.addModule("dranges.traits2");

	explorer.packageExplorer.addModule("dranges.treerange");

	explorer.packageExplorer.addModule("dranges.tuple2");

	explorer.packageExplorer.addModule("dranges.typetuple2");

	explorer.packageExplorer.addModule("dranges.variadic");

	
</script>
</body></html>


