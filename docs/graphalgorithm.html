
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dranges.graphalgorithm</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dranges.graphalgorithm");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dranges.graphalgorithm</h1><!-- Generated by Ddoc from dranges\graphalgorithm.d -->
Some algorithms on graphs: extracting the meta-graph, finding path
in the graph and such.
<br><br>
All the algorithms in this module come from their descriptions in
<a href = "http://www.cs.berkeley.edu/~vazirani/algorithms.html">this book</a>.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Node[] 
<span class="currsymbol">explore</span>
<script>explorer.outline.addDecl('explore');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">n</span>, bool[Node] <span class="funcparam">visited</span> = (AssociativeArray!(Node,bool)).init);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Explore a graph <span class="funcparam">g</span> from the node <span class="funcparam">n</span>. The use of recursion makes it similar to depth-first
traversal.
Returns :
An array of nodes, which are the nodes reachable from node <span class="funcparam">n</span>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Node[][] 
<span class="currsymbol">connectedComponents</span>
<script>explorer.outline.addDecl('connectedComponents');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The graph connected components: sub-graphs that are connected.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(Node[],int[Node],int[Node]) 
<span class="currsymbol">clock</span>
<script>explorer.outline.addDecl('clock');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
In a tuple, the nodes sorted by decreasing post number and the pre and post-visit timings of <span class="funcparam">g</span> nodes, in associative arrays pre and post.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Graph 
<span class="currsymbol">reversedGraph</span>
<script>explorer.outline.addDecl('reversedGraph');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The reverse graph of <span class="funcparam">g</span>: same nodes, vertices inverted
(ie: an edge going from A to B becomes an edge from B to A, with the same properties).
This graph is useful in certain algorithms, like decomposing
a graph into its strongly connected components and creating its metagraph.
<br><br>
<b>Note:</b><br>
it's not smart enough to reverse the edges' classification, if any (that would
need distinguishing between forward and tree edges).
<br><br>
<b>See Also:</b><br>
isAcyclic(Graph <span class="funcparam">g</span>).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Node[][] 
<span class="currsymbol">stronglyConnectedComponents</span>
<script>explorer.outline.addDecl('stronglyConnectedComponents');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The list of strongly connected components (the nodes of sub-graphs
where all nodes can be reached from one another).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Graph[] 
<span class="currsymbol">subGraphs</span>
<script>explorer.outline.addDecl('subGraphs');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The subgraphs created by the strongly connected components.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(Graph,Graph[]) 
<span class="currsymbol">metaGraph</span>
<script>explorer.outline.addDecl('metaGraph');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The meta-graph associated to <span class="funcparam">g</span>. That's the graph whose nodes are the subgraphs of <span class="funcparam">g</span>
and the edges the edges between these subgraphs. The meta-graph nodes names are the concatenation
of each subgraphs nodes names.
<br><br>

As is internally calls subGraphs, it returns the resulting subgraphs in a tuple
with the meta-graph proper (the two are mostly used together). The scc list can be obtained
as the subgraphs' nodes.

<br><br>
<b>Note:</b><br>
It could be coded more efficiently: all these successsive functions (reversedGraph - clock
- stronglyConnectedComponents - subGraphs - 
<span class="currsymbol">metaGraph</span>
<script>explorer.outline.addDecl('metaGraph');</script>

) could be integrated into one metagraph function: some
work is duplicated: while we extract the scc, we could create the metanodes and their names, and
get the outgoing edge without having to painfully find them afterwards as is done there.
But, who cares: for my graphs, it takes a fraction of second to find the MG: there is no need right now to spend 2 days to
shave off some ms.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">enum 
<span class="currsymbol">EdgeClassification</span>
<script>explorer.outline.addDecl('EdgeClassification');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">classifyEdges</span>
<script>explorer.outline.addDecl('classifyEdges');</script>

(ref Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Classify edges between Tree&Forward edges, back edges and cross edges, without distinguishing
between Tree and Forward. It will modify the graph, adding properties to the edges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isAcyclic</span>
<script>explorer.outline.addDecl('isAcyclic');</script>

(ref Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
True if the graph is acyclic, <b>false</b> otherwise.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Graph 
<span class="currsymbol">linearize</span>
<script>explorer.outline.addDecl('linearize');</script>

(Graph <span class="funcparam">g</span>, bool <span class="funcparam">testForAcyclic</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The linearized version of a Directed Acyclic Graph (DAG).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint[Node] 
<span class="currsymbol">numNodesFrom</span>
<script>explorer.outline.addDecl('numNodesFrom');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">from</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Returns:</b><br>
The distance (in number of nodes) between node n and all other nodes, as an associative array.
dist(n,n) = 0.
if node B is not reachable <span class="funcparam">from</span> node A, distanceFrom(<span class="funcparam">g</span>, A)[B] = size_t.max;
<br><br>
<b>Remark:</b><br>
another solution would be not to include B as a key in the associative array. Why not?<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(double[Node],Node[Node]) 
<span class="currsymbol">dijkstra</span>
<script>explorer.outline.addDecl('dijkstra');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">begin</span>, bool <span class="funcparam">checkForNegativeLength</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Implements Dijkstra's shortest path algorithm.
It takes for input a Graph <span class="funcparam">g</span> whose edges must have a positive "length" property (the
algorithm expect a length stored as a double). It's a O(N+E) algorithm, where
N is <span class="funcparam">g</span>'s number of nodes and E its number of edges.
<br><br>
A optional parameter, <span class="funcparam">checkForNegativeLength</span> (default to <b>false</b>, no check) forces
the function to verify that each encountered edge length is not negative. It will
throw an Exception if such an edge is found.

<br><br>
<b>Returns:</b><br>
As the other 'shortest path' algortihm in this module,

<span class="currsymbol">dijkstra</span>
<script>explorer.outline.addDecl('dijkstra');</script>

 returns a tuple which has for first field an array containing
the shortest distance from <span class="funcparam">begin</span> to the other nodes (a <b><font color=blue>double[node]</font></b> associative array).
If a node cannot be reached, the distance is ($D double.max).
The second field contains the predecessor of each node in their path to <span class="funcparam">begin</span>: a Node[Node] array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(double[Node],Node[Node]) 
<span class="currsymbol">bellmanFord</span>
<script>explorer.outline.addDecl('bellmanFord');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">begin</span>, bool <span class="funcparam">checkForNegativeCycle</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Implements the Bellman-Ford algorithm for finding the shortest path
in graphs with positive or negative edge length.  It imposes almost
no condition on the graph, but it's a O(N*E) algorithm, where
N is the number of nodes, and E is the number of edges. As such,it could
be slower than dijkstra or dagShortestPath (my own timings on small
graphs show on the contrary Bellman-Ford to be the quickest of the three).
<br><br>
The only condition on the graph is that there must be not negative cycle
(cycles whose total length is negative), but it's a general condition on shortest path algorithms:
if there is a negative cycle, you can take it many times in your path,
each time decreasing the path total length, without limit. An optional argument
<span class="funcparam">checkForNegativeCycle</span> (default value: <b>false</b>) will provoke such a test (it's done at the end
of the computation, so it does not change the global speed of 
<span class="currsymbol">bellmanFord</span>
<script>explorer.outline.addDecl('bellmanFord');</script>

).
<br><br>

As with other 'shortest path' algorithm (dijkstra and dagShortestPath), it takes for input
a Graph and a Node inside the graph and returns a tuple of distances from the node (a double[Node]
associative array) and a previous node tree, on the form of a Node[Node] array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(double[Node],Node[Node]) 
<span class="currsymbol">dagShortestPath</span>
<script>explorer.outline.addDecl('dagShortestPath');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">begin</span>, bool <span class="funcparam">checkForAcyclicity</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Implements a shortest path algorithm for DAG (Directed Acyclic Graphs).
As these can be linearized (with linearize(Graph <span class="funcparam">g</span>)), there is a simple
O(E) algorithm for them.
<br><br>
The optional argument <span class="funcparam">checkForAcyclicity</span> (default: <b>false</b>) forces a check
on <span class="funcparam">g</span>'s acyclicity. In case a cycle is found, an Exception is throw.
<br><br>

As with other 'shortest path' algorithm (dijkstra and bellmanFord), it takes for input
a Graph and a Node inside the graph and returns a tuple of distances from the node (a double[Node]
associative array) and a previous node tree, on the form of a Node[Node] array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(Node[],double) 
<span class="currsymbol">shortestPath</span>
<script>explorer.outline.addDecl('shortestPath');</script>

(alias algo = bellmanFord)(Graph <span class="funcparam">g</span>, Node <span class="funcparam">from</span>, Node <span class="funcparam">to</span>, bool <span class="funcparam">check</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gives the shortest path in g between g's nodes from and to. The algorithm
used is selected by the caller with the template parameter algo. Just pass
the name of the function (it defaults to bellmanFord, the most generic but also
in theory the slowest algorithm).
<br><br>
The optional argument check (default: <b>false</b>), if set to <b>true</b>, uses the 'with checks'
version of the algorithm.

<br><br>
<b>Example:</b><br>
<pre class="d_code">Graph g;
Node from, begin;
<font color=blue>auto</font> path = <u>shortestPath</u>!(dijkstra)(g, from, to).
</pre>
<br><br>
<b>Returns:</b><br>
a tuple of the path (a Node[] array) and the distance (a double).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">eccentricity</span>
<script>explorer.outline.addDecl('eccentricity');</script>

(Graph <span class="funcparam">g</span>, Node <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>the 
<span class="currsymbol">eccentricity</span>
<script>explorer.outline.addDecl('eccentricity');</script>

 of a graph.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">radius</span>
<script>explorer.outline.addDecl('radius');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>the 
<span class="currsymbol">radius</span>
<script>explorer.outline.addDecl('radius');</script>

 of a graph.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">diameter</span>
<script>explorer.outline.addDecl('diameter');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>the 
<span class="currsymbol">diameter</span>
<script>explorer.outline.addDecl('diameter');</script>

 of a graph.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint[Node][Node] 
<span class="currsymbol">accessibilityMatrix</span>
<script>explorer.outline.addDecl('accessibilityMatrix');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>the accessibility matrix.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Graph 
<span class="currsymbol">subgraph</span>
<script>explorer.outline.addDecl('subgraph');</script>

(Graph <span class="funcparam">g</span>, Node[] <span class="funcparam">nodes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Extracts the 
<span class="currsymbol">subgraph</span>
<script>explorer.outline.addDecl('subgraph');</script>

 of <span class="funcparam">g</span> corresponding from the <span class="funcparam">nodes</span> array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Graph 
<span class="currsymbol">minimumSpanningTree</span>
<script>explorer.outline.addDecl('minimumSpanningTree');</script>

(Graph <span class="funcparam">g</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Implements Kruskal's minimum spanning tree algorithm. See algorithms.pdf on p. 139.
The minimum spanning tree of a graph is a tree that connects all the graph's nodes
using lowest possible length/weight for all edges.
<br><br>
<b>Returns:</b><br>
<span class="funcparam">g</span>'s spanning tree, as a Graph.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Jun 13 23:56:49 2010

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("dranges.all");

    explorer.packageExplorer.addModule("dranges.algorithm2");

    explorer.packageExplorer.addModule("dranges.associative");

    explorer.packageExplorer.addModule("dranges.binaryheap");

    explorer.packageExplorer.addModule("dranges.deepdup");

    explorer.packageExplorer.addModule("dranges.eager");

    explorer.packageExplorer.addModule("dranges.experiments");

    explorer.packageExplorer.addModule("dranges.functional2");

    explorer.packageExplorer.addModule("dranges.graph");

    explorer.packageExplorer.addModule("dranges.graphalgorithm");

    explorer.packageExplorer.addModule("dranges.graphrange");

    explorer.packageExplorer.addModule("dranges.morphism");

    explorer.packageExplorer.addModule("dranges.patternmatch");

    explorer.packageExplorer.addModule("dranges.phobos_extension");

    explorer.packageExplorer.addModule("dranges.predicate");

    explorer.packageExplorer.addModule("dranges.priorityqueue");

    explorer.packageExplorer.addModule("dranges.properties");

    explorer.packageExplorer.addModule("dranges.queue");

    explorer.packageExplorer.addModule("dranges.range2");

    explorer.packageExplorer.addModule("dranges.rangeofranges");

    explorer.packageExplorer.addModule("dranges.recursive");

    explorer.packageExplorer.addModule("dranges.reftuple");

    explorer.packageExplorer.addModule("dranges.templates");

    explorer.packageExplorer.addModule("dranges.traits2");

    explorer.packageExplorer.addModule("dranges.treerange");

    explorer.packageExplorer.addModule("dranges.tuple2");

    explorer.packageExplorer.addModule("dranges.typetuple2");

    explorer.packageExplorer.addModule("dranges.variadic");

</script>
</body></html>


